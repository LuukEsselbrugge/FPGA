
barcode.elf:     file format elf32-littlenios2
barcode.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x0018014c

Program Header:
    LOAD off    0x00001000 vaddr 0x00180000 paddr 0x00180000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00180020 paddr 0x00180020 align 2**12
         filesz 0x00002fb4 memsz 0x00002fb4 flags r-x
    LOAD off    0x00003fd4 vaddr 0x00182fd4 paddr 0x00183890 align 2**12
         filesz 0x000008bc memsz 0x000008bc flags rw-
    LOAD off    0x0000514c vaddr 0x0018414c paddr 0x0018414c align 2**12
         filesz 0x00000000 memsz 0x00000628 flags rw-
    LOAD off    0x00005000 vaddr 0x00008000 paddr 0x00184774 align 2**12
         filesz 0x00000080 memsz 0x00000080 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00180000  00180000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   0000012c  00180020  00180020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00002c68  0018014c  0018014c  0000114c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00000220  00182db4  00182db4  00003db4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       000008bc  00182fd4  00183890  00003fd4  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00000628  0018414c  0018414c  0000514c  2**2
                  ALLOC, SMALL_DATA
  6 .VideoRAM     00000000  00000000  00000000  00005080  2**0
                  CONTENTS
  7 .descriptor_memory 00000080  00008000  00184774  00005000  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  8 .onchip_memory 00000000  001847f4  001847f4  00005080  2**0
                  CONTENTS
  9 .comment      00000023  00000000  00000000  00005080  2**0
                  CONTENTS, READONLY
 10 .debug_aranges 00000580  00000000  00000000  000050a8  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   00006e06  00000000  00000000  00005628  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 0000288b  00000000  00000000  0000c42e  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00002cd7  00000000  00000000  0000ecb9  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  000009b4  00000000  00000000  00011990  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00001b50  00000000  00000000  00012344  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    00004bd5  00000000  00000000  00013e94  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_alt_sim_info 00000040  00000000  00000000  00018a6c  2**2
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_ranges 000007c8  00000000  00000000  00018ab0  2**3
                  CONTENTS, READONLY, DEBUGGING
 19 .thread_model 00000003  00000000  00000000  0001af9a  2**0
                  CONTENTS, READONLY
 20 .cpu          00000005  00000000  00000000  0001af9d  2**0
                  CONTENTS, READONLY
 21 .qsys         00000001  00000000  00000000  0001afa2  2**0
                  CONTENTS, READONLY
 22 .simulation_enabled 00000001  00000000  00000000  0001afa3  2**0
                  CONTENTS, READONLY
 23 .stderr_dev   00000009  00000000  00000000  0001afa4  2**0
                  CONTENTS, READONLY
 24 .stdin_dev    00000009  00000000  00000000  0001afad  2**0
                  CONTENTS, READONLY
 25 .stdout_dev   00000009  00000000  00000000  0001afb6  2**0
                  CONTENTS, READONLY
 26 .sopc_system_name 00000013  00000000  00000000  0001afbf  2**0
                  CONTENTS, READONLY
 27 .quartus_project_dir 0000001e  00000000  00000000  0001afd2  2**0
                  CONTENTS, READONLY
 28 .jdi          0000587f  00000000  00000000  0001aff0  2**0
                  CONTENTS, READONLY
 29 .sopcinfo     0008ba38  00000000  00000000  0002086f  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00180000 l    d  .entry	00000000 .entry
00180020 l    d  .exceptions	00000000 .exceptions
0018014c l    d  .text	00000000 .text
00182db4 l    d  .rodata	00000000 .rodata
00182fd4 l    d  .rwdata	00000000 .rwdata
0018414c l    d  .bss	00000000 .bss
00000000 l    d  .VideoRAM	00000000 .VideoRAM
00008000 l    d  .descriptor_memory	00000000 .descriptor_memory
001847f4 l    d  .onchip_memory	00000000 .onchip_memory
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../barcode_bsp//obj/HAL/src/crt0.o
00180184 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_exception_entry.o
00180094 l       .exceptions	00000000 alt_exception_unknown
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 main.c
00000000 l    df *ABS*	00000000 network.c
00000000 l    df *ABS*	00000000 adddf3.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 fixdfsi.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 lib2-mul.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 putchar.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 impure.c
00183734 l     O .rwdata	000000e0 impure_data
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 fvwrite_small_dev.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 alt_load.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_printf.c
00000000 l    df *ABS*	00000000 alt_putchar.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
00183844 l     O .rwdata	00000030 sgdma_rx
00183814 l     O .rwdata	00000030 sgdma_tx
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_sgdma.c
0018239c l     F .text	0000005c alt_avalon_sgdma_irq
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_dcache_flush.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00181df4 g     F .text	0000001c putchar
001820c8 g     F .text	0000002c alt_main
00180760 g     F .text	000000c8 rx_ethernet_isr
00184674 g     O .bss	00000100 alt_irq
00183890 g       *ABS*	00000000 __flash_rwdata_start
00180240 g     F .text	000002cc showText
00182474 g     F .text	00000080 alt_avalon_sgdma_do_sync_transfer
00182600 g     F .text	00000114 alt_avalon_sgdma_construct_descriptor_burst
0018387c g     O .rwdata	00000004 jtag_uart
00182bc8 g     F .text	00000008 altera_nios2_gen2_irq_init
00180000 g     F .entry	0000000c __reset
00182794 g     F .text	00000048 alt_avalon_sgdma_construct_stream_to_mem_desc_burst
00180020 g       *ABS*	00000000 __flash_exceptions_start
00184160 g     O .bss	00000004 errno
00184168 g     O .bss	00000004 alt_argv
0018b874 g       *ABS*	00000000 _gp
001822ac g     F .text	00000004 usleep
00184174 g     O .bss	00000100 charcode
00000000 g       *ABS*	00000000 __alt_mem_VideoRAM
0018414c g     O .bss	00000004 actualCount
00181dec g     F .text	00000008 _putchar_r
00182a5c g     F .text	00000074 alt_find_dev
00181dc4 g     F .text	00000028 memcpy
00181c5c g     F .text	000000dc .hidden __floatsidf
00182804 g     F .text	00000050 alt_avalon_sgdma_construct_mem_to_stream_desc_burst
00182cf8 g     F .text	00000064 .hidden __udivsi3
001801a0 g     F .text	000000a0 drawChars
0018251c g     F .text	0000001c alt_avalon_sgdma_stop
001829e8 g     F .text	00000004 alt_dcache_flush
00180ac4 g     F .text	000008ac .hidden __adddf3
00183874 g     O .rwdata	00000004 _global_impure_ptr
00184774 g       *ABS*	00000000 __bss_end
00182b60 g     F .text	00000068 alt_iic_isr_register
001823f8 g     F .text	0000007c alt_avalon_sgdma_do_async_transfer
00008000 g     O .descriptor_memory	00000020 rx_descriptor_end
00182b48 g     F .text	00000018 alt_ic_irq_enabled
00008000 g       *ABS*	00000000 __alt_mem_descriptor_memory
00184170 g     O .bss	00000004 alt_irq_active
00183334 g     O .rwdata	00000400 tx_frame
001800ec g     F .exceptions	00000060 alt_irq_handler
00182538 g     F .text	0000002c alt_avalon_sgdma_check_descriptor_status
001829ec g     F .text	00000004 alt_dcache_flush_all
00181bdc g     F .text	00000080 .hidden __fixdfsi
00008020 g     O .descriptor_memory	00000020 rx_descriptor
00183890 g       *ABS*	00000000 __ram_rwdata_end
00180000 g       *ABS*	00000000 __alt_mem_onchip_memory
00182fd4 g     O .rwdata	00000360 charTemplate
001822b0 g     F .text	00000060 write
001825b0 g     F .text	00000030 alt_avalon_sgdma_enable_desc_poll
00181e80 g     F .text	00000058 _putc_r
00182fd4 g       *ABS*	00000000 __ram_rodata_end
00182d5c g     F .text	00000058 .hidden __umodsi3
00182854 g     F .text	00000040 alt_avalon_sgdma_construct_mem_to_stream_desc
001824f4 g     F .text	00000010 alt_avalon_sgdma_register_callback
00184150 g     O .bss	00000004 barwidth
001847f4 g       *ABS*	00000000 end
001cb000 g       *ABS*	00000000 __alt_stack_pointer
001825e0 g     F .text	00000020 alt_avalon_sgdma_disable_desc_poll
00181d38 g     F .text	00000064 .hidden __clzsi2
00182368 g     F .text	00000034 altera_avalon_jtag_uart_write
0018275c g     F .text	00000038 alt_avalon_sgdma_construct_mem_to_mem_desc
001827dc g     F .text	00000028 alt_avalon_sgdma_construct_stream_to_mem_desc
001820f4 g     F .text	00000170 alt_printf
00180990 g     F .text	00000004 refresh_ethernet
0018014c g     F .text	0000003c _start
00184154 g     O .bss	00000004 sgdma_tx_dev
00182564 g     F .text	0000004c alt_avalon_sgdma_open
00184158 g     O .bss	00000004 text_length
00182330 g     F .text	00000038 alt_sys_init
00181d9c g     F .text	00000028 .hidden __mulsi3
00182fd4 g       *ABS*	00000000 __ram_rwdata_start
00182db4 g       *ABS*	00000000 __ram_rodata_start
0018050c g     F .text	000001f4 scanBarcode
00182960 g     F .text	00000088 alt_busy_sleep
00182bd0 g     F .text	00000030 memcmp
001847f4 g       *ABS*	00000000 __alt_stack_base
00181370 g     F .text	0000086c .hidden __muldf3
001829f0 g     F .text	0000006c alt_dev_llist_insert
00182504 g     F .text	00000018 alt_avalon_sgdma_start
00181ed8 g     F .text	000000b8 __sfvwrite_small_dev
0018414c g       *ABS*	00000000 __bss_start
00180734 g     F .text	0000002c main
00184164 g     O .bss	00000004 alt_envp
00183880 g     O .rwdata	00000008 alt_sgdma_list
00183888 g     O .rwdata	00000004 alt_errno
00008060 g     O .descriptor_memory	00000020 tx_descriptor
00184274 g     O .bss	00000400 rx_frame
00181e2c g     F .text	00000054 putc
00182c00 g     F .text	00000084 .hidden __divsi3
001809a8 g     F .text	00000068 transmit
00182db4 g       *ABS*	00000000 __flash_rodata_start
00182310 g     F .text	00000020 alt_irq_init
00182ed4 g     O .rodata	00000100 .hidden __clz_tab
00181f90 g     F .text	00000058 _write_r
00183878 g     O .rwdata	00000004 _impure_ptr
0018416c g     O .bss	00000004 alt_argc
00180020 g       .exceptions	00000000 alt_irq_entry
00180994 g     F .text	00000014 tx_char
00180828 g     F .text	00000168 setup
00180020 g       *ABS*	00000000 __ram_exceptions_start
00182ad4 g     F .text	00000004 alt_ic_isr_register
00183890 g       *ABS*	00000000 _edata
001847f4 g       *ABS*	00000000 _end
0018014c g       *ABS*	00000000 __ram_exceptions_end
00180188 g     F .text	00000018 clearText
00180a10 g     F .text	000000b4 tx_ethernet_isr
00182b10 g     F .text	00000038 alt_ic_irq_disable
00008040 g     O .descriptor_memory	00000020 tx_descriptor_end
00182894 g     F .text	00000048 alt_avalon_sgdma_construct_descriptor
00182c84 g     F .text	00000074 .hidden __modsi3
001cb000 g       *ABS*	00000000 __alt_data_end
00180020 g     F .exceptions	00000000 alt_exception
0018415c g     O .bss	00000004 sgdma_rx_dev
00180700 g     F .text	00000034 callback
0018000c g       .entry	00000000 _exit
00181e10 g     F .text	0000001c strlen
00182264 g     F .text	00000048 alt_putchar
00182ad0 g     F .text	00000004 alt_icache_flush_all
0018388c g     O .rwdata	00000004 alt_priority_mask
00182ad8 g     F .text	00000038 alt_ic_irq_enable
00182714 g     F .text	00000048 alt_avalon_sgdma_construct_mem_to_mem_desc_burst
00181fe8 g     F .text	000000e0 alt_load
001828dc g     F .text	00000084 alt_avalon_sgdma_init



Disassembly of section .entry:

00180000 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
  180000:	00400634 	movhi	at,24
    ori r1, r1, %lo(_start)
  180004:	08405314 	ori	at,at,332
    jmp r1
  180008:	0800683a 	jmp	at

0018000c <_exit>:
	...

Disassembly of section .exceptions:

00180020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
  180020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
  180024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
  180028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
  18002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
  180030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
  180034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
  180038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
  18003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
  180040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
  180044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
  180048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
  18004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
  180050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
  180054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
  180058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
  18005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
  180060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
  180064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
  180068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
  18006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
  180070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
  180074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
  180078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
  18007c:	10000326 	beq	r2,zero,18008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
  180080:	20000226 	beq	r4,zero,18008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
  180084:	01800ec0 	call	1800ec <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
  180088:	00000306 	br	180098 <alt_exception_unknown+0x4>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
  18008c:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
  180090:	e8bfff17 	ldw	r2,-4(ea)

00180094 <alt_exception_unknown>:
#ifdef NIOS2_HAS_DEBUG_STUB
       /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
  180094:	003da03a 	break	0
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
  180098:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
  18009c:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
  1800a0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
  1800a4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
  1800a8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
  1800ac:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
  1800b0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
  1800b4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
  1800b8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
  1800bc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
  1800c0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
  1800c4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
  1800c8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
  1800cc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
  1800d0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
  1800d4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
  1800d8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
  1800dc:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
  1800e0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
  1800e4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
  1800e8:	ef80083a 	eret

001800ec <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
  1800ec:	defffe04 	addi	sp,sp,-8
  1800f0:	dfc00115 	stw	ra,4(sp)
  1800f4:	dc000015 	stw	r16,0(sp)
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
  1800f8:	0009313a 	rdctl	r4,ipending
    do
    {
      if (active & mask)
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
  1800fc:	04000634 	movhi	r16,24
  180100:	84119d04 	addi	r16,r16,18036

  active = alt_irq_pending ();

  do
  {
    i = 0;
  180104:	0005883a 	mov	r2,zero
    mask = 1;
  180108:	00c00044 	movi	r3,1
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
  18010c:	20ca703a 	and	r5,r4,r3
  180110:	28000b26 	beq	r5,zero,180140 <alt_irq_handler+0x54>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
  180114:	100490fa 	slli	r2,r2,3
  180118:	8085883a 	add	r2,r16,r2
  18011c:	10c00017 	ldw	r3,0(r2)
  180120:	11000117 	ldw	r4,4(r2)
  180124:	183ee83a 	callr	r3
  180128:	0009313a 	rdctl	r4,ipending

    } while (1);

    active = alt_irq_pending ();
    
  } while (active);
  18012c:	203ff51e 	bne	r4,zero,180104 <alt_irq_handler+0x18>
  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
}
  180130:	dfc00117 	ldw	ra,4(sp)
  180134:	dc000017 	ldw	r16,0(sp)
  180138:	dec00204 	addi	sp,sp,8
  18013c:	f800283a 	ret
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
  180140:	18c7883a 	add	r3,r3,r3
      i++;
  180144:	10800044 	addi	r2,r2,1

    } while (1);
  180148:	003ff006 	br	18010c <alt_irq_handler+0x20>

Disassembly of section .text:

0018014c <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
  18014c:	06c00734 	movhi	sp,28
    ori sp, sp, %lo(__alt_stack_pointer)
  180150:	deec0014 	ori	sp,sp,45056
    movhi gp, %hi(_gp)
  180154:	06800634 	movhi	gp,24
    ori gp, gp, %lo(_gp)
  180158:	d6ae1d14 	ori	gp,gp,47220
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
  18015c:	00800634 	movhi	r2,24
    ori r2, r2, %lo(__bss_start)
  180160:	10905314 	ori	r2,r2,16716

    movhi r3, %hi(__bss_end)
  180164:	00c00634 	movhi	r3,24
    ori r3, r3, %lo(__bss_end)
  180168:	18d1dd14 	ori	r3,r3,18292

    beq r2, r3, 1f
  18016c:	10c00326 	beq	r2,r3,18017c <_start+0x30>

0:
    stw zero, (r2)
  180170:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
  180174:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
  180178:	10fffd36 	bltu	r2,r3,180170 <_start+0x24>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
  18017c:	0181fe80 	call	181fe8 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
  180180:	01820c80 	call	1820c8 <alt_main>

00180184 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
  180184:	003fff06 	br	180184 <alt_after_alt_main>

00180188 <clearText>:
#include "io.h"
#include "altera_avalon_pio_regs.h"

	//Clear all text on screen
	void clearText(){
		for(int x = 0; x < 10000; x+=4){
  180188:	0005883a 	mov	r2,zero
  18018c:	00c9c404 	movi	r3,10000
			IOWR_ALTERA_AVALON_PIO_DATA(x ,(0<<16)| (0<<8) | 0);
  180190:	10000035 	stwio	zero,0(r2)
#include "io.h"
#include "altera_avalon_pio_regs.h"

	//Clear all text on screen
	void clearText(){
		for(int x = 0; x < 10000; x+=4){
  180194:	10800104 	addi	r2,r2,4
  180198:	10fffd1e 	bne	r2,r3,180190 <clearText+0x8>
			IOWR_ALTERA_AVALON_PIO_DATA(x ,(0<<16)| (0<<8) | 0);
		}
	}
  18019c:	f800283a 	ret

001801a0 <drawChars>:

	//Method to draw raw char pixels to VGA output
	void drawChars(int pixels[35][8]){
  1801a0:	defffe04 	addi	sp,sp,-8
  1801a4:	dc000015 	stw	r16,0(sp)
  1801a8:	dfc00115 	stw	ra,4(sp)
  1801ac:	2021883a 	mov	r16,r4
			int totalChars = 35;
			int add = 0;
			int x = 0;
			int linePixelCount = 0;
			clearText();
  1801b0:	01801880 	call	180188 <clearText>
  1801b4:	8009883a 	mov	r4,r16
  1801b8:	82800804 	addi	r10,r16,32
	}

	//Method to draw raw char pixels to VGA output
	void drawChars(int pixels[35][8]){
			int totalChars = 35;
			int add = 0;
  1801bc:	000f883a 	mov	r7,zero
			clearText();
			int pixel = 0;
			while(x < 40*totalChars){
				//Draw all chars to video memory used by VGA controller
				for(int currentChar = 0; currentChar < totalChars; currentChar++){
					for(int bit = 4; bit >= 0; bit--){
  1801c0:	02ffffc4 	movi	r11,-1
			int linePixelCount = 0;
			clearText();
			int pixel = 0;
			while(x < 40*totalChars){
				//Draw all chars to video memory used by VGA controller
				for(int currentChar = 0; currentChar < totalChars; currentChar++){
  1801c4:	03011804 	movi	r12,1120
					for(int bit = 4; bit >= 0; bit--){
						linePixelCount++;
						int val = 0;
						if((pixels[currentChar][pixel] & (1 << bit)) != 0){
							val = 255;
  1801c8:	380d883a 	mov	r6,r7
  1801cc:	0007883a 	mov	r3,zero
			IOWR_ALTERA_AVALON_PIO_DATA(x ,(0<<16)| (0<<8) | 0);
		}
	}

	//Method to draw raw char pixels to VGA output
	void drawChars(int pixels[35][8]){
  1801d0:	3011883a 	mov	r8,r6
  1801d4:	01400104 	movi	r5,4
				//Draw all chars to video memory used by VGA controller
				for(int currentChar = 0; currentChar < totalChars; currentChar++){
					for(int bit = 4; bit >= 0; bit--){
						linePixelCount++;
						int val = 0;
						if((pixels[currentChar][pixel] & (1 << bit)) != 0){
  1801d8:	20db883a 	add	r13,r4,r3
  1801dc:	68800017 	ldw	r2,0(r13)
  1801e0:	1145d83a 	sra	r2,r2,r5
  1801e4:	1080004c 	andi	r2,r2,1
  1801e8:	10000226 	beq	r2,zero,1801f4 <drawChars+0x54>
							val = 255;
  1801ec:	00803fc4 	movi	r2,255
  1801f0:	00000106 	br	1801f8 <drawChars+0x58>
			while(x < 40*totalChars){
				//Draw all chars to video memory used by VGA controller
				for(int currentChar = 0; currentChar < totalChars; currentChar++){
					for(int bit = 4; bit >= 0; bit--){
						linePixelCount++;
						int val = 0;
  1801f4:	0005883a 	mov	r2,zero
						if((pixels[currentChar][pixel] & (1 << bit)) != 0){
							val = 255;
						}
						IOWR_ALTERA_AVALON_PIO_DATA(add ,(val<<16)| (val<<8) | val);
  1801f8:	101c943a 	slli	r14,r2,16
  1801fc:	1012923a 	slli	r9,r2,8
  180200:	7252b03a 	or	r9,r14,r9
  180204:	4884b03a 	or	r2,r9,r2
  180208:	40800035 	stwio	r2,0(r8)
			clearText();
			int pixel = 0;
			while(x < 40*totalChars){
				//Draw all chars to video memory used by VGA controller
				for(int currentChar = 0; currentChar < totalChars; currentChar++){
					for(int bit = 4; bit >= 0; bit--){
  18020c:	297fffc4 	addi	r5,r5,-1
						if((pixels[currentChar][pixel] & (1 << bit)) != 0){
							val = 255;
						}
						IOWR_ALTERA_AVALON_PIO_DATA(add ,(val<<16)| (val<<8) | val);
						x++;
						add+=4;
  180210:	42000104 	addi	r8,r8,4
			clearText();
			int pixel = 0;
			while(x < 40*totalChars){
				//Draw all chars to video memory used by VGA controller
				for(int currentChar = 0; currentChar < totalChars; currentChar++){
					for(int bit = 4; bit >= 0; bit--){
  180214:	2afff11e 	bne	r5,r11,1801dc <drawChars+0x3c>
  180218:	18c00804 	addi	r3,r3,32
  18021c:	31800604 	addi	r6,r6,24
			int linePixelCount = 0;
			clearText();
			int pixel = 0;
			while(x < 40*totalChars){
				//Draw all chars to video memory used by VGA controller
				for(int currentChar = 0; currentChar < totalChars; currentChar++){
  180220:	1b3feb1e 	bne	r3,r12,1801d0 <drawChars+0x30>
  180224:	21000104 	addi	r4,r4,4
						add+=4;
					}
					add+=4;
				}
				if(linePixelCount == (5*totalChars)){
					add+=(800-(24*totalChars));
  180228:	39c0c804 	addi	r7,r7,800
			int add = 0;
			int x = 0;
			int linePixelCount = 0;
			clearText();
			int pixel = 0;
			while(x < 40*totalChars){
  18022c:	513fe61e 	bne	r10,r4,1801c8 <drawChars+0x28>
					add+=(800-(24*totalChars));
					linePixelCount = 0;
				}
				pixel++;
			}
		}
  180230:	dfc00117 	ldw	ra,4(sp)
  180234:	dc000017 	ldw	r16,0(sp)
  180238:	dec00204 	addi	sp,sp,8
  18023c:	f800283a 	ret

00180240 <showText>:


//Draw char array argument on screen
void showText(char *chars){
  180240:	defee504 	addi	sp,sp,-1132
  180244:	dc411915 	stw	r17,1124(sp)
  180248:	dc011815 	stw	r16,1120(sp)
  18024c:	dfc11a15 	stw	ra,1128(sp)
  180250:	2021883a 	mov	r16,r4
  180254:	d807883a 	mov	r3,sp
  180258:	244008c4 	addi	r17,r4,35
	int pixeldata[35][8];
	for(int x = 0; x < 35; x++){
		switch (chars[x]) {
  18025c:	80800007 	ldb	r2,0(r16)
  180260:	01001b44 	movi	r4,109
  180264:	11007026 	beq	r2,r4,180428 <showText+0x1e8>
  180268:	20802616 	blt	r4,r2,180304 <showText+0xc4>
  18026c:	01001984 	movi	r4,102
  180270:	11005926 	beq	r2,r4,1803d8 <showText+0x198>
  180274:	20801116 	blt	r4,r2,1802bc <showText+0x7c>
  180278:	01001884 	movi	r4,98
  18027c:	11004a26 	beq	r2,r4,1803a8 <showText+0x168>
  180280:	20800716 	blt	r4,r2,1802a0 <showText+0x60>
  180284:	01800804 	movi	r6,32
  180288:	11808f26 	beq	r2,r6,1804c8 <showText+0x288>
  18028c:	01001844 	movi	r4,97
  180290:	11008f1e 	bne	r2,r4,1804d0 <showText+0x290>
		  case 'a': memcpy(&pixeldata[x], &charTemplate[0], sizeof(pixeldata[x]) ); break;
  180294:	01400634 	movhi	r5,24
  180298:	294bf504 	addi	r5,r5,12244
  18029c:	00008f06 	br	1804dc <showText+0x29c>

//Draw char array argument on screen
void showText(char *chars){
	int pixeldata[35][8];
	for(int x = 0; x < 35; x++){
		switch (chars[x]) {
  1802a0:	01001904 	movi	r4,100
  1802a4:	11004426 	beq	r2,r4,1803b8 <showText+0x178>
  1802a8:	20804716 	blt	r4,r2,1803c8 <showText+0x188>
		  case 'a': memcpy(&pixeldata[x], &charTemplate[0], sizeof(pixeldata[x]) ); break;
		  case 'b': memcpy(&pixeldata[x], &charTemplate[1], sizeof(pixeldata[x]) ); break;
		  case 'c': memcpy(&pixeldata[x], &charTemplate[2], sizeof(pixeldata[x]) ); break;
  1802ac:	01400634 	movhi	r5,24
  1802b0:	01800804 	movi	r6,32
  1802b4:	294c0504 	addi	r5,r5,12308
  1802b8:	00008806 	br	1804dc <showText+0x29c>

//Draw char array argument on screen
void showText(char *chars){
	int pixeldata[35][8];
	for(int x = 0; x < 35; x++){
		switch (chars[x]) {
  1802bc:	01001a44 	movi	r4,105
  1802c0:	11004d26 	beq	r2,r4,1803f8 <showText+0x1b8>
  1802c4:	20800816 	blt	r4,r2,1802e8 <showText+0xa8>
  1802c8:	010019c4 	movi	r4,103
  1802cc:	11004626 	beq	r2,r4,1803e8 <showText+0x1a8>
  1802d0:	01001a04 	movi	r4,104
  1802d4:	11007e1e 	bne	r2,r4,1804d0 <showText+0x290>
		  case 'c': memcpy(&pixeldata[x], &charTemplate[2], sizeof(pixeldata[x]) ); break;
		  case 'd': memcpy(&pixeldata[x], &charTemplate[3], sizeof(pixeldata[x]) ); break;
		  case 'e': memcpy(&pixeldata[x], &charTemplate[4], sizeof(pixeldata[x]) ); break;
		  case 'f': memcpy(&pixeldata[x], &charTemplate[5], sizeof(pixeldata[x]) ); break;
		  case 'g': memcpy(&pixeldata[x], &charTemplate[6], sizeof(pixeldata[x]) ); break;
		  case 'h': memcpy(&pixeldata[x], &charTemplate[7], sizeof(pixeldata[x]) ); break;
  1802d8:	01400634 	movhi	r5,24
  1802dc:	01800804 	movi	r6,32
  1802e0:	294c2d04 	addi	r5,r5,12468
  1802e4:	00007d06 	br	1804dc <showText+0x29c>

//Draw char array argument on screen
void showText(char *chars){
	int pixeldata[35][8];
	for(int x = 0; x < 35; x++){
		switch (chars[x]) {
  1802e8:	01001ac4 	movi	r4,107
  1802ec:	11004626 	beq	r2,r4,180408 <showText+0x1c8>
  1802f0:	20804916 	blt	r4,r2,180418 <showText+0x1d8>
		  case 'e': memcpy(&pixeldata[x], &charTemplate[4], sizeof(pixeldata[x]) ); break;
		  case 'f': memcpy(&pixeldata[x], &charTemplate[5], sizeof(pixeldata[x]) ); break;
		  case 'g': memcpy(&pixeldata[x], &charTemplate[6], sizeof(pixeldata[x]) ); break;
		  case 'h': memcpy(&pixeldata[x], &charTemplate[7], sizeof(pixeldata[x]) ); break;
		  case 'i': memcpy(&pixeldata[x], &charTemplate[8], sizeof(pixeldata[x]) ); break;
		  case 'j': memcpy(&pixeldata[x], &charTemplate[9], sizeof(pixeldata[x]) ); break;
  1802f4:	01400634 	movhi	r5,24
  1802f8:	01800804 	movi	r6,32
  1802fc:	294c3d04 	addi	r5,r5,12532
  180300:	00007606 	br	1804dc <showText+0x29c>

//Draw char array argument on screen
void showText(char *chars){
	int pixeldata[35][8];
	for(int x = 0; x < 35; x++){
		switch (chars[x]) {
  180304:	01001d04 	movi	r4,116
  180308:	11005b26 	beq	r2,r4,180478 <showText+0x238>
  18030c:	20801216 	blt	r4,r2,180358 <showText+0x118>
  180310:	01001c04 	movi	r4,112
  180314:	11004c26 	beq	r2,r4,180448 <showText+0x208>
  180318:	20800816 	blt	r4,r2,18033c <showText+0xfc>
  18031c:	01001b84 	movi	r4,110
  180320:	11004526 	beq	r2,r4,180438 <showText+0x1f8>
  180324:	01001bc4 	movi	r4,111
  180328:	1100691e 	bne	r2,r4,1804d0 <showText+0x290>
		  case 'j': memcpy(&pixeldata[x], &charTemplate[9], sizeof(pixeldata[x]) ); break;
		  case 'k': memcpy(&pixeldata[x], &charTemplate[10], sizeof(pixeldata[x]) ); break;
		  case 'l': memcpy(&pixeldata[x], &charTemplate[11], sizeof(pixeldata[x]) ); break;
		  case 'm': memcpy(&pixeldata[x], &charTemplate[12], sizeof(pixeldata[x]) ); break;
		  case 'n': memcpy(&pixeldata[x], &charTemplate[13], sizeof(pixeldata[x]) ); break;
		  case 'o': memcpy(&pixeldata[x], &charTemplate[14], sizeof(pixeldata[x]) ); break;
  18032c:	01400634 	movhi	r5,24
  180330:	01800804 	movi	r6,32
  180334:	294c6504 	addi	r5,r5,12692
  180338:	00006806 	br	1804dc <showText+0x29c>

//Draw char array argument on screen
void showText(char *chars){
	int pixeldata[35][8];
	for(int x = 0; x < 35; x++){
		switch (chars[x]) {
  18033c:	01001c84 	movi	r4,114
  180340:	11004526 	beq	r2,r4,180458 <showText+0x218>
  180344:	20804816 	blt	r4,r2,180468 <showText+0x228>
		  case 'l': memcpy(&pixeldata[x], &charTemplate[11], sizeof(pixeldata[x]) ); break;
		  case 'm': memcpy(&pixeldata[x], &charTemplate[12], sizeof(pixeldata[x]) ); break;
		  case 'n': memcpy(&pixeldata[x], &charTemplate[13], sizeof(pixeldata[x]) ); break;
		  case 'o': memcpy(&pixeldata[x], &charTemplate[14], sizeof(pixeldata[x]) ); break;
		  case 'p': memcpy(&pixeldata[x], &charTemplate[15], sizeof(pixeldata[x]) ); break;
		  case 'q': memcpy(&pixeldata[x], &charTemplate[16], sizeof(pixeldata[x]) ); break;
  180348:	01400634 	movhi	r5,24
  18034c:	01800804 	movi	r6,32
  180350:	294c7504 	addi	r5,r5,12756
  180354:	00006106 	br	1804dc <showText+0x29c>

//Draw char array argument on screen
void showText(char *chars){
	int pixeldata[35][8];
	for(int x = 0; x < 35; x++){
		switch (chars[x]) {
  180358:	01001dc4 	movi	r4,119
  18035c:	11004e26 	beq	r2,r4,180498 <showText+0x258>
  180360:	20800816 	blt	r4,r2,180384 <showText+0x144>
  180364:	01001d44 	movi	r4,117
  180368:	11004726 	beq	r2,r4,180488 <showText+0x248>
  18036c:	01001d84 	movi	r4,118
  180370:	1100571e 	bne	r2,r4,1804d0 <showText+0x290>
		  case 'q': memcpy(&pixeldata[x], &charTemplate[16], sizeof(pixeldata[x]) ); break;
		  case 'r': memcpy(&pixeldata[x], &charTemplate[17], sizeof(pixeldata[x]) ); break;
		  case 's': memcpy(&pixeldata[x], &charTemplate[18], sizeof(pixeldata[x]) ); break;
		  case 't': memcpy(&pixeldata[x], &charTemplate[19], sizeof(pixeldata[x]) ); break;
		  case 'u': memcpy(&pixeldata[x], &charTemplate[20], sizeof(pixeldata[x]) ); break;
		  case 'v': memcpy(&pixeldata[x], &charTemplate[21], sizeof(pixeldata[x]) ); break;
  180374:	01400634 	movhi	r5,24
  180378:	01800804 	movi	r6,32
  18037c:	294c9d04 	addi	r5,r5,12916
  180380:	00005606 	br	1804dc <showText+0x29c>

//Draw char array argument on screen
void showText(char *chars){
	int pixeldata[35][8];
	for(int x = 0; x < 35; x++){
		switch (chars[x]) {
  180384:	01001e44 	movi	r4,121
  180388:	11004b26 	beq	r2,r4,1804b8 <showText+0x278>
  18038c:	11004616 	blt	r2,r4,1804a8 <showText+0x268>
  180390:	01001e84 	movi	r4,122
  180394:	11004e1e 	bne	r2,r4,1804d0 <showText+0x290>
		  case 'u': memcpy(&pixeldata[x], &charTemplate[20], sizeof(pixeldata[x]) ); break;
		  case 'v': memcpy(&pixeldata[x], &charTemplate[21], sizeof(pixeldata[x]) ); break;
		  case 'w': memcpy(&pixeldata[x], &charTemplate[22], sizeof(pixeldata[x]) ); break;
		  case 'x': memcpy(&pixeldata[x], &charTemplate[23], sizeof(pixeldata[x]) ); break;
		  case 'y': memcpy(&pixeldata[x], &charTemplate[24], sizeof(pixeldata[x]) ); break;
		  case 'z': memcpy(&pixeldata[x], &charTemplate[25], sizeof(pixeldata[x]) ); break;
  180398:	01400634 	movhi	r5,24
  18039c:	01800804 	movi	r6,32
  1803a0:	294cbd04 	addi	r5,r5,13044
  1803a4:	00004d06 	br	1804dc <showText+0x29c>
void showText(char *chars){
	int pixeldata[35][8];
	for(int x = 0; x < 35; x++){
		switch (chars[x]) {
		  case 'a': memcpy(&pixeldata[x], &charTemplate[0], sizeof(pixeldata[x]) ); break;
		  case 'b': memcpy(&pixeldata[x], &charTemplate[1], sizeof(pixeldata[x]) ); break;
  1803a8:	01400634 	movhi	r5,24
  1803ac:	01800804 	movi	r6,32
  1803b0:	294bfd04 	addi	r5,r5,12276
  1803b4:	00004906 	br	1804dc <showText+0x29c>
		  case 'c': memcpy(&pixeldata[x], &charTemplate[2], sizeof(pixeldata[x]) ); break;
		  case 'd': memcpy(&pixeldata[x], &charTemplate[3], sizeof(pixeldata[x]) ); break;
  1803b8:	01400634 	movhi	r5,24
  1803bc:	01800804 	movi	r6,32
  1803c0:	294c0d04 	addi	r5,r5,12340
  1803c4:	00004506 	br	1804dc <showText+0x29c>
		  case 'e': memcpy(&pixeldata[x], &charTemplate[4], sizeof(pixeldata[x]) ); break;
  1803c8:	01400634 	movhi	r5,24
  1803cc:	01800804 	movi	r6,32
  1803d0:	294c1504 	addi	r5,r5,12372
  1803d4:	00004106 	br	1804dc <showText+0x29c>
		  case 'f': memcpy(&pixeldata[x], &charTemplate[5], sizeof(pixeldata[x]) ); break;
  1803d8:	01400634 	movhi	r5,24
  1803dc:	01800804 	movi	r6,32
  1803e0:	294c1d04 	addi	r5,r5,12404
  1803e4:	00003d06 	br	1804dc <showText+0x29c>
		  case 'g': memcpy(&pixeldata[x], &charTemplate[6], sizeof(pixeldata[x]) ); break;
  1803e8:	01400634 	movhi	r5,24
  1803ec:	01800804 	movi	r6,32
  1803f0:	294c2504 	addi	r5,r5,12436
  1803f4:	00003906 	br	1804dc <showText+0x29c>
		  case 'h': memcpy(&pixeldata[x], &charTemplate[7], sizeof(pixeldata[x]) ); break;
		  case 'i': memcpy(&pixeldata[x], &charTemplate[8], sizeof(pixeldata[x]) ); break;
  1803f8:	01400634 	movhi	r5,24
  1803fc:	01800804 	movi	r6,32
  180400:	294c3504 	addi	r5,r5,12500
  180404:	00003506 	br	1804dc <showText+0x29c>
		  case 'j': memcpy(&pixeldata[x], &charTemplate[9], sizeof(pixeldata[x]) ); break;
		  case 'k': memcpy(&pixeldata[x], &charTemplate[10], sizeof(pixeldata[x]) ); break;
  180408:	01400634 	movhi	r5,24
  18040c:	01800804 	movi	r6,32
  180410:	294c4504 	addi	r5,r5,12564
  180414:	00003106 	br	1804dc <showText+0x29c>
		  case 'l': memcpy(&pixeldata[x], &charTemplate[11], sizeof(pixeldata[x]) ); break;
  180418:	01400634 	movhi	r5,24
  18041c:	01800804 	movi	r6,32
  180420:	294c4d04 	addi	r5,r5,12596
  180424:	00002d06 	br	1804dc <showText+0x29c>
		  case 'm': memcpy(&pixeldata[x], &charTemplate[12], sizeof(pixeldata[x]) ); break;
  180428:	01400634 	movhi	r5,24
  18042c:	01800804 	movi	r6,32
  180430:	294c5504 	addi	r5,r5,12628
  180434:	00002906 	br	1804dc <showText+0x29c>
		  case 'n': memcpy(&pixeldata[x], &charTemplate[13], sizeof(pixeldata[x]) ); break;
  180438:	01400634 	movhi	r5,24
  18043c:	01800804 	movi	r6,32
  180440:	294c5d04 	addi	r5,r5,12660
  180444:	00002506 	br	1804dc <showText+0x29c>
		  case 'o': memcpy(&pixeldata[x], &charTemplate[14], sizeof(pixeldata[x]) ); break;
		  case 'p': memcpy(&pixeldata[x], &charTemplate[15], sizeof(pixeldata[x]) ); break;
  180448:	01400634 	movhi	r5,24
  18044c:	01800804 	movi	r6,32
  180450:	294c6d04 	addi	r5,r5,12724
  180454:	00002106 	br	1804dc <showText+0x29c>
		  case 'q': memcpy(&pixeldata[x], &charTemplate[16], sizeof(pixeldata[x]) ); break;
		  case 'r': memcpy(&pixeldata[x], &charTemplate[17], sizeof(pixeldata[x]) ); break;
  180458:	01400634 	movhi	r5,24
  18045c:	01800804 	movi	r6,32
  180460:	294c7d04 	addi	r5,r5,12788
  180464:	00001d06 	br	1804dc <showText+0x29c>
		  case 's': memcpy(&pixeldata[x], &charTemplate[18], sizeof(pixeldata[x]) ); break;
  180468:	01400634 	movhi	r5,24
  18046c:	01800804 	movi	r6,32
  180470:	294c8504 	addi	r5,r5,12820
  180474:	00001906 	br	1804dc <showText+0x29c>
		  case 't': memcpy(&pixeldata[x], &charTemplate[19], sizeof(pixeldata[x]) ); break;
  180478:	01400634 	movhi	r5,24
  18047c:	01800804 	movi	r6,32
  180480:	294c8d04 	addi	r5,r5,12852
  180484:	00001506 	br	1804dc <showText+0x29c>
		  case 'u': memcpy(&pixeldata[x], &charTemplate[20], sizeof(pixeldata[x]) ); break;
  180488:	01400634 	movhi	r5,24
  18048c:	01800804 	movi	r6,32
  180490:	294c9504 	addi	r5,r5,12884
  180494:	00001106 	br	1804dc <showText+0x29c>
		  case 'v': memcpy(&pixeldata[x], &charTemplate[21], sizeof(pixeldata[x]) ); break;
		  case 'w': memcpy(&pixeldata[x], &charTemplate[22], sizeof(pixeldata[x]) ); break;
  180498:	01400634 	movhi	r5,24
  18049c:	01800804 	movi	r6,32
  1804a0:	294ca504 	addi	r5,r5,12948
  1804a4:	00000d06 	br	1804dc <showText+0x29c>
		  case 'x': memcpy(&pixeldata[x], &charTemplate[23], sizeof(pixeldata[x]) ); break;
  1804a8:	01400634 	movhi	r5,24
  1804ac:	01800804 	movi	r6,32
  1804b0:	294cad04 	addi	r5,r5,12980
  1804b4:	00000906 	br	1804dc <showText+0x29c>
		  case 'y': memcpy(&pixeldata[x], &charTemplate[24], sizeof(pixeldata[x]) ); break;
  1804b8:	01400634 	movhi	r5,24
  1804bc:	01800804 	movi	r6,32
  1804c0:	294cb504 	addi	r5,r5,13012
  1804c4:	00000506 	br	1804dc <showText+0x29c>
		  case 'z': memcpy(&pixeldata[x], &charTemplate[25], sizeof(pixeldata[x]) ); break;
		  case ' ': memcpy(&pixeldata[x], &charTemplate[26], sizeof(pixeldata[x]) ); break;
  1804c8:	100d883a 	mov	r6,r2
  1804cc:	00000106 	br	1804d4 <showText+0x294>
		  default: memcpy(&pixeldata[x], &charTemplate[26], sizeof(pixeldata[x]) );
  1804d0:	01800804 	movi	r6,32
  1804d4:	01400634 	movhi	r5,24
  1804d8:	294cc504 	addi	r5,r5,13076
  1804dc:	1809883a 	mov	r4,r3
  1804e0:	0181dc40 	call	181dc4 <memcpy>
  1804e4:	84000044 	addi	r16,r16,1
  1804e8:	10c00804 	addi	r3,r2,32


//Draw char array argument on screen
void showText(char *chars){
	int pixeldata[35][8];
	for(int x = 0; x < 35; x++){
  1804ec:	847f5b1e 	bne	r16,r17,18025c <showText+0x1c>
		  default: memcpy(&pixeldata[x], &charTemplate[26], sizeof(pixeldata[x]) );

		 }
	}

	drawChars(pixeldata);
  1804f0:	d809883a 	mov	r4,sp
  1804f4:	01801a00 	call	1801a0 <drawChars>
}
  1804f8:	dfc11a17 	ldw	ra,1128(sp)
  1804fc:	dc411917 	ldw	r17,1124(sp)
  180500:	dc011817 	ldw	r16,1120(sp)
  180504:	dec11b04 	addi	sp,sp,1132
  180508:	f800283a 	ret

0018050c <scanBarcode>:

//Method for decoding the barcode based on pixel data from VGA
char charcode[256] = {};
int barwidth = 0;
int actualCount = 0;
void scanBarcode(){
  18050c:	defff704 	addi	sp,sp,-36
  180510:	dcc00315 	stw	r19,12(sp)
				countingBarWidth = 0;
				charcode[actualCount] = '0';
				actualCount++;
			}
		}else{
			charcode[actualCount] = '1';
  180514:	04c00634 	movhi	r19,24

//Method for decoding the barcode based on pixel data from VGA
char charcode[256] = {};
int barwidth = 0;
int actualCount = 0;
void scanBarcode(){
  180518:	dc800215 	stw	r18,8(sp)
  18051c:	dc400115 	stw	r17,4(sp)
  180520:	dc000015 	stw	r16,0(sp)
  180524:	dfc00815 	stw	ra,32(sp)
  180528:	ddc00715 	stw	r23,28(sp)
  18052c:	dd800615 	stw	r22,24(sp)
  180530:	dd400515 	stw	r21,20(sp)
  180534:	dd000415 	stw	r20,16(sp)
	int firstBit = 0;
	int countingBarWidth = 1;
	barwidth = 0;
  180538:	d0223715 	stw	zero,-30500(gp)
	actualCount = 0;
  18053c:	d0223615 	stw	zero,-30504(gp)

	//Calculate all pixels based on VGA pixel's
	for(int x =0; x < 255; x++){
  180540:	0021883a 	mov	r16,zero
char charcode[256] = {};
int barwidth = 0;
int actualCount = 0;
void scanBarcode(){
	int firstBit = 0;
	int countingBarWidth = 1;
  180544:	04800044 	movi	r18,1
//Method for decoding the barcode based on pixel data from VGA
char charcode[256] = {};
int barwidth = 0;
int actualCount = 0;
void scanBarcode(){
	int firstBit = 0;
  180548:	0023883a 	mov	r17,zero
				countingBarWidth = 0;
				charcode[actualCount] = '0';
				actualCount++;
			}
		}else{
			charcode[actualCount] = '1';
  18054c:	9cd05d04 	addi	r19,r19,16756
	barwidth = 0;
	actualCount = 0;

	//Calculate all pixels based on VGA pixel's
	for(int x =0; x < 255; x++){
		IOWR_ALTERA_AVALON_PIO_DATA(0x4020, x);
  180550:	00900804 	movi	r2,16416
  180554:	14000035 	stwio	r16,0(r2)
		int r = IORD_ALTERA_AVALON_PIO_DATA(0x4000);
  180558:	00900004 	movi	r2,16384
  18055c:	15000037 	ldwio	r20,0(r2)
		int g = IORD_ALTERA_AVALON_PIO_DATA(0x4010);
  180560:	00900404 	movi	r2,16400
  180564:	15c00037 	ldwio	r23,0(r2)
		int b = IORD_ALTERA_AVALON_PIO_DATA(0x4040);
  180568:	00901004 	movi	r2,16448
  18056c:	15800037 	ldwio	r22,0(r2)

		int grey =  0.2126*r + 0.7152*g + 0.0722*b;
		usleep(5100);
  180570:	0104fb04 	movi	r4,5100
  180574:	01822ac0 	call	1822ac <usleep>
		if(grey > 128){
  180578:	a009883a 	mov	r4,r20
  18057c:	0181c5c0 	call	181c5c <__floatsidf>
  180580:	0183e474 	movhi	r6,3985
  180584:	01cff2f4 	movhi	r7,16331
  180588:	31a5af04 	addi	r6,r6,-26948
  18058c:	39cd9e84 	addi	r7,r7,13946
  180590:	180b883a 	mov	r5,r3
  180594:	1009883a 	mov	r4,r2
  180598:	01813700 	call	181370 <__muldf3>
  18059c:	b809883a 	mov	r4,r23
  1805a0:	102b883a 	mov	r21,r2
  1805a4:	1829883a 	mov	r20,r3
  1805a8:	0181c5c0 	call	181c5c <__floatsidf>
  1805ac:	018710f4 	movhi	r6,7235
  1805b0:	01cff9f4 	movhi	r7,16359
  1805b4:	318b2944 	addi	r6,r6,11429
  1805b8:	39f8bac4 	addi	r7,r7,-7445
  1805bc:	1009883a 	mov	r4,r2
  1805c0:	180b883a 	mov	r5,r3
  1805c4:	01813700 	call	181370 <__muldf3>
  1805c8:	a00b883a 	mov	r5,r20
  1805cc:	100d883a 	mov	r6,r2
  1805d0:	180f883a 	mov	r7,r3
  1805d4:	a809883a 	mov	r4,r21
  1805d8:	0180ac40 	call	180ac4 <__adddf3>
  1805dc:	b009883a 	mov	r4,r22
  1805e0:	102b883a 	mov	r21,r2
  1805e4:	1829883a 	mov	r20,r3
  1805e8:	0181c5c0 	call	181c5c <__floatsidf>
  1805ec:	01bfb174 	movhi	r6,65221
  1805f0:	01cfecb4 	movhi	r7,16306
  1805f4:	319b5744 	addi	r6,r6,27997
  1805f8:	39deec84 	addi	r7,r7,31666
  1805fc:	1009883a 	mov	r4,r2
  180600:	180b883a 	mov	r5,r3
  180604:	01813700 	call	181370 <__muldf3>
  180608:	100d883a 	mov	r6,r2
  18060c:	180f883a 	mov	r7,r3
  180610:	a809883a 	mov	r4,r21
  180614:	a00b883a 	mov	r5,r20
  180618:	0180ac40 	call	180ac4 <__adddf3>
  18061c:	1009883a 	mov	r4,r2
  180620:	180b883a 	mov	r5,r3
  180624:	0181bdc0 	call	181bdc <__fixdfsi>
  180628:	01002004 	movi	r4,128
  18062c:	00c00044 	movi	r3,1
  180630:	2080090e 	bge	r4,r2,180658 <scanBarcode+0x14c>
			if(firstBit==1){
  180634:	88c0141e 	bne	r17,r3,180688 <scanBarcode+0x17c>
				countingBarWidth = 0;
				charcode[actualCount] = '0';
  180638:	d0a23617 	ldw	r2,-30504(gp)
  18063c:	01000c04 	movi	r4,48

		int grey =  0.2126*r + 0.7152*g + 0.0722*b;
		usleep(5100);
		if(grey > 128){
			if(firstBit==1){
				countingBarWidth = 0;
  180640:	0025883a 	mov	r18,zero
				charcode[actualCount] = '0';
  180644:	9887883a 	add	r3,r19,r2
				actualCount++;
  180648:	10800044 	addi	r2,r2,1
		int grey =  0.2126*r + 0.7152*g + 0.0722*b;
		usleep(5100);
		if(grey > 128){
			if(firstBit==1){
				countingBarWidth = 0;
				charcode[actualCount] = '0';
  18064c:	19000005 	stb	r4,0(r3)
				actualCount++;
  180650:	d0a23615 	stw	r2,-30504(gp)
  180654:	00000f06 	br	180694 <scanBarcode+0x188>
			}
		}else{
			charcode[actualCount] = '1';
  180658:	d0a23617 	ldw	r2,-30504(gp)
  18065c:	01400c44 	movi	r5,49
  180660:	9889883a 	add	r4,r19,r2
			actualCount++;
  180664:	10800044 	addi	r2,r2,1
				countingBarWidth = 0;
				charcode[actualCount] = '0';
				actualCount++;
			}
		}else{
			charcode[actualCount] = '1';
  180668:	21400005 	stb	r5,0(r4)
			actualCount++;
  18066c:	d0a23615 	stw	r2,-30504(gp)
			if(countingBarWidth == 1){
  180670:	90c0071e 	bne	r18,r3,180690 <scanBarcode+0x184>
				barwidth++;
  180674:	d0a23717 	ldw	r2,-30500(gp)
			}
			firstBit = 1;
  180678:	9023883a 	mov	r17,r18
			}
		}else{
			charcode[actualCount] = '1';
			actualCount++;
			if(countingBarWidth == 1){
				barwidth++;
  18067c:	10800044 	addi	r2,r2,1
  180680:	d0a23715 	stw	r2,-30500(gp)
  180684:	00000306 	br	180694 <scanBarcode+0x188>
  180688:	0023883a 	mov	r17,zero
  18068c:	00000106 	br	180694 <scanBarcode+0x188>
			}
			firstBit = 1;
  180690:	1823883a 	mov	r17,r3
	int countingBarWidth = 1;
	barwidth = 0;
	actualCount = 0;

	//Calculate all pixels based on VGA pixel's
	for(int x =0; x < 255; x++){
  180694:	84000044 	addi	r16,r16,1
  180698:	00803fc4 	movi	r2,255
  18069c:	80bfac1e 	bne	r16,r2,180550 <scanBarcode+0x44>
			}
			firstBit = 1;
		}
	}
	for(int x = 0; x < 255; x+=barwidth){
		printf("%c",charcode[x]);
  1806a0:	04c00634 	movhi	r19,24
  1806a4:	0021883a 	mov	r16,zero
  1806a8:	9cd05d04 	addi	r19,r19,16756
				barwidth++;
			}
			firstBit = 1;
		}
	}
	for(int x = 0; x < 255; x+=barwidth){
  1806ac:	04803f84 	movi	r18,254
		printf("%c",charcode[x]);
  1806b0:	9c23883a 	add	r17,r19,r16
  1806b4:	89000007 	ldb	r4,0(r17)
  1806b8:	0181df40 	call	181df4 <putchar>
		tx_char(charcode[x],x);
  1806bc:	89000007 	ldb	r4,0(r17)
  1806c0:	800b883a 	mov	r5,r16
  1806c4:	01809940 	call	180994 <tx_char>
				barwidth++;
			}
			firstBit = 1;
		}
	}
	for(int x = 0; x < 255; x+=barwidth){
  1806c8:	d0a23717 	ldw	r2,-30500(gp)
  1806cc:	80a1883a 	add	r16,r16,r2
  1806d0:	943ff70e 	bge	r18,r16,1806b0 <scanBarcode+0x1a4>
		printf("%c",charcode[x]);
		tx_char(charcode[x],x);
	}
	transmit();
}
  1806d4:	dfc00817 	ldw	ra,32(sp)
  1806d8:	ddc00717 	ldw	r23,28(sp)
  1806dc:	dd800617 	ldw	r22,24(sp)
  1806e0:	dd400517 	ldw	r21,20(sp)
  1806e4:	dd000417 	ldw	r20,16(sp)
  1806e8:	dcc00317 	ldw	r19,12(sp)
  1806ec:	dc800217 	ldw	r18,8(sp)
  1806f0:	dc400117 	ldw	r17,4(sp)
  1806f4:	dc000017 	ldw	r16,0(sp)
  1806f8:	dec00904 	addi	sp,sp,36
	}
	for(int x = 0; x < 255; x+=barwidth){
		printf("%c",charcode[x]);
		tx_char(charcode[x],x);
	}
	transmit();
  1806fc:	01809a81 	jmpi	1809a8 <transmit>

00180700 <callback>:

	return 0;
}

//Called when network packet is received from server
void callback(unsigned char *data){
  180700:	defffe04 	addi	sp,sp,-8
  180704:	dc000015 	stw	r16,0(sp)
	alt_printf( "\nResponds: %s\n", data + 16);
  180708:	24000404 	addi	r16,r4,16
  18070c:	01000634 	movhi	r4,24
  180710:	800b883a 	mov	r5,r16
  180714:	210b7504 	addi	r4,r4,11732

	return 0;
}

//Called when network packet is received from server
void callback(unsigned char *data){
  180718:	dfc00115 	stw	ra,4(sp)
	alt_printf( "\nResponds: %s\n", data + 16);
  18071c:	01820f40 	call	1820f4 <alt_printf>
	showText(data + 16);
  180720:	8009883a 	mov	r4,r16
}
  180724:	dfc00117 	ldw	ra,4(sp)
  180728:	dc000017 	ldw	r16,0(sp)
  18072c:	dec00204 	addi	sp,sp,8
}

//Called when network packet is received from server
void callback(unsigned char *data){
	alt_printf( "\nResponds: %s\n", data + 16);
	showText(data + 16);
  180730:	01802401 	jmpi	180240 <showText>

00180734 <main>:
		printf("%c",charcode[x]);
		tx_char(charcode[x],x);
	}
	transmit();
}
int main(void){
  180734:	deffff04 	addi	sp,sp,-4
  180738:	dfc00015 	stw	ra,0(sp)
	setup();
  18073c:	01808280 	call	180828 <setup>
	//Show default text on screen
	showText("please hold barcode over line");
  180740:	01000634 	movhi	r4,24
  180744:	210b6d04 	addi	r4,r4,11700
  180748:	01802400 	call	180240 <showText>

	//Delay to Wait for network connection with PC to start
	usleep(2000000);
  18074c:	010007f4 	movhi	r4,31
  180750:	21212004 	addi	r4,r4,-31616
  180754:	01822ac0 	call	1822ac <usleep>
	//Scan barcode
	scanBarcode();
  180758:	018050c0 	call	18050c <scanBarcode>
  18075c:	003fff06 	br	18075c <main+0x28>

00180760 <rx_ethernet_isr>:
	//while (alt_avalon_sgdma_check_descriptor_status(&tx_descriptor) != 0)

}

void rx_ethernet_isr (void *context)
{
  180760:	defffa04 	addi	sp,sp,-24
  180764:	dfc00515 	stw	ra,20(sp)
  180768:	dc000415 	stw	r16,16(sp)
	int i;

		// Wait until receive descriptor transfer is complete
		while (alt_avalon_sgdma_check_descriptor_status(&rx_descriptor) != 0)
  18076c:	01000074 	movhi	r4,1
  180770:	21200804 	addi	r4,r4,-32736
  180774:	01825380 	call	182538 <alt_avalon_sgdma_check_descriptor_status>
  180778:	103ffc1e 	bne	r2,zero,18076c <rx_ethernet_isr+0xc>
		// Clear input line before writing
//		for (i = 0; i < (6 + text_length); i++) {
//			alt_printf( "%c", 0x08 );		 // 0x08 --> backspace
//		}
		//alt_printf( "got: %s\n", rx_frame + 16);
		if(rx_frame[2] == 0x69){
  18077c:	04000634 	movhi	r16,24
  180780:	84109d04 	addi	r16,r16,17012
  180784:	80c00083 	ldbu	r3,2(r16)
  180788:	00801a44 	movi	r2,105
  18078c:	1880021e 	bne	r3,r2,180798 <rx_ethernet_isr+0x38>

			callback(rx_frame);
  180790:	8009883a 	mov	r4,r16
  180794:	01807000 	call	180700 <callback>
		}

		alt_avalon_sgdma_construct_mem_to_stream_desc( &tx_descriptor, &tx_descriptor_end, (alt_u32 *)tx_frame, 62, 0, 1, 1, 0 );
  180798:	00800044 	movi	r2,1
  18079c:	01800634 	movhi	r6,24
  1807a0:	01400074 	movhi	r5,1
  1807a4:	01000074 	movhi	r4,1
  1807a8:	d8800215 	stw	r2,8(sp)
  1807ac:	d8800115 	stw	r2,4(sp)
  1807b0:	01c00f84 	movi	r7,62
  1807b4:	318ccd04 	addi	r6,r6,13108
  1807b8:	29601004 	addi	r5,r5,-32704
  1807bc:	21201804 	addi	r4,r4,-32672
  1807c0:	d8000315 	stw	zero,12(sp)
  1807c4:	d8000015 	stw	zero,0(sp)
  1807c8:	01828540 	call	182854 <alt_avalon_sgdma_construct_mem_to_stream_desc>
		// Create new receive sgdma descriptor
		alt_avalon_sgdma_construct_stream_to_mem_desc( &rx_descriptor, &rx_descriptor_end, (alt_u32 *)rx_frame, 0, 0 );
  1807cc:	01800634 	movhi	r6,24
  1807d0:	01400074 	movhi	r5,1
  1807d4:	01000074 	movhi	r4,1
  1807d8:	000f883a 	mov	r7,zero
  1807dc:	31909d04 	addi	r6,r6,17012
  1807e0:	29600004 	addi	r5,r5,-32768
  1807e4:	21200804 	addi	r4,r4,-32736
  1807e8:	d8000015 	stw	zero,0(sp)
  1807ec:	01827dc0 	call	1827dc <alt_avalon_sgdma_construct_stream_to_mem_desc>


		// Set up non-blocking transfer of sgdma receive descriptor
		alt_avalon_sgdma_do_async_transfer( sgdma_rx_dev, &rx_descriptor );
  1807f0:	d1223a17 	ldw	r4,-30488(gp)
  1807f4:	01400074 	movhi	r5,1
  1807f8:	29600804 	addi	r5,r5,-32736
  1807fc:	01823f80 	call	1823f8 <alt_avalon_sgdma_do_async_transfer>

		// Output received text
			for(int x = 0; x < 1024; x++){
  180800:	0005883a 	mov	r2,zero
  180804:	00c10004 	movi	r3,1024
						rx_frame[x] = 0;
  180808:	1409883a 	add	r4,r2,r16
  18080c:	20000005 	stb	zero,0(r4)

		// Set up non-blocking transfer of sgdma receive descriptor
		alt_avalon_sgdma_do_async_transfer( sgdma_rx_dev, &rx_descriptor );

		// Output received text
			for(int x = 0; x < 1024; x++){
  180810:	10800044 	addi	r2,r2,1
  180814:	10fffc1e 	bne	r2,r3,180808 <rx_ethernet_isr+0xa8>
						rx_frame[x] = 0;
			}
}
  180818:	dfc00517 	ldw	ra,20(sp)
  18081c:	dc000417 	ldw	r16,16(sp)
  180820:	dec00604 	addi	sp,sp,24
  180824:	f800283a 	ret

00180828 <setup>:
alt_sgdma_descriptor rx_descriptor_end  __attribute__ (( section ( ".descriptor_memory" )));

void setup(void)
{
	// Open the sgdma transmit device
	sgdma_tx_dev = alt_avalon_sgdma_open ("/dev/sgdma_tx");
  180828:	01000634 	movhi	r4,24

alt_sgdma_descriptor rx_descriptor  	__attribute__ (( section ( ".descriptor_memory" )));
alt_sgdma_descriptor rx_descriptor_end  __attribute__ (( section ( ".descriptor_memory" )));

void setup(void)
{
  18082c:	defffe04 	addi	sp,sp,-8
	// Open the sgdma transmit device
	sgdma_tx_dev = alt_avalon_sgdma_open ("/dev/sgdma_tx");
  180830:	210b7904 	addi	r4,r4,11748

alt_sgdma_descriptor rx_descriptor  	__attribute__ (( section ( ".descriptor_memory" )));
alt_sgdma_descriptor rx_descriptor_end  __attribute__ (( section ( ".descriptor_memory" )));

void setup(void)
{
  180834:	dfc00115 	stw	ra,4(sp)
	// Open the sgdma transmit device
	sgdma_tx_dev = alt_avalon_sgdma_open ("/dev/sgdma_tx");
  180838:	01825640 	call	182564 <alt_avalon_sgdma_open>
  18083c:	d0a23815 	stw	r2,-30496(gp)
	if (sgdma_tx_dev == NULL) {
  180840:	1000031e 	bne	r2,zero,180850 <setup+0x28>
		alt_printf ("Error: could not open scatter-gather dma transmit device\n");
  180844:	01000634 	movhi	r4,24
  180848:	210b7d04 	addi	r4,r4,11764
  18084c:	00000206 	br	180858 <setup+0x30>
	} else alt_printf ("Opened scatter-gather dma transmit device\n");
  180850:	01000634 	movhi	r4,24
  180854:	210b8c04 	addi	r4,r4,11824
  180858:	01820f40 	call	1820f4 <alt_printf>

	// Open the sgdma receive device
	sgdma_rx_dev = alt_avalon_sgdma_open ("/dev/sgdma_rx");
  18085c:	01000634 	movhi	r4,24
  180860:	210b9704 	addi	r4,r4,11868
  180864:	01825640 	call	182564 <alt_avalon_sgdma_open>
  180868:	d0a23a15 	stw	r2,-30488(gp)
	if (sgdma_rx_dev == NULL) {
  18086c:	1000031e 	bne	r2,zero,18087c <setup+0x54>
		alt_printf ("Error: could not open scatter-gather dma receive device\n");
  180870:	01000634 	movhi	r4,24
  180874:	210b9b04 	addi	r4,r4,11884
  180878:	00000206 	br	180884 <setup+0x5c>
	} else alt_printf ("Opened scatter-gather dma receive device\n");
  18087c:	01000634 	movhi	r4,24
  180880:	210baa04 	addi	r4,r4,11944
  180884:	01820f40 	call	1820f4 <alt_printf>

	// Set interrupts for the sgdma receive device
	alt_avalon_sgdma_register_callback( sgdma_rx_dev, (alt_avalon_sgdma_callback) rx_ethernet_isr, 0x00000014, NULL );
  180888:	d1223a17 	ldw	r4,-30488(gp)
  18088c:	01400634 	movhi	r5,24
  180890:	000f883a 	mov	r7,zero
  180894:	01800504 	movi	r6,20
  180898:	2941d804 	addi	r5,r5,1888
  18089c:	01824f40 	call	1824f4 <alt_avalon_sgdma_register_callback>

	// Create sgdma receive descriptor
	alt_avalon_sgdma_construct_stream_to_mem_desc( &rx_descriptor, &rx_descriptor_end, (alt_u32 *)rx_frame, 0, 0 );
  1808a0:	01800634 	movhi	r6,24
  1808a4:	01400074 	movhi	r5,1
  1808a8:	01000074 	movhi	r4,1
  1808ac:	000f883a 	mov	r7,zero
  1808b0:	31909d04 	addi	r6,r6,17012
  1808b4:	29600004 	addi	r5,r5,-32768
  1808b8:	21200804 	addi	r4,r4,-32736
  1808bc:	d8000015 	stw	zero,0(sp)
  1808c0:	01827dc0 	call	1827dc <alt_avalon_sgdma_construct_stream_to_mem_desc>

	// Set up non-blocking transfer of sgdma receive descriptor
	alt_avalon_sgdma_do_async_transfer( sgdma_rx_dev, &rx_descriptor );
  1808c4:	d1223a17 	ldw	r4,-30488(gp)
  1808c8:	01400074 	movhi	r5,1
  1808cc:	29600804 	addi	r5,r5,-32736
  1808d0:	01823f80 	call	1823f8 <alt_avalon_sgdma_do_async_transfer>

	// Triple-speed Ethernet MegaCore base address
	volatile int * tse = (int *) ETH_TSE_BASE;

	// Initialize the MAC address
	*(tse + 3) = 0x116E6001;
  1808d4:	00800434 	movhi	r2,16
  1808d8:	00c45bb4 	movhi	r3,4462
  1808dc:	18d80044 	addi	r3,r3,24577
  1808e0:	10880304 	addi	r2,r2,8204
  1808e4:	10c00015 	stw	r3,0(r2)
	*(tse + 4) = 0x00000F02;
  1808e8:	00800434 	movhi	r2,16
  1808ec:	00c3c084 	movi	r3,3842
  1808f0:	10880404 	addi	r2,r2,8208
  1808f4:	10c00015 	stw	r3,0(r2)

	// Specify the addresses of the PHY devices to be accessed through MDIO interface
	*(tse + 0x0F) = 0x10;
  1808f8:	00800434 	movhi	r2,16
  1808fc:	00c00404 	movi	r3,16
  180900:	10880f04 	addi	r2,r2,8252
  180904:	10c00015 	stw	r3,0(r2)
	*(tse + 0x10) = 0x11;
  180908:	00800434 	movhi	r2,16
  18090c:	00c00444 	movi	r3,17
  180910:	10881004 	addi	r2,r2,8256
  180914:	10c00015 	stw	r3,0(r2)

	// Write to register 20 of the PHY chip for Ethernet port 0 to set up line loopback
	*(tse + 0x94) = 0x4000;
  180918:	00800434 	movhi	r2,16
  18091c:	00d00004 	movi	r3,16384
  180920:	10889404 	addi	r2,r2,8784
  180924:	10c00015 	stw	r3,0(r2)

	// Write to register 16 of the PHY chip for Ethernet port 1 to enable automatic crossover for all modes
	*(tse + 0xB0) = *(tse + 0xB0) | 0x0060;
  180928:	00c00434 	movhi	r3,16
  18092c:	18c8b004 	addi	r3,r3,8896
  180930:	18800017 	ldw	r2,0(r3)
  180934:	10801814 	ori	r2,r2,96
  180938:	18800015 	stw	r2,0(r3)

	// Write to register 20 of the PHY chip for Ethernet port 2 to set up delay for input/output clk
	*(tse + 0xB4) = *(tse + 0xB4) | 0x0082;
  18093c:	00c00434 	movhi	r3,16
  180940:	18c8b404 	addi	r3,r3,8912
  180944:	18800017 	ldw	r2,0(r3)
  180948:	10802094 	ori	r2,r2,130
  18094c:	18800015 	stw	r2,0(r3)

	// Software reset the second PHY chip and wait
	*(tse + 0xA0) = *(tse + 0xA0) | 0x8000;
  180950:	00800434 	movhi	r2,16
  180954:	1088a004 	addi	r2,r2,8832
  180958:	10c00017 	ldw	r3,0(r2)
  18095c:	18e00014 	ori	r3,r3,32768
  180960:	10c00015 	stw	r3,0(r2)

	while ( *(tse + 0xA0) & 0x8000 );
  180964:	10c00017 	ldw	r3,0(r2)
  180968:	18e0000c 	andi	r3,r3,32768
  18096c:	183ffd1e 	bne	r3,zero,180964 <setup+0x13c>

	// Enable read and write transfers, 100 mbit Ethernet operation, and CRC forwarding
	//*(tse + 2) = *(tse + 2) | 0x00000043;

	// Enable read and write transfers, gigabit Ethernet operation, and CRC forwarding
	*(tse + 2) = *(tse + 2) | 0x0000004B;
  180970:	00c00434 	movhi	r3,16
  180974:	18c80204 	addi	r3,r3,8200
  180978:	18800017 	ldw	r2,0(r3)
  18097c:	108012d4 	ori	r2,r2,75
  180980:	18800015 	stw	r2,0(r3)
}
  180984:	dfc00117 	ldw	ra,4(sp)
  180988:	dec00204 	addi	sp,sp,8
  18098c:	f800283a 	ret

00180990 <refresh_ethernet>:

void refresh_ethernet(){
  180990:	f800283a 	ret

00180994 <tx_char>:
						rx_frame[x] = 0;
			}
}

void tx_char(char *c, int x){
	tx_frame[16 + x] = c;
  180994:	00800634 	movhi	r2,24
  180998:	108cd104 	addi	r2,r2,13124
  18099c:	288b883a 	add	r5,r5,r2
  1809a0:	29000005 	stb	r4,0(r5)
  1809a4:	f800283a 	ret

001809a8 <transmit>:
}

void transmit(){
  1809a8:	defffb04 	addi	sp,sp,-20
	// Create transmit sgdma descriptor
				alt_avalon_sgdma_construct_mem_to_stream_desc( &tx_descriptor, &tx_descriptor_end, (alt_u32 *)tx_frame, 62, 0, 1, 1, 0 );
  1809ac:	00800044 	movi	r2,1
  1809b0:	01800634 	movhi	r6,24
  1809b4:	01400074 	movhi	r5,1
  1809b8:	01000074 	movhi	r4,1
  1809bc:	29601004 	addi	r5,r5,-32704
  1809c0:	21201804 	addi	r4,r4,-32672
  1809c4:	d8000315 	stw	zero,12(sp)
  1809c8:	d8800215 	stw	r2,8(sp)
  1809cc:	d8800115 	stw	r2,4(sp)
  1809d0:	d8000015 	stw	zero,0(sp)
  1809d4:	01c00f84 	movi	r7,62
  1809d8:	318ccd04 	addi	r6,r6,13108

void tx_char(char *c, int x){
	tx_frame[16 + x] = c;
}

void transmit(){
  1809dc:	dfc00415 	stw	ra,16(sp)
	// Create transmit sgdma descriptor
				alt_avalon_sgdma_construct_mem_to_stream_desc( &tx_descriptor, &tx_descriptor_end, (alt_u32 *)tx_frame, 62, 0, 1, 1, 0 );
  1809e0:	01828540 	call	182854 <alt_avalon_sgdma_construct_mem_to_stream_desc>
				// Set up non-blocking transfer of sgdma transmit descriptor
				alt_avalon_sgdma_do_async_transfer( sgdma_tx_dev, &tx_descriptor );
  1809e4:	d1223817 	ldw	r4,-30496(gp)
  1809e8:	01400074 	movhi	r5,1
  1809ec:	29601804 	addi	r5,r5,-32672
  1809f0:	01823f80 	call	1823f8 <alt_avalon_sgdma_do_async_transfer>
				// Wait until transmit descriptor transfer is complete
				while (alt_avalon_sgdma_check_descriptor_status(&tx_descriptor) != 0);
  1809f4:	01000074 	movhi	r4,1
  1809f8:	21201804 	addi	r4,r4,-32672
  1809fc:	01825380 	call	182538 <alt_avalon_sgdma_check_descriptor_status>
  180a00:	103ffc1e 	bne	r2,zero,1809f4 <transmit+0x4c>
}
  180a04:	dfc00417 	ldw	ra,16(sp)
  180a08:	dec00504 	addi	sp,sp,20
  180a0c:	f800283a 	ret

00180a10 <tx_ethernet_isr>:

void tx_ethernet_isr(char *chars){
  180a10:	defff804 	addi	sp,sp,-32
  180a14:	dc800615 	stw	r18,24(sp)
  180a18:	04800634 	movhi	r18,24
  180a1c:	dc400515 	stw	r17,20(sp)
  180a20:	dc000415 	stw	r16,16(sp)
  180a24:	dfc00715 	stw	ra,28(sp)
  180a28:	2023883a 	mov	r17,r4
  180a2c:	948cd104 	addi	r18,r18,13124
			for(int x = 0; x < strlen(chars); x++){
  180a30:	2021883a 	mov	r16,r4
  180a34:	8809883a 	mov	r4,r17
  180a38:	0181e100 	call	181e10 <strlen>
  180a3c:	8447c83a 	sub	r3,r16,r17
  180a40:	1880052e 	bgeu	r3,r2,180a58 <tx_ethernet_isr+0x48>
				tx_frame[16 + x] = chars[x];
  180a44:	80800003 	ldbu	r2,0(r16)
  180a48:	94800044 	addi	r18,r18,1
  180a4c:	84000044 	addi	r16,r16,1
  180a50:	90bfffc5 	stb	r2,-1(r18)
  180a54:	003ff706 	br	180a34 <tx_ethernet_isr+0x24>
			}
			// Create transmit sgdma descriptor
			alt_avalon_sgdma_construct_mem_to_stream_desc( &tx_descriptor, &tx_descriptor_end, (alt_u32 *)tx_frame, 62, 0, 1, 1, 0 );
  180a58:	00800044 	movi	r2,1
  180a5c:	01800634 	movhi	r6,24
  180a60:	01400074 	movhi	r5,1
  180a64:	01000074 	movhi	r4,1
  180a68:	29601004 	addi	r5,r5,-32704
  180a6c:	21201804 	addi	r4,r4,-32672
  180a70:	d8000315 	stw	zero,12(sp)
  180a74:	d8800215 	stw	r2,8(sp)
  180a78:	d8800115 	stw	r2,4(sp)
  180a7c:	d8000015 	stw	zero,0(sp)
  180a80:	01c00f84 	movi	r7,62
  180a84:	318ccd04 	addi	r6,r6,13108
  180a88:	01828540 	call	182854 <alt_avalon_sgdma_construct_mem_to_stream_desc>
			// Set up non-blocking transfer of sgdma transmit descriptor
			alt_avalon_sgdma_do_async_transfer( sgdma_tx_dev, &tx_descriptor );
  180a8c:	d1223817 	ldw	r4,-30496(gp)
  180a90:	01400074 	movhi	r5,1
  180a94:	29601804 	addi	r5,r5,-32672
  180a98:	01823f80 	call	1823f8 <alt_avalon_sgdma_do_async_transfer>
			// Wait until transmit descriptor transfer is complete
			while (alt_avalon_sgdma_check_descriptor_status(&tx_descriptor) != 0);
  180a9c:	01000074 	movhi	r4,1
  180aa0:	21201804 	addi	r4,r4,-32672
  180aa4:	01825380 	call	182538 <alt_avalon_sgdma_check_descriptor_status>
  180aa8:	103ffc1e 	bne	r2,zero,180a9c <tx_ethernet_isr+0x8c>

}
  180aac:	dfc00717 	ldw	ra,28(sp)
  180ab0:	dc800617 	ldw	r18,24(sp)
  180ab4:	dc400517 	ldw	r17,20(sp)
  180ab8:	dc000417 	ldw	r16,16(sp)
  180abc:	dec00804 	addi	sp,sp,32
  180ac0:	f800283a 	ret

00180ac4 <__adddf3>:
  180ac4:	02c00434 	movhi	r11,16
  180ac8:	5affffc4 	addi	r11,r11,-1
  180acc:	2806d7fa 	srli	r3,r5,31
  180ad0:	2ad4703a 	and	r10,r5,r11
  180ad4:	3ad2703a 	and	r9,r7,r11
  180ad8:	3804d53a 	srli	r2,r7,20
  180adc:	3018d77a 	srli	r12,r6,29
  180ae0:	280ad53a 	srli	r5,r5,20
  180ae4:	501490fa 	slli	r10,r10,3
  180ae8:	2010d77a 	srli	r8,r4,29
  180aec:	481290fa 	slli	r9,r9,3
  180af0:	380ed7fa 	srli	r7,r7,31
  180af4:	defffb04 	addi	sp,sp,-20
  180af8:	dc800215 	stw	r18,8(sp)
  180afc:	dc400115 	stw	r17,4(sp)
  180b00:	dc000015 	stw	r16,0(sp)
  180b04:	dfc00415 	stw	ra,16(sp)
  180b08:	dcc00315 	stw	r19,12(sp)
  180b0c:	1c803fcc 	andi	r18,r3,255
  180b10:	2c01ffcc 	andi	r16,r5,2047
  180b14:	5210b03a 	or	r8,r10,r8
  180b18:	202290fa 	slli	r17,r4,3
  180b1c:	1081ffcc 	andi	r2,r2,2047
  180b20:	4b12b03a 	or	r9,r9,r12
  180b24:	300c90fa 	slli	r6,r6,3
  180b28:	91c07526 	beq	r18,r7,180d00 <__adddf3+0x23c>
  180b2c:	8087c83a 	sub	r3,r16,r2
  180b30:	00c0ab0e 	bge	zero,r3,180de0 <__adddf3+0x31c>
  180b34:	10002a1e 	bne	r2,zero,180be0 <__adddf3+0x11c>
  180b38:	4984b03a 	or	r2,r9,r6
  180b3c:	1000961e 	bne	r2,zero,180d98 <__adddf3+0x2d4>
  180b40:	888001cc 	andi	r2,r17,7
  180b44:	10000726 	beq	r2,zero,180b64 <__adddf3+0xa0>
  180b48:	888003cc 	andi	r2,r17,15
  180b4c:	00c00104 	movi	r3,4
  180b50:	10c00426 	beq	r2,r3,180b64 <__adddf3+0xa0>
  180b54:	88c7883a 	add	r3,r17,r3
  180b58:	1c63803a 	cmpltu	r17,r3,r17
  180b5c:	4451883a 	add	r8,r8,r17
  180b60:	1823883a 	mov	r17,r3
  180b64:	4080202c 	andhi	r2,r8,128
  180b68:	10005926 	beq	r2,zero,180cd0 <__adddf3+0x20c>
  180b6c:	84000044 	addi	r16,r16,1
  180b70:	0081ffc4 	movi	r2,2047
  180b74:	8080ba26 	beq	r16,r2,180e60 <__adddf3+0x39c>
  180b78:	00bfe034 	movhi	r2,65408
  180b7c:	10bfffc4 	addi	r2,r2,-1
  180b80:	4090703a 	and	r8,r8,r2
  180b84:	4004977a 	slli	r2,r8,29
  180b88:	4010927a 	slli	r8,r8,9
  180b8c:	8822d0fa 	srli	r17,r17,3
  180b90:	8401ffcc 	andi	r16,r16,2047
  180b94:	4010d33a 	srli	r8,r8,12
  180b98:	9007883a 	mov	r3,r18
  180b9c:	1444b03a 	or	r2,r2,r17
  180ba0:	8401ffcc 	andi	r16,r16,2047
  180ba4:	8020953a 	slli	r16,r16,20
  180ba8:	18c03fcc 	andi	r3,r3,255
  180bac:	01000434 	movhi	r4,16
  180bb0:	213fffc4 	addi	r4,r4,-1
  180bb4:	180697fa 	slli	r3,r3,31
  180bb8:	4110703a 	and	r8,r8,r4
  180bbc:	4410b03a 	or	r8,r8,r16
  180bc0:	40c6b03a 	or	r3,r8,r3
  180bc4:	dfc00417 	ldw	ra,16(sp)
  180bc8:	dcc00317 	ldw	r19,12(sp)
  180bcc:	dc800217 	ldw	r18,8(sp)
  180bd0:	dc400117 	ldw	r17,4(sp)
  180bd4:	dc000017 	ldw	r16,0(sp)
  180bd8:	dec00504 	addi	sp,sp,20
  180bdc:	f800283a 	ret
  180be0:	0081ffc4 	movi	r2,2047
  180be4:	80bfd626 	beq	r16,r2,180b40 <__adddf3+0x7c>
  180be8:	4a402034 	orhi	r9,r9,128
  180bec:	00800e04 	movi	r2,56
  180bf0:	10c09f16 	blt	r2,r3,180e70 <__adddf3+0x3ac>
  180bf4:	008007c4 	movi	r2,31
  180bf8:	10c0c216 	blt	r2,r3,180f04 <__adddf3+0x440>
  180bfc:	00800804 	movi	r2,32
  180c00:	10c5c83a 	sub	r2,r2,r3
  180c04:	488a983a 	sll	r5,r9,r2
  180c08:	30c8d83a 	srl	r4,r6,r3
  180c0c:	3084983a 	sll	r2,r6,r2
  180c10:	48c6d83a 	srl	r3,r9,r3
  180c14:	290cb03a 	or	r6,r5,r4
  180c18:	1004c03a 	cmpne	r2,r2,zero
  180c1c:	308cb03a 	or	r6,r6,r2
  180c20:	898dc83a 	sub	r6,r17,r6
  180c24:	89a3803a 	cmpltu	r17,r17,r6
  180c28:	40d1c83a 	sub	r8,r8,r3
  180c2c:	4451c83a 	sub	r8,r8,r17
  180c30:	3023883a 	mov	r17,r6
  180c34:	4080202c 	andhi	r2,r8,128
  180c38:	10002326 	beq	r2,zero,180cc8 <__adddf3+0x204>
  180c3c:	04c02034 	movhi	r19,128
  180c40:	9cffffc4 	addi	r19,r19,-1
  180c44:	44e6703a 	and	r19,r8,r19
  180c48:	98007626 	beq	r19,zero,180e24 <__adddf3+0x360>
  180c4c:	9809883a 	mov	r4,r19
  180c50:	0181d380 	call	181d38 <__clzsi2>
  180c54:	10fffe04 	addi	r3,r2,-8
  180c58:	010007c4 	movi	r4,31
  180c5c:	20c07716 	blt	r4,r3,180e3c <__adddf3+0x378>
  180c60:	00800804 	movi	r2,32
  180c64:	10c5c83a 	sub	r2,r2,r3
  180c68:	8884d83a 	srl	r2,r17,r2
  180c6c:	98d0983a 	sll	r8,r19,r3
  180c70:	88e2983a 	sll	r17,r17,r3
  180c74:	1204b03a 	or	r2,r2,r8
  180c78:	1c007416 	blt	r3,r16,180e4c <__adddf3+0x388>
  180c7c:	1c21c83a 	sub	r16,r3,r16
  180c80:	82000044 	addi	r8,r16,1
  180c84:	00c007c4 	movi	r3,31
  180c88:	1a009116 	blt	r3,r8,180ed0 <__adddf3+0x40c>
  180c8c:	00c00804 	movi	r3,32
  180c90:	1a07c83a 	sub	r3,r3,r8
  180c94:	8a08d83a 	srl	r4,r17,r8
  180c98:	88e2983a 	sll	r17,r17,r3
  180c9c:	10c6983a 	sll	r3,r2,r3
  180ca0:	1210d83a 	srl	r8,r2,r8
  180ca4:	8804c03a 	cmpne	r2,r17,zero
  180ca8:	1906b03a 	or	r3,r3,r4
  180cac:	18a2b03a 	or	r17,r3,r2
  180cb0:	0021883a 	mov	r16,zero
  180cb4:	003fa206 	br	180b40 <__adddf3+0x7c>
  180cb8:	1890b03a 	or	r8,r3,r2
  180cbc:	40017d26 	beq	r8,zero,1812b4 <__adddf3+0x7f0>
  180cc0:	1011883a 	mov	r8,r2
  180cc4:	1823883a 	mov	r17,r3
  180cc8:	888001cc 	andi	r2,r17,7
  180ccc:	103f9e1e 	bne	r2,zero,180b48 <__adddf3+0x84>
  180cd0:	4004977a 	slli	r2,r8,29
  180cd4:	8822d0fa 	srli	r17,r17,3
  180cd8:	4010d0fa 	srli	r8,r8,3
  180cdc:	9007883a 	mov	r3,r18
  180ce0:	1444b03a 	or	r2,r2,r17
  180ce4:	0101ffc4 	movi	r4,2047
  180ce8:	81002426 	beq	r16,r4,180d7c <__adddf3+0x2b8>
  180cec:	8120703a 	and	r16,r16,r4
  180cf0:	01000434 	movhi	r4,16
  180cf4:	213fffc4 	addi	r4,r4,-1
  180cf8:	4110703a 	and	r8,r8,r4
  180cfc:	003fa806 	br	180ba0 <__adddf3+0xdc>
  180d00:	8089c83a 	sub	r4,r16,r2
  180d04:	01005e0e 	bge	zero,r4,180e80 <__adddf3+0x3bc>
  180d08:	10002b26 	beq	r2,zero,180db8 <__adddf3+0x2f4>
  180d0c:	0081ffc4 	movi	r2,2047
  180d10:	80bf8b26 	beq	r16,r2,180b40 <__adddf3+0x7c>
  180d14:	4a402034 	orhi	r9,r9,128
  180d18:	00800e04 	movi	r2,56
  180d1c:	1100a40e 	bge	r2,r4,180fb0 <__adddf3+0x4ec>
  180d20:	498cb03a 	or	r6,r9,r6
  180d24:	300ac03a 	cmpne	r5,r6,zero
  180d28:	0013883a 	mov	r9,zero
  180d2c:	2c4b883a 	add	r5,r5,r17
  180d30:	2c63803a 	cmpltu	r17,r5,r17
  180d34:	4a11883a 	add	r8,r9,r8
  180d38:	8a11883a 	add	r8,r17,r8
  180d3c:	2823883a 	mov	r17,r5
  180d40:	4080202c 	andhi	r2,r8,128
  180d44:	103fe026 	beq	r2,zero,180cc8 <__adddf3+0x204>
  180d48:	84000044 	addi	r16,r16,1
  180d4c:	0081ffc4 	movi	r2,2047
  180d50:	8080d226 	beq	r16,r2,18109c <__adddf3+0x5d8>
  180d54:	00bfe034 	movhi	r2,65408
  180d58:	10bfffc4 	addi	r2,r2,-1
  180d5c:	4090703a 	and	r8,r8,r2
  180d60:	880ad07a 	srli	r5,r17,1
  180d64:	400897fa 	slli	r4,r8,31
  180d68:	88c0004c 	andi	r3,r17,1
  180d6c:	28e2b03a 	or	r17,r5,r3
  180d70:	4010d07a 	srli	r8,r8,1
  180d74:	2462b03a 	or	r17,r4,r17
  180d78:	003f7106 	br	180b40 <__adddf3+0x7c>
  180d7c:	4088b03a 	or	r4,r8,r2
  180d80:	20014526 	beq	r4,zero,181298 <__adddf3+0x7d4>
  180d84:	01000434 	movhi	r4,16
  180d88:	42000234 	orhi	r8,r8,8
  180d8c:	213fffc4 	addi	r4,r4,-1
  180d90:	4110703a 	and	r8,r8,r4
  180d94:	003f8206 	br	180ba0 <__adddf3+0xdc>
  180d98:	18ffffc4 	addi	r3,r3,-1
  180d9c:	1800491e 	bne	r3,zero,180ec4 <__adddf3+0x400>
  180da0:	898bc83a 	sub	r5,r17,r6
  180da4:	8963803a 	cmpltu	r17,r17,r5
  180da8:	4251c83a 	sub	r8,r8,r9
  180dac:	4451c83a 	sub	r8,r8,r17
  180db0:	2823883a 	mov	r17,r5
  180db4:	003f9f06 	br	180c34 <__adddf3+0x170>
  180db8:	4984b03a 	or	r2,r9,r6
  180dbc:	103f6026 	beq	r2,zero,180b40 <__adddf3+0x7c>
  180dc0:	213fffc4 	addi	r4,r4,-1
  180dc4:	2000931e 	bne	r4,zero,181014 <__adddf3+0x550>
  180dc8:	898d883a 	add	r6,r17,r6
  180dcc:	3463803a 	cmpltu	r17,r6,r17
  180dd0:	4251883a 	add	r8,r8,r9
  180dd4:	8a11883a 	add	r8,r17,r8
  180dd8:	3023883a 	mov	r17,r6
  180ddc:	003fd806 	br	180d40 <__adddf3+0x27c>
  180de0:	1800541e 	bne	r3,zero,180f34 <__adddf3+0x470>
  180de4:	80800044 	addi	r2,r16,1
  180de8:	1081ffcc 	andi	r2,r2,2047
  180dec:	00c00044 	movi	r3,1
  180df0:	1880a00e 	bge	r3,r2,181074 <__adddf3+0x5b0>
  180df4:	8989c83a 	sub	r4,r17,r6
  180df8:	8905803a 	cmpltu	r2,r17,r4
  180dfc:	4267c83a 	sub	r19,r8,r9
  180e00:	98a7c83a 	sub	r19,r19,r2
  180e04:	9880202c 	andhi	r2,r19,128
  180e08:	10006326 	beq	r2,zero,180f98 <__adddf3+0x4d4>
  180e0c:	3463c83a 	sub	r17,r6,r17
  180e10:	4a07c83a 	sub	r3,r9,r8
  180e14:	344d803a 	cmpltu	r6,r6,r17
  180e18:	19a7c83a 	sub	r19,r3,r6
  180e1c:	3825883a 	mov	r18,r7
  180e20:	983f8a1e 	bne	r19,zero,180c4c <__adddf3+0x188>
  180e24:	8809883a 	mov	r4,r17
  180e28:	0181d380 	call	181d38 <__clzsi2>
  180e2c:	10800804 	addi	r2,r2,32
  180e30:	10fffe04 	addi	r3,r2,-8
  180e34:	010007c4 	movi	r4,31
  180e38:	20ff890e 	bge	r4,r3,180c60 <__adddf3+0x19c>
  180e3c:	10bff604 	addi	r2,r2,-40
  180e40:	8884983a 	sll	r2,r17,r2
  180e44:	0023883a 	mov	r17,zero
  180e48:	1c3f8c0e 	bge	r3,r16,180c7c <__adddf3+0x1b8>
  180e4c:	023fe034 	movhi	r8,65408
  180e50:	423fffc4 	addi	r8,r8,-1
  180e54:	80e1c83a 	sub	r16,r16,r3
  180e58:	1210703a 	and	r8,r2,r8
  180e5c:	003f3806 	br	180b40 <__adddf3+0x7c>
  180e60:	9007883a 	mov	r3,r18
  180e64:	0011883a 	mov	r8,zero
  180e68:	0005883a 	mov	r2,zero
  180e6c:	003f4c06 	br	180ba0 <__adddf3+0xdc>
  180e70:	498cb03a 	or	r6,r9,r6
  180e74:	300cc03a 	cmpne	r6,r6,zero
  180e78:	0007883a 	mov	r3,zero
  180e7c:	003f6806 	br	180c20 <__adddf3+0x15c>
  180e80:	20009c1e 	bne	r4,zero,1810f4 <__adddf3+0x630>
  180e84:	80800044 	addi	r2,r16,1
  180e88:	1141ffcc 	andi	r5,r2,2047
  180e8c:	01000044 	movi	r4,1
  180e90:	2140670e 	bge	r4,r5,181030 <__adddf3+0x56c>
  180e94:	0101ffc4 	movi	r4,2047
  180e98:	11007f26 	beq	r2,r4,181098 <__adddf3+0x5d4>
  180e9c:	898d883a 	add	r6,r17,r6
  180ea0:	4247883a 	add	r3,r8,r9
  180ea4:	3451803a 	cmpltu	r8,r6,r17
  180ea8:	40d1883a 	add	r8,r8,r3
  180eac:	402297fa 	slli	r17,r8,31
  180eb0:	300cd07a 	srli	r6,r6,1
  180eb4:	4010d07a 	srli	r8,r8,1
  180eb8:	1021883a 	mov	r16,r2
  180ebc:	89a2b03a 	or	r17,r17,r6
  180ec0:	003f1f06 	br	180b40 <__adddf3+0x7c>
  180ec4:	0081ffc4 	movi	r2,2047
  180ec8:	80bf481e 	bne	r16,r2,180bec <__adddf3+0x128>
  180ecc:	003f1c06 	br	180b40 <__adddf3+0x7c>
  180ed0:	843ff844 	addi	r16,r16,-31
  180ed4:	01000804 	movi	r4,32
  180ed8:	1406d83a 	srl	r3,r2,r16
  180edc:	41005026 	beq	r8,r4,181020 <__adddf3+0x55c>
  180ee0:	01001004 	movi	r4,64
  180ee4:	2211c83a 	sub	r8,r4,r8
  180ee8:	1204983a 	sll	r2,r2,r8
  180eec:	88a2b03a 	or	r17,r17,r2
  180ef0:	8822c03a 	cmpne	r17,r17,zero
  180ef4:	1c62b03a 	or	r17,r3,r17
  180ef8:	0011883a 	mov	r8,zero
  180efc:	0021883a 	mov	r16,zero
  180f00:	003f7106 	br	180cc8 <__adddf3+0x204>
  180f04:	193ff804 	addi	r4,r3,-32
  180f08:	00800804 	movi	r2,32
  180f0c:	4908d83a 	srl	r4,r9,r4
  180f10:	18804526 	beq	r3,r2,181028 <__adddf3+0x564>
  180f14:	00801004 	movi	r2,64
  180f18:	10c5c83a 	sub	r2,r2,r3
  180f1c:	4886983a 	sll	r3,r9,r2
  180f20:	198cb03a 	or	r6,r3,r6
  180f24:	300cc03a 	cmpne	r6,r6,zero
  180f28:	218cb03a 	or	r6,r4,r6
  180f2c:	0007883a 	mov	r3,zero
  180f30:	003f3b06 	br	180c20 <__adddf3+0x15c>
  180f34:	80002a26 	beq	r16,zero,180fe0 <__adddf3+0x51c>
  180f38:	0101ffc4 	movi	r4,2047
  180f3c:	11006826 	beq	r2,r4,1810e0 <__adddf3+0x61c>
  180f40:	00c7c83a 	sub	r3,zero,r3
  180f44:	42002034 	orhi	r8,r8,128
  180f48:	01000e04 	movi	r4,56
  180f4c:	20c07c16 	blt	r4,r3,181140 <__adddf3+0x67c>
  180f50:	010007c4 	movi	r4,31
  180f54:	20c0da16 	blt	r4,r3,1812c0 <__adddf3+0x7fc>
  180f58:	01000804 	movi	r4,32
  180f5c:	20c9c83a 	sub	r4,r4,r3
  180f60:	4114983a 	sll	r10,r8,r4
  180f64:	88cad83a 	srl	r5,r17,r3
  180f68:	8908983a 	sll	r4,r17,r4
  180f6c:	40c6d83a 	srl	r3,r8,r3
  180f70:	5162b03a 	or	r17,r10,r5
  180f74:	2008c03a 	cmpne	r4,r4,zero
  180f78:	8922b03a 	or	r17,r17,r4
  180f7c:	3463c83a 	sub	r17,r6,r17
  180f80:	48c7c83a 	sub	r3,r9,r3
  180f84:	344d803a 	cmpltu	r6,r6,r17
  180f88:	1991c83a 	sub	r8,r3,r6
  180f8c:	1021883a 	mov	r16,r2
  180f90:	3825883a 	mov	r18,r7
  180f94:	003f2706 	br	180c34 <__adddf3+0x170>
  180f98:	24d0b03a 	or	r8,r4,r19
  180f9c:	40001b1e 	bne	r8,zero,18100c <__adddf3+0x548>
  180fa0:	0005883a 	mov	r2,zero
  180fa4:	0007883a 	mov	r3,zero
  180fa8:	0021883a 	mov	r16,zero
  180fac:	003f4d06 	br	180ce4 <__adddf3+0x220>
  180fb0:	008007c4 	movi	r2,31
  180fb4:	11003c16 	blt	r2,r4,1810a8 <__adddf3+0x5e4>
  180fb8:	00800804 	movi	r2,32
  180fbc:	1105c83a 	sub	r2,r2,r4
  180fc0:	488e983a 	sll	r7,r9,r2
  180fc4:	310ad83a 	srl	r5,r6,r4
  180fc8:	3084983a 	sll	r2,r6,r2
  180fcc:	4912d83a 	srl	r9,r9,r4
  180fd0:	394ab03a 	or	r5,r7,r5
  180fd4:	1004c03a 	cmpne	r2,r2,zero
  180fd8:	288ab03a 	or	r5,r5,r2
  180fdc:	003f5306 	br	180d2c <__adddf3+0x268>
  180fe0:	4448b03a 	or	r4,r8,r17
  180fe4:	20003e26 	beq	r4,zero,1810e0 <__adddf3+0x61c>
  180fe8:	00c6303a 	nor	r3,zero,r3
  180fec:	18003a1e 	bne	r3,zero,1810d8 <__adddf3+0x614>
  180ff0:	3463c83a 	sub	r17,r6,r17
  180ff4:	4a07c83a 	sub	r3,r9,r8
  180ff8:	344d803a 	cmpltu	r6,r6,r17
  180ffc:	1991c83a 	sub	r8,r3,r6
  181000:	1021883a 	mov	r16,r2
  181004:	3825883a 	mov	r18,r7
  181008:	003f0a06 	br	180c34 <__adddf3+0x170>
  18100c:	2023883a 	mov	r17,r4
  181010:	003f0d06 	br	180c48 <__adddf3+0x184>
  181014:	0081ffc4 	movi	r2,2047
  181018:	80bf3f1e 	bne	r16,r2,180d18 <__adddf3+0x254>
  18101c:	003ec806 	br	180b40 <__adddf3+0x7c>
  181020:	0005883a 	mov	r2,zero
  181024:	003fb106 	br	180eec <__adddf3+0x428>
  181028:	0007883a 	mov	r3,zero
  18102c:	003fbc06 	br	180f20 <__adddf3+0x45c>
  181030:	4444b03a 	or	r2,r8,r17
  181034:	8000871e 	bne	r16,zero,181254 <__adddf3+0x790>
  181038:	1000ba26 	beq	r2,zero,181324 <__adddf3+0x860>
  18103c:	4984b03a 	or	r2,r9,r6
  181040:	103ebf26 	beq	r2,zero,180b40 <__adddf3+0x7c>
  181044:	8985883a 	add	r2,r17,r6
  181048:	4247883a 	add	r3,r8,r9
  18104c:	1451803a 	cmpltu	r8,r2,r17
  181050:	40d1883a 	add	r8,r8,r3
  181054:	40c0202c 	andhi	r3,r8,128
  181058:	1023883a 	mov	r17,r2
  18105c:	183f1a26 	beq	r3,zero,180cc8 <__adddf3+0x204>
  181060:	00bfe034 	movhi	r2,65408
  181064:	10bfffc4 	addi	r2,r2,-1
  181068:	2021883a 	mov	r16,r4
  18106c:	4090703a 	and	r8,r8,r2
  181070:	003eb306 	br	180b40 <__adddf3+0x7c>
  181074:	4444b03a 	or	r2,r8,r17
  181078:	8000291e 	bne	r16,zero,181120 <__adddf3+0x65c>
  18107c:	10004b1e 	bne	r2,zero,1811ac <__adddf3+0x6e8>
  181080:	4990b03a 	or	r8,r9,r6
  181084:	40008b26 	beq	r8,zero,1812b4 <__adddf3+0x7f0>
  181088:	4811883a 	mov	r8,r9
  18108c:	3023883a 	mov	r17,r6
  181090:	3825883a 	mov	r18,r7
  181094:	003eaa06 	br	180b40 <__adddf3+0x7c>
  181098:	1021883a 	mov	r16,r2
  18109c:	0011883a 	mov	r8,zero
  1810a0:	0005883a 	mov	r2,zero
  1810a4:	003f0f06 	br	180ce4 <__adddf3+0x220>
  1810a8:	217ff804 	addi	r5,r4,-32
  1810ac:	00800804 	movi	r2,32
  1810b0:	494ad83a 	srl	r5,r9,r5
  1810b4:	20807d26 	beq	r4,r2,1812ac <__adddf3+0x7e8>
  1810b8:	00801004 	movi	r2,64
  1810bc:	1109c83a 	sub	r4,r2,r4
  1810c0:	4912983a 	sll	r9,r9,r4
  1810c4:	498cb03a 	or	r6,r9,r6
  1810c8:	300cc03a 	cmpne	r6,r6,zero
  1810cc:	298ab03a 	or	r5,r5,r6
  1810d0:	0013883a 	mov	r9,zero
  1810d4:	003f1506 	br	180d2c <__adddf3+0x268>
  1810d8:	0101ffc4 	movi	r4,2047
  1810dc:	113f9a1e 	bne	r2,r4,180f48 <__adddf3+0x484>
  1810e0:	4811883a 	mov	r8,r9
  1810e4:	3023883a 	mov	r17,r6
  1810e8:	1021883a 	mov	r16,r2
  1810ec:	3825883a 	mov	r18,r7
  1810f0:	003e9306 	br	180b40 <__adddf3+0x7c>
  1810f4:	8000161e 	bne	r16,zero,181150 <__adddf3+0x68c>
  1810f8:	444ab03a 	or	r5,r8,r17
  1810fc:	28005126 	beq	r5,zero,181244 <__adddf3+0x780>
  181100:	0108303a 	nor	r4,zero,r4
  181104:	20004d1e 	bne	r4,zero,18123c <__adddf3+0x778>
  181108:	89a3883a 	add	r17,r17,r6
  18110c:	4253883a 	add	r9,r8,r9
  181110:	898d803a 	cmpltu	r6,r17,r6
  181114:	3251883a 	add	r8,r6,r9
  181118:	1021883a 	mov	r16,r2
  18111c:	003f0806 	br	180d40 <__adddf3+0x27c>
  181120:	1000301e 	bne	r2,zero,1811e4 <__adddf3+0x720>
  181124:	4984b03a 	or	r2,r9,r6
  181128:	10007126 	beq	r2,zero,1812f0 <__adddf3+0x82c>
  18112c:	4811883a 	mov	r8,r9
  181130:	3023883a 	mov	r17,r6
  181134:	3825883a 	mov	r18,r7
  181138:	0401ffc4 	movi	r16,2047
  18113c:	003e8006 	br	180b40 <__adddf3+0x7c>
  181140:	4462b03a 	or	r17,r8,r17
  181144:	8822c03a 	cmpne	r17,r17,zero
  181148:	0007883a 	mov	r3,zero
  18114c:	003f8b06 	br	180f7c <__adddf3+0x4b8>
  181150:	0141ffc4 	movi	r5,2047
  181154:	11403b26 	beq	r2,r5,181244 <__adddf3+0x780>
  181158:	0109c83a 	sub	r4,zero,r4
  18115c:	42002034 	orhi	r8,r8,128
  181160:	01400e04 	movi	r5,56
  181164:	29006716 	blt	r5,r4,181304 <__adddf3+0x840>
  181168:	014007c4 	movi	r5,31
  18116c:	29007016 	blt	r5,r4,181330 <__adddf3+0x86c>
  181170:	01400804 	movi	r5,32
  181174:	290bc83a 	sub	r5,r5,r4
  181178:	4154983a 	sll	r10,r8,r5
  18117c:	890ed83a 	srl	r7,r17,r4
  181180:	894a983a 	sll	r5,r17,r5
  181184:	4108d83a 	srl	r4,r8,r4
  181188:	51e2b03a 	or	r17,r10,r7
  18118c:	280ac03a 	cmpne	r5,r5,zero
  181190:	8962b03a 	or	r17,r17,r5
  181194:	89a3883a 	add	r17,r17,r6
  181198:	2253883a 	add	r9,r4,r9
  18119c:	898d803a 	cmpltu	r6,r17,r6
  1811a0:	3251883a 	add	r8,r6,r9
  1811a4:	1021883a 	mov	r16,r2
  1811a8:	003ee506 	br	180d40 <__adddf3+0x27c>
  1811ac:	4984b03a 	or	r2,r9,r6
  1811b0:	103e6326 	beq	r2,zero,180b40 <__adddf3+0x7c>
  1811b4:	8987c83a 	sub	r3,r17,r6
  1811b8:	88c9803a 	cmpltu	r4,r17,r3
  1811bc:	4245c83a 	sub	r2,r8,r9
  1811c0:	1105c83a 	sub	r2,r2,r4
  1811c4:	1100202c 	andhi	r4,r2,128
  1811c8:	203ebb26 	beq	r4,zero,180cb8 <__adddf3+0x1f4>
  1811cc:	3463c83a 	sub	r17,r6,r17
  1811d0:	4a07c83a 	sub	r3,r9,r8
  1811d4:	344d803a 	cmpltu	r6,r6,r17
  1811d8:	1991c83a 	sub	r8,r3,r6
  1811dc:	3825883a 	mov	r18,r7
  1811e0:	003e5706 	br	180b40 <__adddf3+0x7c>
  1811e4:	4984b03a 	or	r2,r9,r6
  1811e8:	10002e26 	beq	r2,zero,1812a4 <__adddf3+0x7e0>
  1811ec:	4004d0fa 	srli	r2,r8,3
  1811f0:	8822d0fa 	srli	r17,r17,3
  1811f4:	4010977a 	slli	r8,r8,29
  1811f8:	10c0022c 	andhi	r3,r2,8
  1811fc:	4462b03a 	or	r17,r8,r17
  181200:	18000826 	beq	r3,zero,181224 <__adddf3+0x760>
  181204:	4808d0fa 	srli	r4,r9,3
  181208:	20c0022c 	andhi	r3,r4,8
  18120c:	1800051e 	bne	r3,zero,181224 <__adddf3+0x760>
  181210:	300cd0fa 	srli	r6,r6,3
  181214:	4806977a 	slli	r3,r9,29
  181218:	2005883a 	mov	r2,r4
  18121c:	3825883a 	mov	r18,r7
  181220:	19a2b03a 	or	r17,r3,r6
  181224:	8810d77a 	srli	r8,r17,29
  181228:	100490fa 	slli	r2,r2,3
  18122c:	882290fa 	slli	r17,r17,3
  181230:	0401ffc4 	movi	r16,2047
  181234:	4090b03a 	or	r8,r8,r2
  181238:	003e4106 	br	180b40 <__adddf3+0x7c>
  18123c:	0141ffc4 	movi	r5,2047
  181240:	117fc71e 	bne	r2,r5,181160 <__adddf3+0x69c>
  181244:	4811883a 	mov	r8,r9
  181248:	3023883a 	mov	r17,r6
  18124c:	1021883a 	mov	r16,r2
  181250:	003e3b06 	br	180b40 <__adddf3+0x7c>
  181254:	10002f26 	beq	r2,zero,181314 <__adddf3+0x850>
  181258:	4984b03a 	or	r2,r9,r6
  18125c:	10001126 	beq	r2,zero,1812a4 <__adddf3+0x7e0>
  181260:	4004d0fa 	srli	r2,r8,3
  181264:	8822d0fa 	srli	r17,r17,3
  181268:	4010977a 	slli	r8,r8,29
  18126c:	10c0022c 	andhi	r3,r2,8
  181270:	4462b03a 	or	r17,r8,r17
  181274:	183feb26 	beq	r3,zero,181224 <__adddf3+0x760>
  181278:	4808d0fa 	srli	r4,r9,3
  18127c:	20c0022c 	andhi	r3,r4,8
  181280:	183fe81e 	bne	r3,zero,181224 <__adddf3+0x760>
  181284:	300cd0fa 	srli	r6,r6,3
  181288:	4806977a 	slli	r3,r9,29
  18128c:	2005883a 	mov	r2,r4
  181290:	19a2b03a 	or	r17,r3,r6
  181294:	003fe306 	br	181224 <__adddf3+0x760>
  181298:	0011883a 	mov	r8,zero
  18129c:	0005883a 	mov	r2,zero
  1812a0:	003e3f06 	br	180ba0 <__adddf3+0xdc>
  1812a4:	0401ffc4 	movi	r16,2047
  1812a8:	003e2506 	br	180b40 <__adddf3+0x7c>
  1812ac:	0013883a 	mov	r9,zero
  1812b0:	003f8406 	br	1810c4 <__adddf3+0x600>
  1812b4:	0005883a 	mov	r2,zero
  1812b8:	0007883a 	mov	r3,zero
  1812bc:	003e8906 	br	180ce4 <__adddf3+0x220>
  1812c0:	197ff804 	addi	r5,r3,-32
  1812c4:	01000804 	movi	r4,32
  1812c8:	414ad83a 	srl	r5,r8,r5
  1812cc:	19002426 	beq	r3,r4,181360 <__adddf3+0x89c>
  1812d0:	01001004 	movi	r4,64
  1812d4:	20c7c83a 	sub	r3,r4,r3
  1812d8:	40c6983a 	sll	r3,r8,r3
  1812dc:	1c46b03a 	or	r3,r3,r17
  1812e0:	1806c03a 	cmpne	r3,r3,zero
  1812e4:	28e2b03a 	or	r17,r5,r3
  1812e8:	0007883a 	mov	r3,zero
  1812ec:	003f2306 	br	180f7c <__adddf3+0x4b8>
  1812f0:	0007883a 	mov	r3,zero
  1812f4:	5811883a 	mov	r8,r11
  1812f8:	00bfffc4 	movi	r2,-1
  1812fc:	0401ffc4 	movi	r16,2047
  181300:	003e7806 	br	180ce4 <__adddf3+0x220>
  181304:	4462b03a 	or	r17,r8,r17
  181308:	8822c03a 	cmpne	r17,r17,zero
  18130c:	0009883a 	mov	r4,zero
  181310:	003fa006 	br	181194 <__adddf3+0x6d0>
  181314:	4811883a 	mov	r8,r9
  181318:	3023883a 	mov	r17,r6
  18131c:	0401ffc4 	movi	r16,2047
  181320:	003e0706 	br	180b40 <__adddf3+0x7c>
  181324:	4811883a 	mov	r8,r9
  181328:	3023883a 	mov	r17,r6
  18132c:	003e0406 	br	180b40 <__adddf3+0x7c>
  181330:	21fff804 	addi	r7,r4,-32
  181334:	01400804 	movi	r5,32
  181338:	41ced83a 	srl	r7,r8,r7
  18133c:	21400a26 	beq	r4,r5,181368 <__adddf3+0x8a4>
  181340:	01401004 	movi	r5,64
  181344:	2909c83a 	sub	r4,r5,r4
  181348:	4108983a 	sll	r4,r8,r4
  18134c:	2448b03a 	or	r4,r4,r17
  181350:	2008c03a 	cmpne	r4,r4,zero
  181354:	3922b03a 	or	r17,r7,r4
  181358:	0009883a 	mov	r4,zero
  18135c:	003f8d06 	br	181194 <__adddf3+0x6d0>
  181360:	0007883a 	mov	r3,zero
  181364:	003fdd06 	br	1812dc <__adddf3+0x818>
  181368:	0009883a 	mov	r4,zero
  18136c:	003ff706 	br	18134c <__adddf3+0x888>

00181370 <__muldf3>:
  181370:	deffee04 	addi	sp,sp,-72
  181374:	dd000c15 	stw	r20,48(sp)
  181378:	2828d53a 	srli	r20,r5,20
  18137c:	ddc00f15 	stw	r23,60(sp)
  181380:	282ed7fa 	srli	r23,r5,31
  181384:	dc000815 	stw	r16,32(sp)
  181388:	04000434 	movhi	r16,16
  18138c:	dcc00b15 	stw	r19,44(sp)
  181390:	843fffc4 	addi	r16,r16,-1
  181394:	dfc01115 	stw	ra,68(sp)
  181398:	df001015 	stw	fp,64(sp)
  18139c:	dd800e15 	stw	r22,56(sp)
  1813a0:	dd400d15 	stw	r21,52(sp)
  1813a4:	dc800a15 	stw	r18,40(sp)
  1813a8:	dc400915 	stw	r17,36(sp)
  1813ac:	a501ffcc 	andi	r20,r20,2047
  1813b0:	2c20703a 	and	r16,r5,r16
  1813b4:	b827883a 	mov	r19,r23
  1813b8:	ba403fcc 	andi	r9,r23,255
  1813bc:	a0006026 	beq	r20,zero,181540 <__muldf3+0x1d0>
  1813c0:	0081ffc4 	movi	r2,2047
  1813c4:	202d883a 	mov	r22,r4
  1813c8:	a0803626 	beq	r20,r2,1814a4 <__muldf3+0x134>
  1813cc:	84000434 	orhi	r16,r16,16
  1813d0:	200ad77a 	srli	r5,r4,29
  1813d4:	800490fa 	slli	r2,r16,3
  1813d8:	202c90fa 	slli	r22,r4,3
  1813dc:	a53f0044 	addi	r20,r20,-1023
  1813e0:	28a0b03a 	or	r16,r5,r2
  1813e4:	002b883a 	mov	r21,zero
  1813e8:	000b883a 	mov	r5,zero
  1813ec:	3804d53a 	srli	r2,r7,20
  1813f0:	3838d7fa 	srli	fp,r7,31
  1813f4:	04400434 	movhi	r17,16
  1813f8:	8c7fffc4 	addi	r17,r17,-1
  1813fc:	1081ffcc 	andi	r2,r2,2047
  181400:	3025883a 	mov	r18,r6
  181404:	3c62703a 	and	r17,r7,r17
  181408:	e2803fcc 	andi	r10,fp,255
  18140c:	10006d26 	beq	r2,zero,1815c4 <__muldf3+0x254>
  181410:	00c1ffc4 	movi	r3,2047
  181414:	10c06526 	beq	r2,r3,1815ac <__muldf3+0x23c>
  181418:	8c400434 	orhi	r17,r17,16
  18141c:	300ed77a 	srli	r7,r6,29
  181420:	880690fa 	slli	r3,r17,3
  181424:	302490fa 	slli	r18,r6,3
  181428:	10bf0044 	addi	r2,r2,-1023
  18142c:	38e2b03a 	or	r17,r7,r3
  181430:	000f883a 	mov	r7,zero
  181434:	a087883a 	add	r3,r20,r2
  181438:	010003c4 	movi	r4,15
  18143c:	3d44b03a 	or	r2,r7,r21
  181440:	e5ccf03a 	xor	r6,fp,r23
  181444:	1a000044 	addi	r8,r3,1
  181448:	20809b36 	bltu	r4,r2,1816b8 <__muldf3+0x348>
  18144c:	100490ba 	slli	r2,r2,2
  181450:	01000634 	movhi	r4,24
  181454:	21051904 	addi	r4,r4,5220
  181458:	1105883a 	add	r2,r2,r4
  18145c:	10800017 	ldw	r2,0(r2)
  181460:	1000683a 	jmp	r2
  181464:	001816b8 	rdprs	zero,zero,24666
  181468:	001814c4 	movi	zero,24659
  18146c:	001814c4 	movi	zero,24659
  181470:	001814c0 	call	1814c <tx_descriptor+0x100ec>
  181474:	00181694 	movui	zero,24666
  181478:	00181694 	movui	zero,24666
  18147c:	0018167c 	xorhi	zero,zero,24665
  181480:	001814c0 	call	1814c <tx_descriptor+0x100ec>
  181484:	00181694 	movui	zero,24666
  181488:	0018167c 	xorhi	zero,zero,24665
  18148c:	00181694 	movui	zero,24666
  181490:	001814c0 	call	1814c <tx_descriptor+0x100ec>
  181494:	001816a4 	muli	zero,zero,24666
  181498:	001816a4 	muli	zero,zero,24666
  18149c:	001816a4 	muli	zero,zero,24666
  1814a0:	00181a04 	movi	zero,24680
  1814a4:	2404b03a 	or	r2,r4,r16
  1814a8:	1000711e 	bne	r2,zero,181670 <__muldf3+0x300>
  1814ac:	05400204 	movi	r21,8
  1814b0:	0021883a 	mov	r16,zero
  1814b4:	002d883a 	mov	r22,zero
  1814b8:	01400084 	movi	r5,2
  1814bc:	003fcb06 	br	1813ec <__muldf3+0x7c>
  1814c0:	500d883a 	mov	r6,r10
  1814c4:	00800084 	movi	r2,2
  1814c8:	38805926 	beq	r7,r2,181630 <__muldf3+0x2c0>
  1814cc:	008000c4 	movi	r2,3
  1814d0:	3881bb26 	beq	r7,r2,181bc0 <__muldf3+0x850>
  1814d4:	00800044 	movi	r2,1
  1814d8:	3881961e 	bne	r7,r2,181b34 <__muldf3+0x7c4>
  1814dc:	3027883a 	mov	r19,r6
  1814e0:	0005883a 	mov	r2,zero
  1814e4:	0021883a 	mov	r16,zero
  1814e8:	002d883a 	mov	r22,zero
  1814ec:	1004953a 	slli	r2,r2,20
  1814f0:	98c03fcc 	andi	r3,r19,255
  1814f4:	04400434 	movhi	r17,16
  1814f8:	8c7fffc4 	addi	r17,r17,-1
  1814fc:	180697fa 	slli	r3,r3,31
  181500:	8460703a 	and	r16,r16,r17
  181504:	80a0b03a 	or	r16,r16,r2
  181508:	80c6b03a 	or	r3,r16,r3
  18150c:	b005883a 	mov	r2,r22
  181510:	dfc01117 	ldw	ra,68(sp)
  181514:	df001017 	ldw	fp,64(sp)
  181518:	ddc00f17 	ldw	r23,60(sp)
  18151c:	dd800e17 	ldw	r22,56(sp)
  181520:	dd400d17 	ldw	r21,52(sp)
  181524:	dd000c17 	ldw	r20,48(sp)
  181528:	dcc00b17 	ldw	r19,44(sp)
  18152c:	dc800a17 	ldw	r18,40(sp)
  181530:	dc400917 	ldw	r17,36(sp)
  181534:	dc000817 	ldw	r16,32(sp)
  181538:	dec01204 	addi	sp,sp,72
  18153c:	f800283a 	ret
  181540:	2404b03a 	or	r2,r4,r16
  181544:	202b883a 	mov	r21,r4
  181548:	10004426 	beq	r2,zero,18165c <__muldf3+0x2ec>
  18154c:	80015126 	beq	r16,zero,181a94 <__muldf3+0x724>
  181550:	8009883a 	mov	r4,r16
  181554:	d9800715 	stw	r6,28(sp)
  181558:	d9c00215 	stw	r7,8(sp)
  18155c:	da400415 	stw	r9,16(sp)
  181560:	0181d380 	call	181d38 <__clzsi2>
  181564:	d9800717 	ldw	r6,28(sp)
  181568:	d9c00217 	ldw	r7,8(sp)
  18156c:	da400417 	ldw	r9,16(sp)
  181570:	113ffd44 	addi	r4,r2,-11
  181574:	00c00704 	movi	r3,28
  181578:	19014216 	blt	r3,r4,181a84 <__muldf3+0x714>
  18157c:	00c00744 	movi	r3,29
  181580:	15bffe04 	addi	r22,r2,-8
  181584:	1907c83a 	sub	r3,r3,r4
  181588:	85a0983a 	sll	r16,r16,r22
  18158c:	a8c6d83a 	srl	r3,r21,r3
  181590:	adac983a 	sll	r22,r21,r22
  181594:	1c20b03a 	or	r16,r3,r16
  181598:	1080fcc4 	addi	r2,r2,1011
  18159c:	00a9c83a 	sub	r20,zero,r2
  1815a0:	002b883a 	mov	r21,zero
  1815a4:	000b883a 	mov	r5,zero
  1815a8:	003f9006 	br	1813ec <__muldf3+0x7c>
  1815ac:	3446b03a 	or	r3,r6,r17
  1815b0:	1800281e 	bne	r3,zero,181654 <__muldf3+0x2e4>
  1815b4:	0023883a 	mov	r17,zero
  1815b8:	0025883a 	mov	r18,zero
  1815bc:	01c00084 	movi	r7,2
  1815c0:	003f9c06 	br	181434 <__muldf3+0xc4>
  1815c4:	3446b03a 	or	r3,r6,r17
  1815c8:	18001e26 	beq	r3,zero,181644 <__muldf3+0x2d4>
  1815cc:	88012126 	beq	r17,zero,181a54 <__muldf3+0x6e4>
  1815d0:	8809883a 	mov	r4,r17
  1815d4:	d9400215 	stw	r5,8(sp)
  1815d8:	d9800715 	stw	r6,28(sp)
  1815dc:	da400415 	stw	r9,16(sp)
  1815e0:	da800315 	stw	r10,12(sp)
  1815e4:	0181d380 	call	181d38 <__clzsi2>
  1815e8:	d9400217 	ldw	r5,8(sp)
  1815ec:	d9800717 	ldw	r6,28(sp)
  1815f0:	da400417 	ldw	r9,16(sp)
  1815f4:	da800317 	ldw	r10,12(sp)
  1815f8:	113ffd44 	addi	r4,r2,-11
  1815fc:	00c00704 	movi	r3,28
  181600:	19011016 	blt	r3,r4,181a44 <__muldf3+0x6d4>
  181604:	00c00744 	movi	r3,29
  181608:	14bffe04 	addi	r18,r2,-8
  18160c:	1907c83a 	sub	r3,r3,r4
  181610:	8ca2983a 	sll	r17,r17,r18
  181614:	30c6d83a 	srl	r3,r6,r3
  181618:	34a4983a 	sll	r18,r6,r18
  18161c:	1c62b03a 	or	r17,r3,r17
  181620:	1080fcc4 	addi	r2,r2,1011
  181624:	0085c83a 	sub	r2,zero,r2
  181628:	000f883a 	mov	r7,zero
  18162c:	003f8106 	br	181434 <__muldf3+0xc4>
  181630:	3027883a 	mov	r19,r6
  181634:	0081ffc4 	movi	r2,2047
  181638:	0021883a 	mov	r16,zero
  18163c:	002d883a 	mov	r22,zero
  181640:	003faa06 	br	1814ec <__muldf3+0x17c>
  181644:	0023883a 	mov	r17,zero
  181648:	0025883a 	mov	r18,zero
  18164c:	01c00044 	movi	r7,1
  181650:	003f7806 	br	181434 <__muldf3+0xc4>
  181654:	01c000c4 	movi	r7,3
  181658:	003f7606 	br	181434 <__muldf3+0xc4>
  18165c:	05400104 	movi	r21,4
  181660:	0021883a 	mov	r16,zero
  181664:	002d883a 	mov	r22,zero
  181668:	01400044 	movi	r5,1
  18166c:	003f5f06 	br	1813ec <__muldf3+0x7c>
  181670:	05400304 	movi	r21,12
  181674:	014000c4 	movi	r5,3
  181678:	003f5c06 	br	1813ec <__muldf3+0x7c>
  18167c:	04000434 	movhi	r16,16
  181680:	0027883a 	mov	r19,zero
  181684:	843fffc4 	addi	r16,r16,-1
  181688:	05bfffc4 	movi	r22,-1
  18168c:	0081ffc4 	movi	r2,2047
  181690:	003f9606 	br	1814ec <__muldf3+0x17c>
  181694:	8023883a 	mov	r17,r16
  181698:	b025883a 	mov	r18,r22
  18169c:	280f883a 	mov	r7,r5
  1816a0:	003f8806 	br	1814c4 <__muldf3+0x154>
  1816a4:	8023883a 	mov	r17,r16
  1816a8:	b025883a 	mov	r18,r22
  1816ac:	480d883a 	mov	r6,r9
  1816b0:	280f883a 	mov	r7,r5
  1816b4:	003f8306 	br	1814c4 <__muldf3+0x154>
  1816b8:	b026d43a 	srli	r19,r22,16
  1816bc:	902ed43a 	srli	r23,r18,16
  1816c0:	b5bfffcc 	andi	r22,r22,65535
  1816c4:	94bfffcc 	andi	r18,r18,65535
  1816c8:	b00b883a 	mov	r5,r22
  1816cc:	9009883a 	mov	r4,r18
  1816d0:	d8c00515 	stw	r3,20(sp)
  1816d4:	d9800715 	stw	r6,28(sp)
  1816d8:	da000615 	stw	r8,24(sp)
  1816dc:	0181d9c0 	call	181d9c <__mulsi3>
  1816e0:	980b883a 	mov	r5,r19
  1816e4:	9009883a 	mov	r4,r18
  1816e8:	1029883a 	mov	r20,r2
  1816ec:	0181d9c0 	call	181d9c <__mulsi3>
  1816f0:	b80b883a 	mov	r5,r23
  1816f4:	9809883a 	mov	r4,r19
  1816f8:	102b883a 	mov	r21,r2
  1816fc:	0181d9c0 	call	181d9c <__mulsi3>
  181700:	b809883a 	mov	r4,r23
  181704:	b00b883a 	mov	r5,r22
  181708:	1039883a 	mov	fp,r2
  18170c:	0181d9c0 	call	181d9c <__mulsi3>
  181710:	a008d43a 	srli	r4,r20,16
  181714:	1545883a 	add	r2,r2,r21
  181718:	d8c00517 	ldw	r3,20(sp)
  18171c:	2085883a 	add	r2,r4,r2
  181720:	d9800717 	ldw	r6,28(sp)
  181724:	da000617 	ldw	r8,24(sp)
  181728:	1540022e 	bgeu	r2,r21,181734 <__muldf3+0x3c4>
  18172c:	01000074 	movhi	r4,1
  181730:	e139883a 	add	fp,fp,r4
  181734:	100e943a 	slli	r7,r2,16
  181738:	1004d43a 	srli	r2,r2,16
  18173c:	882ad43a 	srli	r21,r17,16
  181740:	a53fffcc 	andi	r20,r20,65535
  181744:	8c7fffcc 	andi	r17,r17,65535
  181748:	3d29883a 	add	r20,r7,r20
  18174c:	b00b883a 	mov	r5,r22
  181750:	8809883a 	mov	r4,r17
  181754:	d8c00515 	stw	r3,20(sp)
  181758:	d9800715 	stw	r6,28(sp)
  18175c:	da000615 	stw	r8,24(sp)
  181760:	dd000115 	stw	r20,4(sp)
  181764:	d8800015 	stw	r2,0(sp)
  181768:	0181d9c0 	call	181d9c <__mulsi3>
  18176c:	980b883a 	mov	r5,r19
  181770:	8809883a 	mov	r4,r17
  181774:	d8800215 	stw	r2,8(sp)
  181778:	0181d9c0 	call	181d9c <__mulsi3>
  18177c:	9809883a 	mov	r4,r19
  181780:	a80b883a 	mov	r5,r21
  181784:	1029883a 	mov	r20,r2
  181788:	0181d9c0 	call	181d9c <__mulsi3>
  18178c:	b00b883a 	mov	r5,r22
  181790:	a809883a 	mov	r4,r21
  181794:	d8800415 	stw	r2,16(sp)
  181798:	0181d9c0 	call	181d9c <__mulsi3>
  18179c:	d9c00217 	ldw	r7,8(sp)
  1817a0:	1505883a 	add	r2,r2,r20
  1817a4:	d8c00517 	ldw	r3,20(sp)
  1817a8:	3826d43a 	srli	r19,r7,16
  1817ac:	d9800717 	ldw	r6,28(sp)
  1817b0:	da000617 	ldw	r8,24(sp)
  1817b4:	9885883a 	add	r2,r19,r2
  1817b8:	da400417 	ldw	r9,16(sp)
  1817bc:	1500022e 	bgeu	r2,r20,1817c8 <__muldf3+0x458>
  1817c0:	01000074 	movhi	r4,1
  1817c4:	4913883a 	add	r9,r9,r4
  1817c8:	1028d43a 	srli	r20,r2,16
  1817cc:	1004943a 	slli	r2,r2,16
  1817d0:	802cd43a 	srli	r22,r16,16
  1817d4:	843fffcc 	andi	r16,r16,65535
  1817d8:	3cffffcc 	andi	r19,r7,65535
  1817dc:	9009883a 	mov	r4,r18
  1817e0:	800b883a 	mov	r5,r16
  1817e4:	a269883a 	add	r20,r20,r9
  1817e8:	d8c00515 	stw	r3,20(sp)
  1817ec:	d9800715 	stw	r6,28(sp)
  1817f0:	da000615 	stw	r8,24(sp)
  1817f4:	14e7883a 	add	r19,r2,r19
  1817f8:	0181d9c0 	call	181d9c <__mulsi3>
  1817fc:	9009883a 	mov	r4,r18
  181800:	b00b883a 	mov	r5,r22
  181804:	d8800315 	stw	r2,12(sp)
  181808:	0181d9c0 	call	181d9c <__mulsi3>
  18180c:	b809883a 	mov	r4,r23
  181810:	b00b883a 	mov	r5,r22
  181814:	d8800215 	stw	r2,8(sp)
  181818:	0181d9c0 	call	181d9c <__mulsi3>
  18181c:	b80b883a 	mov	r5,r23
  181820:	8009883a 	mov	r4,r16
  181824:	d8800415 	stw	r2,16(sp)
  181828:	0181d9c0 	call	181d9c <__mulsi3>
  18182c:	da800317 	ldw	r10,12(sp)
  181830:	d9c00217 	ldw	r7,8(sp)
  181834:	d9000017 	ldw	r4,0(sp)
  181838:	502ed43a 	srli	r23,r10,16
  18183c:	11c5883a 	add	r2,r2,r7
  181840:	24e5883a 	add	r18,r4,r19
  181844:	b885883a 	add	r2,r23,r2
  181848:	d8c00517 	ldw	r3,20(sp)
  18184c:	d9800717 	ldw	r6,28(sp)
  181850:	da000617 	ldw	r8,24(sp)
  181854:	da400417 	ldw	r9,16(sp)
  181858:	11c0022e 	bgeu	r2,r7,181864 <__muldf3+0x4f4>
  18185c:	01000074 	movhi	r4,1
  181860:	4913883a 	add	r9,r9,r4
  181864:	100ed43a 	srli	r7,r2,16
  181868:	1004943a 	slli	r2,r2,16
  18186c:	55ffffcc 	andi	r23,r10,65535
  181870:	3a53883a 	add	r9,r7,r9
  181874:	8809883a 	mov	r4,r17
  181878:	800b883a 	mov	r5,r16
  18187c:	d8c00515 	stw	r3,20(sp)
  181880:	d9800715 	stw	r6,28(sp)
  181884:	da000615 	stw	r8,24(sp)
  181888:	da400415 	stw	r9,16(sp)
  18188c:	15ef883a 	add	r23,r2,r23
  181890:	0181d9c0 	call	181d9c <__mulsi3>
  181894:	8809883a 	mov	r4,r17
  181898:	b00b883a 	mov	r5,r22
  18189c:	d8800215 	stw	r2,8(sp)
  1818a0:	0181d9c0 	call	181d9c <__mulsi3>
  1818a4:	b00b883a 	mov	r5,r22
  1818a8:	a809883a 	mov	r4,r21
  1818ac:	d8800315 	stw	r2,12(sp)
  1818b0:	0181d9c0 	call	181d9c <__mulsi3>
  1818b4:	8009883a 	mov	r4,r16
  1818b8:	a80b883a 	mov	r5,r21
  1818bc:	1023883a 	mov	r17,r2
  1818c0:	0181d9c0 	call	181d9c <__mulsi3>
  1818c4:	d9c00217 	ldw	r7,8(sp)
  1818c8:	da800317 	ldw	r10,12(sp)
  1818cc:	d8c00517 	ldw	r3,20(sp)
  1818d0:	3808d43a 	srli	r4,r7,16
  1818d4:	1285883a 	add	r2,r2,r10
  1818d8:	d9800717 	ldw	r6,28(sp)
  1818dc:	2085883a 	add	r2,r4,r2
  1818e0:	da000617 	ldw	r8,24(sp)
  1818e4:	da400417 	ldw	r9,16(sp)
  1818e8:	1280022e 	bgeu	r2,r10,1818f4 <__muldf3+0x584>
  1818ec:	01000074 	movhi	r4,1
  1818f0:	8923883a 	add	r17,r17,r4
  1818f4:	1008943a 	slli	r4,r2,16
  1818f8:	39ffffcc 	andi	r7,r7,65535
  1818fc:	e4b9883a 	add	fp,fp,r18
  181900:	21cf883a 	add	r7,r4,r7
  181904:	e4e7803a 	cmpltu	r19,fp,r19
  181908:	3d0f883a 	add	r7,r7,r20
  18190c:	bf39883a 	add	fp,r23,fp
  181910:	99c9883a 	add	r4,r19,r7
  181914:	e5ef803a 	cmpltu	r23,fp,r23
  181918:	490b883a 	add	r5,r9,r4
  18191c:	1004d43a 	srli	r2,r2,16
  181920:	b965883a 	add	r18,r23,r5
  181924:	24c9803a 	cmpltu	r4,r4,r19
  181928:	3d29803a 	cmpltu	r20,r7,r20
  18192c:	a128b03a 	or	r20,r20,r4
  181930:	95ef803a 	cmpltu	r23,r18,r23
  181934:	2a53803a 	cmpltu	r9,r5,r9
  181938:	a0a9883a 	add	r20,r20,r2
  18193c:	4deeb03a 	or	r23,r9,r23
  181940:	a5ef883a 	add	r23,r20,r23
  181944:	bc63883a 	add	r17,r23,r17
  181948:	e004927a 	slli	r2,fp,9
  18194c:	d9000117 	ldw	r4,4(sp)
  181950:	882e927a 	slli	r23,r17,9
  181954:	9022d5fa 	srli	r17,r18,23
  181958:	e038d5fa 	srli	fp,fp,23
  18195c:	1104b03a 	or	r2,r2,r4
  181960:	9024927a 	slli	r18,r18,9
  181964:	1004c03a 	cmpne	r2,r2,zero
  181968:	bc62b03a 	or	r17,r23,r17
  18196c:	1738b03a 	or	fp,r2,fp
  181970:	8880402c 	andhi	r2,r17,256
  181974:	e4a4b03a 	or	r18,fp,r18
  181978:	10000726 	beq	r2,zero,181998 <__muldf3+0x628>
  18197c:	9006d07a 	srli	r3,r18,1
  181980:	880497fa 	slli	r2,r17,31
  181984:	9480004c 	andi	r18,r18,1
  181988:	8822d07a 	srli	r17,r17,1
  18198c:	1ca4b03a 	or	r18,r3,r18
  181990:	14a4b03a 	or	r18,r2,r18
  181994:	4007883a 	mov	r3,r8
  181998:	1880ffc4 	addi	r2,r3,1023
  18199c:	0080460e 	bge	zero,r2,181ab8 <__muldf3+0x748>
  1819a0:	910001cc 	andi	r4,r18,7
  1819a4:	20000726 	beq	r4,zero,1819c4 <__muldf3+0x654>
  1819a8:	910003cc 	andi	r4,r18,15
  1819ac:	01400104 	movi	r5,4
  1819b0:	21400426 	beq	r4,r5,1819c4 <__muldf3+0x654>
  1819b4:	9149883a 	add	r4,r18,r5
  1819b8:	24a5803a 	cmpltu	r18,r4,r18
  1819bc:	8ca3883a 	add	r17,r17,r18
  1819c0:	2025883a 	mov	r18,r4
  1819c4:	8900402c 	andhi	r4,r17,256
  1819c8:	20000426 	beq	r4,zero,1819dc <__muldf3+0x66c>
  1819cc:	18810004 	addi	r2,r3,1024
  1819d0:	00ffc034 	movhi	r3,65280
  1819d4:	18ffffc4 	addi	r3,r3,-1
  1819d8:	88e2703a 	and	r17,r17,r3
  1819dc:	00c1ff84 	movi	r3,2046
  1819e0:	18bf1316 	blt	r3,r2,181630 <__muldf3+0x2c0>
  1819e4:	882c977a 	slli	r22,r17,29
  1819e8:	9024d0fa 	srli	r18,r18,3
  1819ec:	8822927a 	slli	r17,r17,9
  1819f0:	1081ffcc 	andi	r2,r2,2047
  1819f4:	b4acb03a 	or	r22,r22,r18
  1819f8:	8820d33a 	srli	r16,r17,12
  1819fc:	3027883a 	mov	r19,r6
  181a00:	003eba06 	br	1814ec <__muldf3+0x17c>
  181a04:	8080022c 	andhi	r2,r16,8
  181a08:	10000926 	beq	r2,zero,181a30 <__muldf3+0x6c0>
  181a0c:	8880022c 	andhi	r2,r17,8
  181a10:	1000071e 	bne	r2,zero,181a30 <__muldf3+0x6c0>
  181a14:	00800434 	movhi	r2,16
  181a18:	8c000234 	orhi	r16,r17,8
  181a1c:	10bfffc4 	addi	r2,r2,-1
  181a20:	e027883a 	mov	r19,fp
  181a24:	80a0703a 	and	r16,r16,r2
  181a28:	902d883a 	mov	r22,r18
  181a2c:	003f1706 	br	18168c <__muldf3+0x31c>
  181a30:	00800434 	movhi	r2,16
  181a34:	84000234 	orhi	r16,r16,8
  181a38:	10bfffc4 	addi	r2,r2,-1
  181a3c:	80a0703a 	and	r16,r16,r2
  181a40:	003f1206 	br	18168c <__muldf3+0x31c>
  181a44:	147ff604 	addi	r17,r2,-40
  181a48:	3462983a 	sll	r17,r6,r17
  181a4c:	0025883a 	mov	r18,zero
  181a50:	003ef306 	br	181620 <__muldf3+0x2b0>
  181a54:	3009883a 	mov	r4,r6
  181a58:	d9400215 	stw	r5,8(sp)
  181a5c:	d9800715 	stw	r6,28(sp)
  181a60:	da400415 	stw	r9,16(sp)
  181a64:	da800315 	stw	r10,12(sp)
  181a68:	0181d380 	call	181d38 <__clzsi2>
  181a6c:	10800804 	addi	r2,r2,32
  181a70:	da800317 	ldw	r10,12(sp)
  181a74:	da400417 	ldw	r9,16(sp)
  181a78:	d9800717 	ldw	r6,28(sp)
  181a7c:	d9400217 	ldw	r5,8(sp)
  181a80:	003edd06 	br	1815f8 <__muldf3+0x288>
  181a84:	143ff604 	addi	r16,r2,-40
  181a88:	ac20983a 	sll	r16,r21,r16
  181a8c:	002d883a 	mov	r22,zero
  181a90:	003ec106 	br	181598 <__muldf3+0x228>
  181a94:	d9800715 	stw	r6,28(sp)
  181a98:	d9c00215 	stw	r7,8(sp)
  181a9c:	da400415 	stw	r9,16(sp)
  181aa0:	0181d380 	call	181d38 <__clzsi2>
  181aa4:	10800804 	addi	r2,r2,32
  181aa8:	da400417 	ldw	r9,16(sp)
  181aac:	d9c00217 	ldw	r7,8(sp)
  181ab0:	d9800717 	ldw	r6,28(sp)
  181ab4:	003eae06 	br	181570 <__muldf3+0x200>
  181ab8:	00c00044 	movi	r3,1
  181abc:	1887c83a 	sub	r3,r3,r2
  181ac0:	01000e04 	movi	r4,56
  181ac4:	20fe8516 	blt	r4,r3,1814dc <__muldf3+0x16c>
  181ac8:	010007c4 	movi	r4,31
  181acc:	20c01b16 	blt	r4,r3,181b3c <__muldf3+0x7cc>
  181ad0:	00800804 	movi	r2,32
  181ad4:	10c5c83a 	sub	r2,r2,r3
  181ad8:	888a983a 	sll	r5,r17,r2
  181adc:	90c8d83a 	srl	r4,r18,r3
  181ae0:	9084983a 	sll	r2,r18,r2
  181ae4:	88e2d83a 	srl	r17,r17,r3
  181ae8:	2906b03a 	or	r3,r5,r4
  181aec:	1004c03a 	cmpne	r2,r2,zero
  181af0:	1886b03a 	or	r3,r3,r2
  181af4:	188001cc 	andi	r2,r3,7
  181af8:	10000726 	beq	r2,zero,181b18 <__muldf3+0x7a8>
  181afc:	188003cc 	andi	r2,r3,15
  181b00:	01000104 	movi	r4,4
  181b04:	11000426 	beq	r2,r4,181b18 <__muldf3+0x7a8>
  181b08:	1805883a 	mov	r2,r3
  181b0c:	10c00104 	addi	r3,r2,4
  181b10:	1885803a 	cmpltu	r2,r3,r2
  181b14:	88a3883a 	add	r17,r17,r2
  181b18:	8880202c 	andhi	r2,r17,128
  181b1c:	10001c26 	beq	r2,zero,181b90 <__muldf3+0x820>
  181b20:	3027883a 	mov	r19,r6
  181b24:	00800044 	movi	r2,1
  181b28:	0021883a 	mov	r16,zero
  181b2c:	002d883a 	mov	r22,zero
  181b30:	003e6e06 	br	1814ec <__muldf3+0x17c>
  181b34:	4007883a 	mov	r3,r8
  181b38:	003f9706 	br	181998 <__muldf3+0x628>
  181b3c:	017ff844 	movi	r5,-31
  181b40:	2885c83a 	sub	r2,r5,r2
  181b44:	888ad83a 	srl	r5,r17,r2
  181b48:	00800804 	movi	r2,32
  181b4c:	18801a26 	beq	r3,r2,181bb8 <__muldf3+0x848>
  181b50:	01001004 	movi	r4,64
  181b54:	20c7c83a 	sub	r3,r4,r3
  181b58:	88e2983a 	sll	r17,r17,r3
  181b5c:	8ca4b03a 	or	r18,r17,r18
  181b60:	9004c03a 	cmpne	r2,r18,zero
  181b64:	2884b03a 	or	r2,r5,r2
  181b68:	144001cc 	andi	r17,r2,7
  181b6c:	88000d1e 	bne	r17,zero,181ba4 <__muldf3+0x834>
  181b70:	0021883a 	mov	r16,zero
  181b74:	102cd0fa 	srli	r22,r2,3
  181b78:	3027883a 	mov	r19,r6
  181b7c:	0005883a 	mov	r2,zero
  181b80:	b46cb03a 	or	r22,r22,r17
  181b84:	003e5906 	br	1814ec <__muldf3+0x17c>
  181b88:	1007883a 	mov	r3,r2
  181b8c:	0023883a 	mov	r17,zero
  181b90:	8820927a 	slli	r16,r17,9
  181b94:	1805883a 	mov	r2,r3
  181b98:	8822977a 	slli	r17,r17,29
  181b9c:	8020d33a 	srli	r16,r16,12
  181ba0:	003ff406 	br	181b74 <__muldf3+0x804>
  181ba4:	10c003cc 	andi	r3,r2,15
  181ba8:	01000104 	movi	r4,4
  181bac:	193ff626 	beq	r3,r4,181b88 <__muldf3+0x818>
  181bb0:	0023883a 	mov	r17,zero
  181bb4:	003fd506 	br	181b0c <__muldf3+0x79c>
  181bb8:	0023883a 	mov	r17,zero
  181bbc:	003fe706 	br	181b5c <__muldf3+0x7ec>
  181bc0:	00800434 	movhi	r2,16
  181bc4:	8c000234 	orhi	r16,r17,8
  181bc8:	10bfffc4 	addi	r2,r2,-1
  181bcc:	3027883a 	mov	r19,r6
  181bd0:	80a0703a 	and	r16,r16,r2
  181bd4:	902d883a 	mov	r22,r18
  181bd8:	003eac06 	br	18168c <__muldf3+0x31c>

00181bdc <__fixdfsi>:
  181bdc:	280cd53a 	srli	r6,r5,20
  181be0:	00c00434 	movhi	r3,16
  181be4:	18ffffc4 	addi	r3,r3,-1
  181be8:	3181ffcc 	andi	r6,r6,2047
  181bec:	01c0ff84 	movi	r7,1022
  181bf0:	28c6703a 	and	r3,r5,r3
  181bf4:	280ad7fa 	srli	r5,r5,31
  181bf8:	3980120e 	bge	r7,r6,181c44 <__fixdfsi+0x68>
  181bfc:	00810744 	movi	r2,1053
  181c00:	11800c16 	blt	r2,r6,181c34 <__fixdfsi+0x58>
  181c04:	00810cc4 	movi	r2,1075
  181c08:	1185c83a 	sub	r2,r2,r6
  181c0c:	01c007c4 	movi	r7,31
  181c10:	18c00434 	orhi	r3,r3,16
  181c14:	38800d16 	blt	r7,r2,181c4c <__fixdfsi+0x70>
  181c18:	31befb44 	addi	r6,r6,-1043
  181c1c:	2084d83a 	srl	r2,r4,r2
  181c20:	1986983a 	sll	r3,r3,r6
  181c24:	1884b03a 	or	r2,r3,r2
  181c28:	28000726 	beq	r5,zero,181c48 <__fixdfsi+0x6c>
  181c2c:	0085c83a 	sub	r2,zero,r2
  181c30:	f800283a 	ret
  181c34:	00a00034 	movhi	r2,32768
  181c38:	10bfffc4 	addi	r2,r2,-1
  181c3c:	2885883a 	add	r2,r5,r2
  181c40:	f800283a 	ret
  181c44:	0005883a 	mov	r2,zero
  181c48:	f800283a 	ret
  181c4c:	008104c4 	movi	r2,1043
  181c50:	1185c83a 	sub	r2,r2,r6
  181c54:	1884d83a 	srl	r2,r3,r2
  181c58:	003ff306 	br	181c28 <__fixdfsi+0x4c>

00181c5c <__floatsidf>:
  181c5c:	defffd04 	addi	sp,sp,-12
  181c60:	dfc00215 	stw	ra,8(sp)
  181c64:	dc400115 	stw	r17,4(sp)
  181c68:	dc000015 	stw	r16,0(sp)
  181c6c:	20002b26 	beq	r4,zero,181d1c <__floatsidf+0xc0>
  181c70:	2023883a 	mov	r17,r4
  181c74:	2020d7fa 	srli	r16,r4,31
  181c78:	20002d16 	blt	r4,zero,181d30 <__floatsidf+0xd4>
  181c7c:	8809883a 	mov	r4,r17
  181c80:	0181d380 	call	181d38 <__clzsi2>
  181c84:	01410784 	movi	r5,1054
  181c88:	288bc83a 	sub	r5,r5,r2
  181c8c:	01010cc4 	movi	r4,1075
  181c90:	2149c83a 	sub	r4,r4,r5
  181c94:	00c007c4 	movi	r3,31
  181c98:	1900160e 	bge	r3,r4,181cf4 <__floatsidf+0x98>
  181c9c:	00c104c4 	movi	r3,1043
  181ca0:	1947c83a 	sub	r3,r3,r5
  181ca4:	88c6983a 	sll	r3,r17,r3
  181ca8:	00800434 	movhi	r2,16
  181cac:	10bfffc4 	addi	r2,r2,-1
  181cb0:	1886703a 	and	r3,r3,r2
  181cb4:	2941ffcc 	andi	r5,r5,2047
  181cb8:	800d883a 	mov	r6,r16
  181cbc:	0005883a 	mov	r2,zero
  181cc0:	280a953a 	slli	r5,r5,20
  181cc4:	31803fcc 	andi	r6,r6,255
  181cc8:	01000434 	movhi	r4,16
  181ccc:	300c97fa 	slli	r6,r6,31
  181cd0:	213fffc4 	addi	r4,r4,-1
  181cd4:	1906703a 	and	r3,r3,r4
  181cd8:	1946b03a 	or	r3,r3,r5
  181cdc:	1986b03a 	or	r3,r3,r6
  181ce0:	dfc00217 	ldw	ra,8(sp)
  181ce4:	dc400117 	ldw	r17,4(sp)
  181ce8:	dc000017 	ldw	r16,0(sp)
  181cec:	dec00304 	addi	sp,sp,12
  181cf0:	f800283a 	ret
  181cf4:	00c002c4 	movi	r3,11
  181cf8:	1887c83a 	sub	r3,r3,r2
  181cfc:	88c6d83a 	srl	r3,r17,r3
  181d00:	8904983a 	sll	r2,r17,r4
  181d04:	01000434 	movhi	r4,16
  181d08:	213fffc4 	addi	r4,r4,-1
  181d0c:	2941ffcc 	andi	r5,r5,2047
  181d10:	1906703a 	and	r3,r3,r4
  181d14:	800d883a 	mov	r6,r16
  181d18:	003fe906 	br	181cc0 <__floatsidf+0x64>
  181d1c:	000d883a 	mov	r6,zero
  181d20:	000b883a 	mov	r5,zero
  181d24:	0007883a 	mov	r3,zero
  181d28:	0005883a 	mov	r2,zero
  181d2c:	003fe406 	br	181cc0 <__floatsidf+0x64>
  181d30:	0123c83a 	sub	r17,zero,r4
  181d34:	003fd106 	br	181c7c <__floatsidf+0x20>

00181d38 <__clzsi2>:
  181d38:	00bfffd4 	movui	r2,65535
  181d3c:	11000536 	bltu	r2,r4,181d54 <__clzsi2+0x1c>
  181d40:	00803fc4 	movi	r2,255
  181d44:	11000f36 	bltu	r2,r4,181d84 <__clzsi2+0x4c>
  181d48:	00800804 	movi	r2,32
  181d4c:	0007883a 	mov	r3,zero
  181d50:	00000506 	br	181d68 <__clzsi2+0x30>
  181d54:	00804034 	movhi	r2,256
  181d58:	10bfffc4 	addi	r2,r2,-1
  181d5c:	11000c2e 	bgeu	r2,r4,181d90 <__clzsi2+0x58>
  181d60:	00800204 	movi	r2,8
  181d64:	00c00604 	movi	r3,24
  181d68:	20c8d83a 	srl	r4,r4,r3
  181d6c:	00c00634 	movhi	r3,24
  181d70:	18cbb504 	addi	r3,r3,11988
  181d74:	1909883a 	add	r4,r3,r4
  181d78:	20c00003 	ldbu	r3,0(r4)
  181d7c:	10c5c83a 	sub	r2,r2,r3
  181d80:	f800283a 	ret
  181d84:	00800604 	movi	r2,24
  181d88:	00c00204 	movi	r3,8
  181d8c:	003ff606 	br	181d68 <__clzsi2+0x30>
  181d90:	00800404 	movi	r2,16
  181d94:	1007883a 	mov	r3,r2
  181d98:	003ff306 	br	181d68 <__clzsi2+0x30>

00181d9c <__mulsi3>:
  181d9c:	0005883a 	mov	r2,zero
  181da0:	20000726 	beq	r4,zero,181dc0 <__mulsi3+0x24>
  181da4:	20c0004c 	andi	r3,r4,1
  181da8:	2008d07a 	srli	r4,r4,1
  181dac:	18000126 	beq	r3,zero,181db4 <__mulsi3+0x18>
  181db0:	1145883a 	add	r2,r2,r5
  181db4:	294b883a 	add	r5,r5,r5
  181db8:	203ffa1e 	bne	r4,zero,181da4 <__mulsi3+0x8>
  181dbc:	f800283a 	ret
  181dc0:	f800283a 	ret

00181dc4 <memcpy>:
  181dc4:	2005883a 	mov	r2,r4
  181dc8:	2007883a 	mov	r3,r4
  181dcc:	218d883a 	add	r6,r4,r6
  181dd0:	19800526 	beq	r3,r6,181de8 <memcpy+0x24>
  181dd4:	29000003 	ldbu	r4,0(r5)
  181dd8:	18c00044 	addi	r3,r3,1
  181ddc:	29400044 	addi	r5,r5,1
  181de0:	193fffc5 	stb	r4,-1(r3)
  181de4:	003ffa06 	br	181dd0 <memcpy+0xc>
  181de8:	f800283a 	ret

00181dec <_putchar_r>:
  181dec:	21800217 	ldw	r6,8(r4)
  181df0:	0181e801 	jmpi	181e80 <_putc_r>

00181df4 <putchar>:
  181df4:	00800634 	movhi	r2,24
  181df8:	108e1e04 	addi	r2,r2,14456
  181dfc:	10800017 	ldw	r2,0(r2)
  181e00:	200b883a 	mov	r5,r4
  181e04:	11800217 	ldw	r6,8(r2)
  181e08:	1009883a 	mov	r4,r2
  181e0c:	0181e801 	jmpi	181e80 <_putc_r>

00181e10 <strlen>:
  181e10:	2005883a 	mov	r2,r4
  181e14:	10c00007 	ldb	r3,0(r2)
  181e18:	18000226 	beq	r3,zero,181e24 <strlen+0x14>
  181e1c:	10800044 	addi	r2,r2,1
  181e20:	003ffc06 	br	181e14 <strlen+0x4>
  181e24:	1105c83a 	sub	r2,r2,r4
  181e28:	f800283a 	ret

00181e2c <putc>:
  181e2c:	defffd04 	addi	sp,sp,-12
  181e30:	00800634 	movhi	r2,24
  181e34:	dc000115 	stw	r16,4(sp)
  181e38:	dfc00215 	stw	ra,8(sp)
  181e3c:	1087b604 	addi	r2,r2,7896
  181e40:	28800115 	stw	r2,4(r5)
  181e44:	00800634 	movhi	r2,24
  181e48:	108e1e04 	addi	r2,r2,14456
  181e4c:	d9000005 	stb	r4,0(sp)
  181e50:	2021883a 	mov	r16,r4
  181e54:	11000017 	ldw	r4,0(r2)
  181e58:	01c00044 	movi	r7,1
  181e5c:	d80d883a 	mov	r6,sp
  181e60:	0181ed80 	call	181ed8 <__sfvwrite_small_dev>
  181e64:	00ffffc4 	movi	r3,-1
  181e68:	10c00126 	beq	r2,r3,181e70 <putc+0x44>
  181e6c:	8005883a 	mov	r2,r16
  181e70:	dfc00217 	ldw	ra,8(sp)
  181e74:	dc000117 	ldw	r16,4(sp)
  181e78:	dec00304 	addi	sp,sp,12
  181e7c:	f800283a 	ret

00181e80 <_putc_r>:
  181e80:	defffd04 	addi	sp,sp,-12
  181e84:	00800634 	movhi	r2,24
  181e88:	dc000115 	stw	r16,4(sp)
  181e8c:	dfc00215 	stw	ra,8(sp)
  181e90:	1087b604 	addi	r2,r2,7896
  181e94:	30800115 	stw	r2,4(r6)
  181e98:	00800634 	movhi	r2,24
  181e9c:	108e1e04 	addi	r2,r2,14456
  181ea0:	11000017 	ldw	r4,0(r2)
  181ea4:	2821883a 	mov	r16,r5
  181ea8:	01c00044 	movi	r7,1
  181eac:	300b883a 	mov	r5,r6
  181eb0:	d80d883a 	mov	r6,sp
  181eb4:	dc000005 	stb	r16,0(sp)
  181eb8:	0181ed80 	call	181ed8 <__sfvwrite_small_dev>
  181ebc:	00ffffc4 	movi	r3,-1
  181ec0:	10c00126 	beq	r2,r3,181ec8 <_putc_r+0x48>
  181ec4:	8005883a 	mov	r2,r16
  181ec8:	dfc00217 	ldw	ra,8(sp)
  181ecc:	dc000117 	ldw	r16,4(sp)
  181ed0:	dec00304 	addi	sp,sp,12
  181ed4:	f800283a 	ret

00181ed8 <__sfvwrite_small_dev>:
  181ed8:	2880000b 	ldhu	r2,0(r5)
  181edc:	1080020c 	andi	r2,r2,8
  181ee0:	10002126 	beq	r2,zero,181f68 <__sfvwrite_small_dev+0x90>
  181ee4:	2880008f 	ldh	r2,2(r5)
  181ee8:	defffa04 	addi	sp,sp,-24
  181eec:	dc000015 	stw	r16,0(sp)
  181ef0:	dfc00515 	stw	ra,20(sp)
  181ef4:	dd000415 	stw	r20,16(sp)
  181ef8:	dcc00315 	stw	r19,12(sp)
  181efc:	dc800215 	stw	r18,8(sp)
  181f00:	dc400115 	stw	r17,4(sp)
  181f04:	2821883a 	mov	r16,r5
  181f08:	10001216 	blt	r2,zero,181f54 <__sfvwrite_small_dev+0x7c>
  181f0c:	2027883a 	mov	r19,r4
  181f10:	3025883a 	mov	r18,r6
  181f14:	3823883a 	mov	r17,r7
  181f18:	05010004 	movi	r20,1024
  181f1c:	04400b0e 	bge	zero,r17,181f4c <__sfvwrite_small_dev+0x74>
  181f20:	880f883a 	mov	r7,r17
  181f24:	a440010e 	bge	r20,r17,181f2c <__sfvwrite_small_dev+0x54>
  181f28:	01c10004 	movi	r7,1024
  181f2c:	8140008f 	ldh	r5,2(r16)
  181f30:	900d883a 	mov	r6,r18
  181f34:	9809883a 	mov	r4,r19
  181f38:	0181f900 	call	181f90 <_write_r>
  181f3c:	0080050e 	bge	zero,r2,181f54 <__sfvwrite_small_dev+0x7c>
  181f40:	88a3c83a 	sub	r17,r17,r2
  181f44:	90a5883a 	add	r18,r18,r2
  181f48:	003ff406 	br	181f1c <__sfvwrite_small_dev+0x44>
  181f4c:	0005883a 	mov	r2,zero
  181f50:	00000706 	br	181f70 <__sfvwrite_small_dev+0x98>
  181f54:	8080000b 	ldhu	r2,0(r16)
  181f58:	10801014 	ori	r2,r2,64
  181f5c:	8080000d 	sth	r2,0(r16)
  181f60:	00bfffc4 	movi	r2,-1
  181f64:	00000206 	br	181f70 <__sfvwrite_small_dev+0x98>
  181f68:	00bfffc4 	movi	r2,-1
  181f6c:	f800283a 	ret
  181f70:	dfc00517 	ldw	ra,20(sp)
  181f74:	dd000417 	ldw	r20,16(sp)
  181f78:	dcc00317 	ldw	r19,12(sp)
  181f7c:	dc800217 	ldw	r18,8(sp)
  181f80:	dc400117 	ldw	r17,4(sp)
  181f84:	dc000017 	ldw	r16,0(sp)
  181f88:	dec00604 	addi	sp,sp,24
  181f8c:	f800283a 	ret

00181f90 <_write_r>:
  181f90:	defffd04 	addi	sp,sp,-12
  181f94:	dc000015 	stw	r16,0(sp)
  181f98:	04000634 	movhi	r16,24
  181f9c:	dc400115 	stw	r17,4(sp)
  181fa0:	84105804 	addi	r16,r16,16736
  181fa4:	2023883a 	mov	r17,r4
  181fa8:	2809883a 	mov	r4,r5
  181fac:	300b883a 	mov	r5,r6
  181fb0:	380d883a 	mov	r6,r7
  181fb4:	dfc00215 	stw	ra,8(sp)
  181fb8:	80000015 	stw	zero,0(r16)
  181fbc:	01822b00 	call	1822b0 <write>
  181fc0:	00ffffc4 	movi	r3,-1
  181fc4:	10c0031e 	bne	r2,r3,181fd4 <_write_r+0x44>
  181fc8:	80c00017 	ldw	r3,0(r16)
  181fcc:	18000126 	beq	r3,zero,181fd4 <_write_r+0x44>
  181fd0:	88c00015 	stw	r3,0(r17)
  181fd4:	dfc00217 	ldw	ra,8(sp)
  181fd8:	dc400117 	ldw	r17,4(sp)
  181fdc:	dc000017 	ldw	r16,0(sp)
  181fe0:	dec00304 	addi	sp,sp,12
  181fe4:	f800283a 	ret

00181fe8 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
  181fe8:	deffff04 	addi	sp,sp,-4
  181fec:	01000634 	movhi	r4,24
  181ff0:	01400634 	movhi	r5,24
  181ff4:	dfc00015 	stw	ra,0(sp)
  181ff8:	210bf504 	addi	r4,r4,12244
  181ffc:	294e2404 	addi	r5,r5,14480

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  182000:	2140061e 	bne	r4,r5,18201c <alt_load+0x34>
  182004:	01000634 	movhi	r4,24
  182008:	01400634 	movhi	r5,24
  18200c:	21000804 	addi	r4,r4,32
  182010:	29400804 	addi	r5,r5,32
  182014:	2140121e 	bne	r4,r5,182060 <alt_load+0x78>
  182018:	00000b06 	br	182048 <alt_load+0x60>
  18201c:	00c00634 	movhi	r3,24
  182020:	18ce2404 	addi	r3,r3,14480
  182024:	1907c83a 	sub	r3,r3,r4
  182028:	0005883a 	mov	r2,zero
  {
    while( to != end )
  18202c:	10fff526 	beq	r2,r3,182004 <alt_load+0x1c>
    {
      *to++ = *from++;
  182030:	114f883a 	add	r7,r2,r5
  182034:	39c00017 	ldw	r7,0(r7)
  182038:	110d883a 	add	r6,r2,r4
  18203c:	10800104 	addi	r2,r2,4
  182040:	31c00015 	stw	r7,0(r6)
  182044:	003ff906 	br	18202c <alt_load+0x44>
  182048:	01000634 	movhi	r4,24
  18204c:	01400634 	movhi	r5,24
  182050:	210b6d04 	addi	r4,r4,11700
  182054:	294b6d04 	addi	r5,r5,11700

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  182058:	2140101e 	bne	r4,r5,18209c <alt_load+0xb4>
  18205c:	00000b06 	br	18208c <alt_load+0xa4>
  182060:	00c00634 	movhi	r3,24
  182064:	18c05304 	addi	r3,r3,332
  182068:	1907c83a 	sub	r3,r3,r4
  18206c:	0005883a 	mov	r2,zero
  {
    while( to != end )
  182070:	10fff526 	beq	r2,r3,182048 <alt_load+0x60>
    {
      *to++ = *from++;
  182074:	114f883a 	add	r7,r2,r5
  182078:	39c00017 	ldw	r7,0(r7)
  18207c:	110d883a 	add	r6,r2,r4
  182080:	10800104 	addi	r2,r2,4
  182084:	31c00015 	stw	r7,0(r6)
  182088:	003ff906 	br	182070 <alt_load+0x88>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  18208c:	01829ec0 	call	1829ec <alt_dcache_flush_all>
  alt_icache_flush_all();
}
  182090:	dfc00017 	ldw	ra,0(sp)
  182094:	dec00104 	addi	sp,sp,4
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  alt_icache_flush_all();
  182098:	0182ad01 	jmpi	182ad0 <alt_icache_flush_all>
  18209c:	00c00634 	movhi	r3,24
  1820a0:	18cbf504 	addi	r3,r3,12244
  1820a4:	1907c83a 	sub	r3,r3,r4

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  1820a8:	0005883a 	mov	r2,zero
  {
    while( to != end )
  1820ac:	18bff726 	beq	r3,r2,18208c <alt_load+0xa4>
    {
      *to++ = *from++;
  1820b0:	114f883a 	add	r7,r2,r5
  1820b4:	39c00017 	ldw	r7,0(r7)
  1820b8:	110d883a 	add	r6,r2,r4
  1820bc:	10800104 	addi	r2,r2,4
  1820c0:	31c00015 	stw	r7,0(r6)
  1820c4:	003ff906 	br	1820ac <alt_load+0xc4>

001820c8 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
  1820c8:	deffff04 	addi	sp,sp,-4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
  1820cc:	0009883a 	mov	r4,zero
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
  1820d0:	dfc00015 	stw	ra,0(sp)
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
  1820d4:	01823100 	call	182310 <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
  1820d8:	01823300 	call	182330 <alt_sys_init>
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
  1820dc:	d1a23c17 	ldw	r6,-30480(gp)
  1820e0:	d1623d17 	ldw	r5,-30476(gp)
  1820e4:	d1223e17 	ldw	r4,-30472(gp)
  close(STDOUT_FILENO);
  exit (result);
#endif

  ALT_LOG_PRINT_BOOT("[alt_main.c] After main - we should not be here?.\r\n");
}
  1820e8:	dfc00017 	ldw	ra,0(sp)
  1820ec:	dec00104 	addi	sp,sp,4
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
  1820f0:	01807341 	jmpi	180734 <main>

001820f4 <alt_printf>:
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
  1820f4:	defff204 	addi	sp,sp,-56
  1820f8:	2005883a 	mov	r2,r4
  1820fc:	dfc00a15 	stw	ra,40(sp)
  182100:	df000915 	stw	fp,36(sp)
  182104:	ddc00815 	stw	r23,32(sp)
  182108:	dd800715 	stw	r22,28(sp)
  18210c:	dd400615 	stw	r21,24(sp)
  182110:	dd000515 	stw	r20,20(sp)
  182114:	dcc00415 	stw	r19,16(sp)
  182118:	dc800315 	stw	r18,12(sp)
  18211c:	dc400215 	stw	r17,8(sp)
  182120:	dc000115 	stw	r16,4(sp)
  182124:	d9400b15 	stw	r5,44(sp)
  182128:	d9800c15 	stw	r6,48(sp)
  18212c:	d9c00d15 	stw	r7,52(sp)
    w = fmt;
    while ((c = *w++) != 0)
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
  182130:	04000944 	movi	r16,37
 */
void 
alt_printf(const char* fmt, ... )
{
	va_list args;
	va_start(args, fmt);
  182134:	dd400b04 	addi	r21,sp,44
                if (c == '%')
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
                } 
                else if (c == 'c')
  182138:	048018c4 	movi	r18,99
                {
                    int v = va_arg(args, int);
                    alt_putchar(v);
                }
                else if (c == 'x')
  18213c:	04c01e04 	movi	r19,120
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
  182140:	05001cc4 	movi	r20,115
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
  182144:	11000007 	ldb	r4,0(r2)
  182148:	20003a26 	beq	r4,zero,182234 <alt_printf+0x140>
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
  18214c:	24000226 	beq	r4,r16,182158 <alt_printf+0x64>
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
  182150:	14400044 	addi	r17,r2,1
  182154:	00001406 	br	1821a8 <alt_printf+0xb4>
        }
        else
        {
            /* Get format character.  If none     */
            /* available, processing is complete. */
            if ((c = *w++) != 0)
  182158:	14400084 	addi	r17,r2,2
  18215c:	10800047 	ldb	r2,1(r2)
  182160:	10003426 	beq	r2,zero,182234 <alt_printf+0x140>
            {
                if (c == '%')
  182164:	1400021e 	bne	r2,r16,182170 <alt_printf+0x7c>
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
  182168:	8009883a 	mov	r4,r16
  18216c:	00000e06 	br	1821a8 <alt_printf+0xb4>
                } 
                else if (c == 'c')
  182170:	1480051e 	bne	r2,r18,182188 <alt_printf+0x94>
                {
                    int v = va_arg(args, int);
                    alt_putchar(v);
  182174:	a9000017 	ldw	r4,0(r21)
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
                } 
                else if (c == 'c')
                {
                    int v = va_arg(args, int);
  182178:	ad800104 	addi	r22,r21,4
  18217c:	b02b883a 	mov	r21,r22
                    alt_putchar(v);
  182180:	01822640 	call	182264 <alt_putchar>
  182184:	00002906 	br	18222c <alt_printf+0x138>
                }
                else if (c == 'x')
  182188:	14c0201e 	bne	r2,r19,18220c <alt_printf+0x118>
                {
                    /* Process hexadecimal number format. */
                    unsigned long v = va_arg(args, unsigned long);
  18218c:	adc00017 	ldw	r23,0(r21)
  182190:	ad400104 	addi	r21,r21,4
                    unsigned long digit;
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
  182194:	b8000326 	beq	r23,zero,1821a4 <alt_printf+0xb0>
  182198:	05800704 	movi	r22,28
                        continue;
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
  18219c:	00c003c4 	movi	r3,15
  1821a0:	00000306 	br	1821b0 <alt_printf+0xbc>
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
                    {
                        alt_putchar('0');
  1821a4:	01000c04 	movi	r4,48
  1821a8:	01822640 	call	182264 <alt_putchar>
                        continue;
  1821ac:	00001f06 	br	18222c <alt_printf+0x138>
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
  1821b0:	1d84983a 	sll	r2,r3,r22
  1821b4:	15c4703a 	and	r2,r2,r23
  1821b8:	1000021e 	bne	r2,zero,1821c4 <alt_printf+0xd0>
                        digit_shift -= 4;
  1821bc:	b5bfff04 	addi	r22,r22,-4
  1821c0:	003ffb06 	br	1821b0 <alt_printf+0xbc>

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
  1821c4:	070003c4 	movi	fp,15
                        if (digit <= 9)
  1821c8:	00c00244 	movi	r3,9
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
  1821cc:	b0001716 	blt	r22,zero,18222c <alt_printf+0x138>
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
  1821d0:	e588983a 	sll	r4,fp,r22
  1821d4:	25c8703a 	and	r4,r4,r23
  1821d8:	2588d83a 	srl	r4,r4,r22
                        if (digit <= 9)
  1821dc:	19000236 	bltu	r3,r4,1821e8 <alt_printf+0xf4>
                            c = '0' + digit;
  1821e0:	21000c04 	addi	r4,r4,48
  1821e4:	00000106 	br	1821ec <alt_printf+0xf8>
                        else
                            c = 'a' + digit - 10;
  1821e8:	210015c4 	addi	r4,r4,87
                        alt_putchar(c);
  1821ec:	21003fcc 	andi	r4,r4,255
  1821f0:	2100201c 	xori	r4,r4,128
  1821f4:	213fe004 	addi	r4,r4,-128
  1821f8:	d8c00015 	stw	r3,0(sp)
  1821fc:	01822640 	call	182264 <alt_putchar>
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
  182200:	b5bfff04 	addi	r22,r22,-4
  182204:	d8c00017 	ldw	r3,0(sp)
  182208:	003ff006 	br	1821cc <alt_printf+0xd8>
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
  18220c:	1500071e 	bne	r2,r20,18222c <alt_printf+0x138>
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);
  182210:	ad800017 	ldw	r22,0(r21)
  182214:	ad400104 	addi	r21,r21,4

                    while(*s)
  182218:	b1000007 	ldb	r4,0(r22)
  18221c:	20000326 	beq	r4,zero,18222c <alt_printf+0x138>
                      alt_putchar(*s++);
  182220:	b5800044 	addi	r22,r22,1
  182224:	01822640 	call	182264 <alt_putchar>
  182228:	003ffb06 	br	182218 <alt_printf+0x124>
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
                } 
                else if (c == 'c')
                {
                    int v = va_arg(args, int);
  18222c:	8805883a 	mov	r2,r17
  182230:	003fc406 	br	182144 <alt_printf+0x50>
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
  182234:	dfc00a17 	ldw	ra,40(sp)
  182238:	df000917 	ldw	fp,36(sp)
  18223c:	ddc00817 	ldw	r23,32(sp)
  182240:	dd800717 	ldw	r22,28(sp)
  182244:	dd400617 	ldw	r21,24(sp)
  182248:	dd000517 	ldw	r20,20(sp)
  18224c:	dcc00417 	ldw	r19,16(sp)
  182250:	dc800317 	ldw	r18,12(sp)
  182254:	dc400217 	ldw	r17,8(sp)
  182258:	dc000117 	ldw	r16,4(sp)
  18225c:	dec00e04 	addi	sp,sp,56
  182260:	f800283a 	ret

00182264 <alt_putchar>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
  182264:	defffd04 	addi	sp,sp,-12
  182268:	dc000115 	stw	r16,4(sp)
	char        c1 = (char)(c & 0xff);
    return write(STDOUT_FILENO,&c1,1);
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    char        c1 = (char)(c & 0xff);
  18226c:	d9000005 	stb	r4,0(sp)
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
  182270:	2021883a 	mov	r16,r4
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    char        c1 = (char)(c & 0xff);

    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
  182274:	01000634 	movhi	r4,24
  182278:	000f883a 	mov	r7,zero
  18227c:	01800044 	movi	r6,1
  182280:	d80b883a 	mov	r5,sp
  182284:	210e1f04 	addi	r4,r4,14460
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
  182288:	dfc00215 	stw	ra,8(sp)
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    char        c1 = (char)(c & 0xff);

    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
  18228c:	01823680 	call	182368 <altera_avalon_jtag_uart_write>
  182290:	00ffffc4 	movi	r3,-1
  182294:	10c00126 	beq	r2,r3,18229c <alt_putchar+0x38>
        return -1;
    }
    return c;
  182298:	8005883a 	mov	r2,r16
#else
    return putchar(c);
#endif
#endif
}
  18229c:	dfc00217 	ldw	ra,8(sp)
  1822a0:	dc000117 	ldw	r16,4(sp)
  1822a4:	dec00304 	addi	sp,sp,12
  1822a8:	f800283a 	ret

001822ac <usleep>:
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
  return alt_busy_sleep(us);
  1822ac:	01829601 	jmpi	182960 <alt_busy_sleep>

001822b0 <write>:
#if !defined(ALT_STDOUT_PRESENT) && !defined(ALT_STDERR_PRESENT)
    /* Generate a link time warning, should this function ever be called. */
    ALT_STUB_WARNING(write);
#endif

    switch (file) {
  1822b0:	00800044 	movi	r2,1
  1822b4:	20800226 	beq	r4,r2,1822c0 <write+0x10>
  1822b8:	00800084 	movi	r2,2
  1822bc:	2080041e 	bne	r4,r2,1822d0 <write+0x20>
    case 1: /* stdout file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, ptr, len, 0);
#endif /* ALT_STDOUT_PRESENT */
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
  1822c0:	01000634 	movhi	r4,24
  1822c4:	000f883a 	mov	r7,zero
  1822c8:	210e1f04 	addi	r4,r4,14460
  1822cc:	01823681 	jmpi	182368 <altera_avalon_jtag_uart_write>

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  return ((alt_errno) ? alt_errno() : &errno);
  1822d0:	d0a00517 	ldw	r2,-32748(gp)
  1822d4:	10000926 	beq	r2,zero,1822fc <write+0x4c>
 * Provide minimal version that just writes to the stdout/stderr devices
 * when provided.
 */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
  1822d8:	deffff04 	addi	sp,sp,-4
  1822dc:	dfc00015 	stw	ra,0(sp)
  1822e0:	103ee83a 	callr	r2
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
#endif /* ALT_STDERR_PRESENT */
    default:
        ALT_ERRNO = EBADFD;
  1822e4:	00c01444 	movi	r3,81
  1822e8:	10c00015 	stw	r3,0(r2)
        return -1;
    }
}
  1822ec:	00bfffc4 	movi	r2,-1
  1822f0:	dfc00017 	ldw	ra,0(sp)
  1822f4:	dec00104 	addi	sp,sp,4
  1822f8:	f800283a 	ret
  1822fc:	d0a23b04 	addi	r2,gp,-30484
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
#endif /* ALT_STDERR_PRESENT */
    default:
        ALT_ERRNO = EBADFD;
  182300:	00c01444 	movi	r3,81
  182304:	10c00015 	stw	r3,0(r2)
        return -1;
    }
}
  182308:	00bfffc4 	movi	r2,-1
  18230c:	f800283a 	ret

00182310 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
  182310:	deffff04 	addi	sp,sp,-4
  182314:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2, nios2);
  182318:	0182bc80 	call	182bc8 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
  18231c:	00800044 	movi	r2,1
  182320:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
  182324:	dfc00017 	ldw	ra,0(sp)
  182328:	dec00104 	addi	sp,sp,4
  18232c:	f800283a 	ret

00182330 <alt_sys_init>:
 */

void alt_sys_init( void )
{
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_RX, sgdma_rx);
  182330:	01000634 	movhi	r4,24
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
  182334:	deffff04 	addi	sp,sp,-4
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_RX, sgdma_rx);
  182338:	000d883a 	mov	r6,zero
  18233c:	000b883a 	mov	r5,zero
  182340:	210e1104 	addi	r4,r4,14404
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
  182344:	dfc00015 	stw	ra,0(sp)
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_RX, sgdma_rx);
  182348:	01828dc0 	call	1828dc <alt_avalon_sgdma_init>
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_TX, sgdma_tx);
  18234c:	01000634 	movhi	r4,24
  182350:	01800044 	movi	r6,1
  182354:	000b883a 	mov	r5,zero
  182358:	210e0504 	addi	r4,r4,14356
    ALTERA_ETH_TSE_INIT ( ETH_TSE, eth_tse);
}
  18235c:	dfc00017 	ldw	ra,0(sp)
  182360:	dec00104 	addi	sp,sp,4

void alt_sys_init( void )
{
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_RX, sgdma_rx);
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_TX, sgdma_tx);
  182364:	01828dc1 	jmpi	1828dc <alt_avalon_sgdma_init>

00182368 <altera_avalon_jtag_uart_write>:
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  unsigned int base = sp->base;
  182368:	21000017 	ldw	r4,0(r4)
 * one FIFOs worth of data.  But you said you didn't want to use interrupts :-)
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  18236c:	3005883a 	mov	r2,r6
  unsigned int base = sp->base;

  const char * end = ptr + count;
  182370:	298d883a 	add	r6,r5,r6

  while (ptr < end)
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
  182374:	21c00104 	addi	r7,r4,4
{
  unsigned int base = sp->base;

  const char * end = ptr + count;

  while (ptr < end)
  182378:	2980072e 	bgeu	r5,r6,182398 <altera_avalon_jtag_uart_write+0x30>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
  18237c:	38c00037 	ldwio	r3,0(r7)
  182380:	18ffffec 	andhi	r3,r3,65535
  182384:	183ffc26 	beq	r3,zero,182378 <altera_avalon_jtag_uart_write+0x10>
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);
  182388:	28c00007 	ldb	r3,0(r5)
  18238c:	20c00035 	stwio	r3,0(r4)
  182390:	29400044 	addi	r5,r5,1
  182394:	003ff806 	br	182378 <altera_avalon_jtag_uart_write+0x10>

  return count;
}
  182398:	f800283a 	ret

0018239c <alt_avalon_sgdma_irq>:
   * Note: This is explicitly done before calling user interrupt-handling
   * code rather than after; if user ISR code initiates another SGDMA
   * transfer which completes quickly, reading the control register after
   * the callback routine may result in a lost interrupt.
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
  18239c:	20800317 	ldw	r2,12(r4)
  1823a0:	10800404 	addi	r2,r2,16
  1823a4:	10c00037 	ldwio	r3,0(r2)
  1823a8:	18e00034 	orhi	r3,r3,32768
  1823ac:	10c00035 	stwio	r3,0(r2)
    IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) | 0x80000000);
  
  /* Dummy read to ensure IRQ is negated before the ISR returns */
  IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  1823b0:	20800317 	ldw	r2,12(r4)
  1823b4:	10800437 	ldwio	r2,16(r2)
   * Other interrupts are explicitly disabled if callbacks
   * are registered because there is no guarantee that they are 
   * preemption-safe. This allows the driver to support 
   * interrupt preemption.
   */
  if(dev->callback) {
  1823b8:	20c00917 	ldw	r3,36(r4)
  1823bc:	18000d26 	beq	r3,zero,1823f4 <alt_avalon_sgdma_irq+0x58>
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_sgdma_irq(void *context)
#else
static void alt_avalon_sgdma_irq(void *context, alt_u32 id)
#endif
{
  1823c0:	defffe04 	addi	sp,sp,-8
  1823c4:	dfc00115 	stw	ra,4(sp)
  1823c8:	dc000015 	stw	r16,0(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  1823cc:	0021303a 	rdctl	r16,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  1823d0:	00bfff84 	movi	r2,-2
  1823d4:	8084703a 	and	r2,r16,r2
  1823d8:	1001703a 	wrctl	status,r2
   * preemption-safe. This allows the driver to support 
   * interrupt preemption.
   */
  if(dev->callback) {
    cpu_sr = alt_irq_disable_all();
    (dev->callback)(dev->callback_context);
  1823dc:	21000a17 	ldw	r4,40(r4)
  1823e0:	183ee83a 	callr	r3
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  1823e4:	8001703a 	wrctl	status,r16
    alt_irq_enable_all(cpu_sr);
  }
}
  1823e8:	dfc00117 	ldw	ra,4(sp)
  1823ec:	dc000017 	ldw	r16,0(sp)
  1823f0:	dec00204 	addi	sp,sp,8
  1823f4:	f800283a 	ret

001823f8 <alt_avalon_sgdma_do_async_transfer>:
  alt_sgdma_descriptor *desc)
{
  alt_u32 control;

  /* Return with error immediately if controller is busy */
  if( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
  1823f8:	20c00317 	ldw	r3,12(r4)
  1823fc:	18800037 	ldwio	r2,0(r3)
  182400:	1080040c 	andi	r2,r2,16
  182404:	1000191e 	bne	r2,zero,18246c <alt_avalon_sgdma_do_async_transfer+0x74>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    return -EBUSY;
  }

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
  182408:	18c00404 	addi	r3,r3,16
  18240c:	19c00037 	ldwio	r7,0(r3)
  182410:	01bff7c4 	movi	r6,-33
  182414:	398c703a 	and	r6,r7,r6
  182418:	19800035 	stwio	r6,0(r3)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
  18241c:	20c00317 	ldw	r3,12(r4)
  182420:	01803fc4 	movi	r6,255
  182424:	19800035 	stwio	r6,0(r3)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
  182428:	20c00317 	ldw	r3,12(r4)
  18242c:	19400835 	stwio	r5,32(r3)
  182430:	20c00317 	ldw	r3,12(r4)
   *  - Stop on an error with any particular descriptor
   *  - Include any control register bits registered with along with
   *    the callback routine (effectively, interrupts are controlled
   *    via the control bits set during callback-register time).
   */
  if(dev->callback) {
  182434:	21400917 	ldw	r5,36(r4)
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  182438:	18c00404 	addi	r3,r3,16
   *  - Stop on an error with any particular descriptor
   *  - Include any control register bits registered with along with
   *    the callback routine (effectively, interrupts are controlled
   *    via the control bits set during callback-register time).
   */
  if(dev->callback) {
  18243c:	28000526 	beq	r5,zero,182454 <alt_avalon_sgdma_do_async_transfer+0x5c>
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  182440:	19400037 	ldwio	r5,0(r3)

    control |= (dev->chain_control                          |
                ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK  );

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
  182444:	21000b17 	ldw	r4,44(r4)
  182448:	21001814 	ori	r4,r4,96
  18244c:	2148b03a 	or	r4,r4,r5
  182450:	00000406 	br	182464 <alt_avalon_sgdma_do_async_transfer+0x6c>
   *   - Run
   *   - Stop on an error with any particular descriptor
   *   - Disable interrupt generation
   */
  else {
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  182454:	19400037 	ldwio	r5,0(r3)
  182458:	013ffbc4 	movi	r4,-17
  18245c:	2908703a 	and	r4,r5,r4

    control |= (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK );
    control &= ~ALTERA_AVALON_SGDMA_CONTROL_IE_GLOBAL_MSK;

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
  182460:	21001814 	ori	r4,r4,96
  182464:	19000035 	stwio	r4,0(r3)
  182468:	f800283a 	ret
  alt_u32 control;

  /* Return with error immediately if controller is busy */
  if( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    return -EBUSY;
  18246c:	00bffc04 	movi	r2,-16
  /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
  return 0;
}
  182470:	f800283a 	ret

00182474 <alt_avalon_sgdma_do_sync_transfer>:
  alt_sgdma_descriptor *desc)
{
  alt_u8 status;

  /* Wait for any pending transfers to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
  182474:	20c00317 	ldw	r3,12(r4)
  182478:	18800037 	ldwio	r2,0(r3)
  18247c:	1080040c 	andi	r2,r2,16
  182480:	103ffc1e 	bne	r2,zero,182474 <alt_avalon_sgdma_do_sync_transfer>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );


  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
  182484:	18c00404 	addi	r3,r3,16
  182488:	19800037 	ldwio	r6,0(r3)
  18248c:	00bff7c4 	movi	r2,-33
  182490:	308c703a 	and	r6,r6,r2
  182494:	19800035 	stwio	r6,0(r3)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
  182498:	20c00317 	ldw	r3,12(r4)
  18249c:	01803fc4 	movi	r6,255
  1824a0:	19800035 	stwio	r6,0(r3)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
  1824a4:	20c00317 	ldw	r3,12(r4)
  1824a8:	19400835 	stwio	r5,32(r3)
   * Set up SGDMA controller to:
   * - Disable interrupt generation
   * - Run once a valid descriptor is written to controller
   * - Stop on an error with any particular descriptor
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
  1824ac:	20c00317 	ldw	r3,12(r4)
  1824b0:	18c00404 	addi	r3,r3,16
  1824b4:	19400037 	ldwio	r5,0(r3)
  1824b8:	29401814 	ori	r5,r5,96
  1824bc:	19400035 	stwio	r5,0(r3)
    (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK |
     ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK | 
     IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base)) );

  /* Wait for the descriptor (chain) to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
  1824c0:	20c00317 	ldw	r3,12(r4)
  1824c4:	19400037 	ldwio	r5,0(r3)
  1824c8:	2940040c 	andi	r5,r5,16
  1824cc:	283ffc1e 	bne	r5,zero,1824c0 <alt_avalon_sgdma_do_sync_transfer+0x4c>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
  1824d0:	18c00404 	addi	r3,r3,16
  1824d4:	19400037 	ldwio	r5,0(r3)
  1824d8:	2884703a 	and	r2,r5,r2
  1824dc:	18800035 	stwio	r2,0(r3)
    (IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) &
     ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK) );

  /* Get & clear status register contents */
  status = IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base);
  1824e0:	20c00317 	ldw	r3,12(r4)
  1824e4:	18800037 	ldwio	r2,0(r3)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
  1824e8:	01003fc4 	movi	r4,255
  1824ec:	19000035 	stwio	r4,0(r3)

  return status;
}
  1824f0:	f800283a 	ret

001824f4 <alt_avalon_sgdma_register_callback>:
  alt_sgdma_dev *dev,
  alt_avalon_sgdma_callback callback,
  alt_u32 chain_control,
  void *context)
{
  dev->callback         = callback;
  1824f4:	21400915 	stw	r5,36(r4)
  dev->callback_context = context;
  1824f8:	21c00a15 	stw	r7,40(r4)
  dev->chain_control    = chain_control;
  1824fc:	21800b15 	stw	r6,44(r4)
  182500:	f800283a 	ret

00182504 <alt_avalon_sgdma_start>:
 */
void alt_avalon_sgdma_start(alt_sgdma_dev *dev)
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  182504:	20800317 	ldw	r2,12(r4)
  182508:	10800404 	addi	r2,r2,16
  18250c:	10c00037 	ldwio	r3,0(r2)
  control |= ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
  182510:	18c00814 	ori	r3,r3,32
  182514:	10c00035 	stwio	r3,0(r2)
  182518:	f800283a 	ret

0018251c <alt_avalon_sgdma_stop>:
 */
void alt_avalon_sgdma_stop(alt_sgdma_dev *dev)
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  18251c:	20800317 	ldw	r2,12(r4)
  182520:	10800404 	addi	r2,r2,16
  182524:	11000037 	ldwio	r4,0(r2)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
  182528:	00fff7c4 	movi	r3,-33
  18252c:	20c6703a 	and	r3,r4,r3
  182530:	10c00035 	stwio	r3,0(r2)
  182534:	f800283a 	ret

00182538 <alt_avalon_sgdma_check_descriptor_status>:
 *   normally. Or, various error conditions defined in <errno.h>
 */
int alt_avalon_sgdma_check_descriptor_status(alt_sgdma_descriptor *desc)
{
  /* Errors take precedence */
  if( IORD_8DIRECT(&desc->status, 0) &
  182538:	208007a3 	ldbuio	r2,30(r4)
  18253c:	10801fcc 	andi	r2,r2,127
  182540:	1000041e 	bne	r2,zero,182554 <alt_avalon_sgdma_check_descriptor_status+0x1c>
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) {
    return -EIO;
  }

  if( IORD_8DIRECT(&desc->control, 0) &
  182544:	208007e3 	ldbuio	r2,31(r4)
  182548:	1080200c 	andi	r2,r2,128
  18254c:	1000031e 	bne	r2,zero,18255c <alt_avalon_sgdma_check_descriptor_status+0x24>
  182550:	f800283a 	ret
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_OVERFLOW_MSK |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) {
    return -EIO;
  182554:	00bffec4 	movi	r2,-5
  182558:	f800283a 	ret
  }

  if( IORD_8DIRECT(&desc->control, 0) &
      ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK) {
    return -EINPROGRESS;
  18255c:	00bfe244 	movi	r2,-119
  }

    return 0;
}
  182560:	f800283a 	ret

00182564 <alt_avalon_sgdma_open>:
 * Returns:
 * - Pointer to SGDMA device instance struct, or null if the device
 *   could not be opened.
 */
alt_sgdma_dev* alt_avalon_sgdma_open (const char* name)
{
  182564:	defffe04 	addi	sp,sp,-8
  alt_sgdma_dev* dev;

  dev = (alt_sgdma_dev*) alt_find_dev (name, &alt_sgdma_list);
  182568:	d1600304 	addi	r5,gp,-32756
 * Returns:
 * - Pointer to SGDMA device instance struct, or null if the device
 *   could not be opened.
 */
alt_sgdma_dev* alt_avalon_sgdma_open (const char* name)
{
  18256c:	dc000015 	stw	r16,0(sp)
  182570:	dfc00115 	stw	ra,4(sp)
  alt_sgdma_dev* dev;

  dev = (alt_sgdma_dev*) alt_find_dev (name, &alt_sgdma_list);
  182574:	0182a5c0 	call	182a5c <alt_find_dev>
  182578:	1021883a 	mov	r16,r2

  if (NULL == dev) {
  18257c:	1000071e 	bne	r2,zero,18259c <alt_avalon_sgdma_open+0x38>
  182580:	d0a00517 	ldw	r2,-32748(gp)
  182584:	10000226 	beq	r2,zero,182590 <alt_avalon_sgdma_open+0x2c>
  182588:	103ee83a 	callr	r2
  18258c:	00000106 	br	182594 <alt_avalon_sgdma_open+0x30>
  182590:	d0a23b04 	addi	r2,gp,-30484
    ALT_ERRNO = ENODEV;
  182594:	00c004c4 	movi	r3,19
  182598:	10c00015 	stw	r3,0(r2)
  }

  return dev;
}
  18259c:	8005883a 	mov	r2,r16
  1825a0:	dfc00117 	ldw	ra,4(sp)
  1825a4:	dc000017 	ldw	r16,0(sp)
  1825a8:	dec00204 	addi	sp,sp,8
  1825ac:	f800283a 	ret

001825b0 <alt_avalon_sgdma_enable_desc_poll>:
 */
void alt_avalon_sgdma_enable_desc_poll(alt_sgdma_dev *dev, alt_u32 frequency)
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  1825b0:	20c00317 	ldw	r3,12(r4)
  1825b4:	18c00404 	addi	r3,r3,16
  1825b8:	19000037 	ldwio	r4,0(r3)
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
  1825bc:	00a00434 	movhi	r2,32784
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
            ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
  1825c0:	280a953a 	slli	r5,r5,20
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
  1825c4:	10bfffc4 	addi	r2,r2,-1
  1825c8:	2084703a 	and	r2,r4,r2
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
            ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
  1825cc:	295ffc2c 	andhi	r5,r5,32752
  1825d0:	29400134 	orhi	r5,r5,4
  1825d4:	288ab03a 	or	r5,r5,r2
  1825d8:	19400035 	stwio	r5,0(r3)
  1825dc:	f800283a 	ret

001825e0 <alt_avalon_sgdma_disable_desc_poll>:
 */
void alt_avalon_sgdma_disable_desc_poll(alt_sgdma_dev *dev)
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  1825e0:	20800317 	ldw	r2,12(r4)
  1825e4:	10800404 	addi	r2,r2,16
  1825e8:	11000037 	ldwio	r4,0(r2)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK;

  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
  1825ec:	00ffff34 	movhi	r3,65532
  1825f0:	18ffffc4 	addi	r3,r3,-1
  1825f4:	20c6703a 	and	r3,r4,r3
  1825f8:	10c00035 	stwio	r3,0(r2)
  1825fc:	f800283a 	ret

00182600 <alt_avalon_sgdma_construct_descriptor_burst>:
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
  182600:	288007c3 	ldbu	r2,31(r5)
  int                   read_fixed,
  int                   write_fixed_or_sop,
  int                   read_burst,
  int                   write_burst,
  alt_u8                atlantic_channel)
{
  182604:	d8c00617 	ldw	r3,24(sp)
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
  182608:	10801fcc 	andi	r2,r2,127
  18260c:	288007e5 	stbio	r2,31(r5)
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  182610:	3004d23a 	srli	r2,r6,8
  182614:	21800005 	stb	r6,0(r4)
  desc->write_addr               = write_addr;
  182618:	21c00205 	stb	r7,8(r4)
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  18261c:	20800045 	stb	r2,1(r4)
  182620:	3004d43a 	srli	r2,r6,16
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  182624:	21400405 	stb	r5,16(r4)
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  182628:	300cd63a 	srli	r6,r6,24
  18262c:	20800085 	stb	r2,2(r4)
  desc->write_addr               = write_addr;
  182630:	3804d23a 	srli	r2,r7,8
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  182634:	218000c5 	stb	r6,3(r4)
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
  182638:	20000105 	stb	zero,4(r4)
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  18263c:	20800245 	stb	r2,9(r4)
  182640:	3804d43a 	srli	r2,r7,16
  182644:	380ed63a 	srli	r7,r7,24
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
  182648:	20000145 	stb	zero,5(r4)
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  18264c:	20800285 	stb	r2,10(r4)
  desc->next                     = (alt_u32 *) next;
  182650:	2804d23a 	srli	r2,r5,8
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  182654:	21c002c5 	stb	r7,11(r4)
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
  182658:	20000185 	stb	zero,6(r4)
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  18265c:	20800445 	stb	r2,17(r4)
  182660:	2804d43a 	srli	r2,r5,16
  182664:	280ad63a 	srli	r5,r5,24
  desc->read_addr_pad            = 0x0;
  182668:	200001c5 	stb	zero,7(r4)
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  18266c:	20800485 	stb	r2,18(r4)
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
  desc->next_pad                 = 0x0;
  desc->bytes_to_transfer        = length_or_eop;
  182670:	d880000b 	ldhu	r2,0(sp)
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  182674:	214004c5 	stb	r5,19(r4)
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
  182678:	20000305 	stb	zero,12(r4)
  desc->next_pad                 = 0x0;
  desc->bytes_to_transfer        = length_or_eop;
  18267c:	20800605 	stb	r2,24(r4)
  182680:	1004d23a 	srli	r2,r2,8

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
  182684:	20000345 	stb	zero,13(r4)
  182688:	20000385 	stb	zero,14(r4)
  desc->next_pad                 = 0x0;
  desc->bytes_to_transfer        = length_or_eop;
  18268c:	20800645 	stb	r2,25(r4)
  desc->actual_bytes_transferred = 0;
  desc->status                   = 0x0;

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
  182690:	d8800417 	ldw	r2,16(sp)

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
  182694:	200003c5 	stb	zero,15(r4)
  desc->next_pad                 = 0x0;
  182698:	20000505 	stb	zero,20(r4)
  18269c:	20000545 	stb	zero,21(r4)
  1826a0:	20000585 	stb	zero,22(r4)
  1826a4:	200005c5 	stb	zero,23(r4)
  desc->bytes_to_transfer        = length_or_eop;
  desc->actual_bytes_transferred = 0;
  1826a8:	20000705 	stb	zero,28(r4)
  1826ac:	20000745 	stb	zero,29(r4)
  desc->status                   = 0x0;
  1826b0:	20000785 	stb	zero,30(r4)

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
  1826b4:	20800685 	stb	r2,26(r4)
  desc->write_burst              = write_burst;
  1826b8:	d8800517 	ldw	r2,20(sp)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
  1826bc:	d9400117 	ldw	r5,4(sp)
  desc->actual_bytes_transferred = 0;
  desc->status                   = 0x0;

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
  desc->write_burst              = write_burst;
  1826c0:	208006c5 	stb	r2,27(r4)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
  1826c4:	d8800217 	ldw	r2,8(sp)
  1826c8:	280ac03a 	cmpne	r5,r5,zero
  1826cc:	297fe004 	addi	r5,r5,-128
  1826d0:	1004c03a 	cmpne	r2,r2,zero
  1826d4:	1004907a 	slli	r2,r2,1
  1826d8:	2884b03a 	or	r2,r5,r2
  1826dc:	d9400317 	ldw	r5,12(sp)
  1826e0:	280ac03a 	cmpne	r5,r5,zero
  1826e4:	280a90ba 	slli	r5,r5,2
  1826e8:	114ab03a 	or	r5,r2,r5
  1826ec:	18803fcc 	andi	r2,r3,255
  1826f0:	10000326 	beq	r2,zero,182700 <alt_avalon_sgdma_construct_descriptor_burst+0x100>
  1826f4:	18c003cc 	andi	r3,r3,15
  1826f8:	180490fa 	slli	r2,r3,3
  1826fc:	00000106 	br	182704 <alt_avalon_sgdma_construct_descriptor_burst+0x104>
  182700:	0005883a 	mov	r2,zero
  182704:	2884b03a 	or	r2,r5,r2
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to.
   */
  alt_dcache_flush(desc, sizeof(alt_sgdma_descriptor));
  182708:	01400804 	movi	r5,32
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
  18270c:	208007c5 	stb	r2,31(r4)
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to.
   */
  alt_dcache_flush(desc, sizeof(alt_sgdma_descriptor));
  182710:	01829e81 	jmpi	1829e8 <alt_dcache_flush>

00182714 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>:
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed,
  int                   read_burst,
  int                   write_burst)
{
  182714:	defff804 	addi	sp,sp,-32
  alt_avalon_sgdma_construct_descriptor_burst(
  182718:	d8800c17 	ldw	r2,48(sp)
  18271c:	d8000615 	stw	zero,24(sp)
  182720:	d8000115 	stw	zero,4(sp)
  182724:	d8800515 	stw	r2,20(sp)
  182728:	d8800b17 	ldw	r2,44(sp)
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed,
  int                   read_burst,
  int                   write_burst)
{
  18272c:	dfc00715 	stw	ra,28(sp)
  alt_avalon_sgdma_construct_descriptor_burst(
  182730:	d8800415 	stw	r2,16(sp)
  182734:	d8800a17 	ldw	r2,40(sp)
  182738:	d8800315 	stw	r2,12(sp)
  18273c:	d8800917 	ldw	r2,36(sp)
  182740:	d8800215 	stw	r2,8(sp)
  182744:	d880080b 	ldhu	r2,32(sp)
  182748:	d8800015 	stw	r2,0(sp)
  18274c:	01826000 	call	182600 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    write_fixed,
    read_burst,
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in mem-to-mem mode
}
  182750:	dfc00717 	ldw	ra,28(sp)
  182754:	dec00804 	addi	sp,sp,32
  182758:	f800283a 	ret

0018275c <alt_avalon_sgdma_construct_mem_to_mem_desc>:
  alt_u32              *read_addr,
  alt_u32              *write_addr,
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed)
{
  18275c:	defffa04 	addi	sp,sp,-24
  alt_avalon_sgdma_construct_mem_to_mem_desc_burst(desc, next, read_addr, 
  182760:	d8800817 	ldw	r2,32(sp)
  182764:	d8000415 	stw	zero,16(sp)
  182768:	d8000315 	stw	zero,12(sp)
  18276c:	d8800215 	stw	r2,8(sp)
  182770:	d8800717 	ldw	r2,28(sp)
  alt_u32              *read_addr,
  alt_u32              *write_addr,
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed)
{
  182774:	dfc00515 	stw	ra,20(sp)
  alt_avalon_sgdma_construct_mem_to_mem_desc_burst(desc, next, read_addr, 
  182778:	d8800115 	stw	r2,4(sp)
  18277c:	d880060b 	ldhu	r2,24(sp)
  182780:	d8800015 	stw	r2,0(sp)
  182784:	01827140 	call	182714 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>
    write_addr, length, read_fixed, write_fixed, 0, 0);
}
  182788:	dfc00517 	ldw	ra,20(sp)
  18278c:	dec00604 	addi	sp,sp,24
  182790:	f800283a 	ret

00182794 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>:
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed,
  int                   write_burst)
{
  182794:	defff804 	addi	sp,sp,-32
  alt_avalon_sgdma_construct_descriptor_burst(
  182798:	d8800917 	ldw	r2,36(sp)
  18279c:	39ffffcc 	andi	r7,r7,65535
  1827a0:	d9c00015 	stw	r7,0(sp)
  1827a4:	d8800515 	stw	r2,20(sp)
  1827a8:	d8800817 	ldw	r2,32(sp)
  1827ac:	300f883a 	mov	r7,r6
  1827b0:	d8000615 	stw	zero,24(sp)
  1827b4:	d8000415 	stw	zero,16(sp)
  1827b8:	d8800315 	stw	r2,12(sp)
  1827bc:	d8000215 	stw	zero,8(sp)
  1827c0:	d8000115 	stw	zero,4(sp)
  1827c4:	000d883a 	mov	r6,zero
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed,
  int                   write_burst)
{
  1827c8:	dfc00715 	stw	ra,28(sp)
  alt_avalon_sgdma_construct_descriptor_burst(
  1827cc:	01826000 	call	182600 <alt_avalon_sgdma_construct_descriptor_burst>
    0x0,            // Read fixed: N/A in stream-to-mem mode
    write_fixed,
    0,              // Read_burst : N/A in stream-to-mem mode
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in stream-to-mem mode
}
  1827d0:	dfc00717 	ldw	ra,28(sp)
  1827d4:	dec00804 	addi	sp,sp,32
  1827d8:	f800283a 	ret

001827dc <alt_avalon_sgdma_construct_stream_to_mem_desc>:
  alt_sgdma_descriptor *desc,
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed)
{
  1827dc:	defffd04 	addi	sp,sp,-12
  alt_avalon_sgdma_construct_stream_to_mem_desc_burst(desc, next, write_addr, 
  1827e0:	d8800317 	ldw	r2,12(sp)
  1827e4:	d8000115 	stw	zero,4(sp)
  1827e8:	39ffffcc 	andi	r7,r7,65535
  1827ec:	d8800015 	stw	r2,0(sp)
  alt_sgdma_descriptor *desc,
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed)
{
  1827f0:	dfc00215 	stw	ra,8(sp)
  alt_avalon_sgdma_construct_stream_to_mem_desc_burst(desc, next, write_addr, 
  1827f4:	01827940 	call	182794 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>
    length_or_eop, write_fixed, 0);
}
  1827f8:	dfc00217 	ldw	ra,8(sp)
  1827fc:	dec00304 	addi	sp,sp,12
  182800:	f800283a 	ret

00182804 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>:
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  int                   read_burst,
  alt_u8                atlantic_channel)
{
  182804:	defff804 	addi	sp,sp,-32
  alt_avalon_sgdma_construct_descriptor_burst(
  182808:	d8800c03 	ldbu	r2,48(sp)
  18280c:	39ffffcc 	andi	r7,r7,65535
  182810:	d9c00015 	stw	r7,0(sp)
  182814:	d8800615 	stw	r2,24(sp)
  182818:	d8800b17 	ldw	r2,44(sp)
  18281c:	d8000515 	stw	zero,20(sp)
  182820:	000f883a 	mov	r7,zero
  182824:	d8800415 	stw	r2,16(sp)
  182828:	d8800917 	ldw	r2,36(sp)
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  int                   read_burst,
  alt_u8                atlantic_channel)
{
  18282c:	dfc00715 	stw	ra,28(sp)
  alt_avalon_sgdma_construct_descriptor_burst(
  182830:	d8800315 	stw	r2,12(sp)
  182834:	d8800817 	ldw	r2,32(sp)
  182838:	d8800215 	stw	r2,8(sp)
  18283c:	d8800a17 	ldw	r2,40(sp)
  182840:	d8800115 	stw	r2,4(sp)
  182844:	01826000 	call	182600 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    generate_sop,
    read_burst,
    0,                 // Write_burst : N/A in mem-to-stream mode
    atlantic_channel);
}
  182848:	dfc00717 	ldw	ra,28(sp)
  18284c:	dec00804 	addi	sp,sp,32
  182850:	f800283a 	ret

00182854 <alt_avalon_sgdma_construct_mem_to_stream_desc>:
  alt_u16               length,
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  alt_u8                atlantic_channel)
{
  182854:	defffa04 	addi	sp,sp,-24
  alt_avalon_sgdma_construct_mem_to_stream_desc_burst(desc, next, read_addr, 
  182858:	d8800903 	ldbu	r2,36(sp)
  18285c:	d8000315 	stw	zero,12(sp)
  182860:	39ffffcc 	andi	r7,r7,65535
  182864:	d8800415 	stw	r2,16(sp)
  182868:	d8800817 	ldw	r2,32(sp)
  alt_u16               length,
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  alt_u8                atlantic_channel)
{
  18286c:	dfc00515 	stw	ra,20(sp)
  alt_avalon_sgdma_construct_mem_to_stream_desc_burst(desc, next, read_addr, 
  182870:	d8800215 	stw	r2,8(sp)
  182874:	d8800717 	ldw	r2,28(sp)
  182878:	d8800115 	stw	r2,4(sp)
  18287c:	d8800617 	ldw	r2,24(sp)
  182880:	d8800015 	stw	r2,0(sp)
  182884:	01828040 	call	182804 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>
    length, read_fixed, generate_sop, generate_eop, 0, atlantic_channel);

}
  182888:	dfc00517 	ldw	ra,20(sp)
  18288c:	dec00604 	addi	sp,sp,24
  182890:	f800283a 	ret

00182894 <alt_avalon_sgdma_construct_descriptor>:
  alt_u16               length_or_eop,
  int                   generate_eop,
  int                   read_fixed,
  int                   write_fixed_or_sop,
  alt_u8                atlantic_channel)
{
  182894:	defff804 	addi	sp,sp,-32
  alt_avalon_sgdma_construct_descriptor_burst(desc, next, read_addr, 
  182898:	d8800c03 	ldbu	r2,48(sp)
  18289c:	d8000515 	stw	zero,20(sp)
  1828a0:	d8000415 	stw	zero,16(sp)
  1828a4:	d8800615 	stw	r2,24(sp)
  1828a8:	d8800b17 	ldw	r2,44(sp)
  alt_u16               length_or_eop,
  int                   generate_eop,
  int                   read_fixed,
  int                   write_fixed_or_sop,
  alt_u8                atlantic_channel)
{
  1828ac:	dfc00715 	stw	ra,28(sp)
  alt_avalon_sgdma_construct_descriptor_burst(desc, next, read_addr, 
  1828b0:	d8800315 	stw	r2,12(sp)
  1828b4:	d8800a17 	ldw	r2,40(sp)
  1828b8:	d8800215 	stw	r2,8(sp)
  1828bc:	d8800917 	ldw	r2,36(sp)
  1828c0:	d8800115 	stw	r2,4(sp)
  1828c4:	d880080b 	ldhu	r2,32(sp)
  1828c8:	d8800015 	stw	r2,0(sp)
  1828cc:	01826000 	call	182600 <alt_avalon_sgdma_construct_descriptor_burst>
    write_addr, length_or_eop, generate_eop, read_fixed, write_fixed_or_sop, 
    0, 0, atlantic_channel);
}
  1828d0:	dfc00717 	ldw	ra,28(sp)
  1828d4:	dec00804 	addi	sp,sp,32
  1828d8:	f800283a 	ret

001828dc <alt_avalon_sgdma_init>:

  /* 
   * Halt any current transactions (reset the device)
   * SW reset is written twice per SGDMA documentation 
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
  1828dc:	20c00317 	ldw	r3,12(r4)
 * This routine disables interrupts, future descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_avalon_sgdma_init (alt_sgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
  1828e0:	defffb04 	addi	sp,sp,-20
  1828e4:	dc800315 	stw	r18,12(sp)
  1828e8:	dc400215 	stw	r17,8(sp)
  1828ec:	dc000115 	stw	r16,4(sp)
  1828f0:	dfc00415 	stw	ra,16(sp)
  1828f4:	2021883a 	mov	r16,r4
  1828f8:	2823883a 	mov	r17,r5
  1828fc:	3025883a 	mov	r18,r6

  /* 
   * Halt any current transactions (reset the device)
   * SW reset is written twice per SGDMA documentation 
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
  182900:	00800074 	movhi	r2,1
  182904:	18800435 	stwio	r2,16(r3)
    ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
  182908:	20c00317 	ldw	r3,12(r4)
  18290c:	18800435 	stwio	r2,16(r3)

  /*
   * Disable interrupts, halt future descriptor processing,
   * and clear status register content
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 0x0);
  182910:	20800317 	ldw	r2,12(r4)
  182914:	10000435 	stwio	zero,16(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
  182918:	20800317 	ldw	r2,12(r4)
  18291c:	00c03fc4 	movi	r3,255
  182920:	10c00035 	stwio	r3,0(r2)

  /* Register this instance of the SGDMA controller with HAL */
  alt_dev_llist_insert((alt_dev_llist*) dev, &alt_sgdma_list);
  182924:	d1600304 	addi	r5,gp,-32756
  182928:	01829f00 	call	1829f0 <alt_dev_llist_insert>

  /* Install IRQ handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(ic_id, irq, alt_avalon_sgdma_irq, dev, 0x0);
  18292c:	01800634 	movhi	r6,24
  182930:	d8000015 	stw	zero,0(sp)
  182934:	800f883a 	mov	r7,r16
  182938:	3188e704 	addi	r6,r6,9116
  18293c:	900b883a 	mov	r5,r18
  182940:	8809883a 	mov	r4,r17
  182944:	0182ad40 	call	182ad4 <alt_ic_isr_register>
#else
  alt_irq_register(irq, dev, alt_avalon_sgdma_irq);
#endif  
}
  182948:	dfc00417 	ldw	ra,16(sp)
  18294c:	dc800317 	ldw	r18,12(sp)
  182950:	dc400217 	ldw	r17,8(sp)
  182954:	dc000117 	ldw	r16,4(sp)
  182958:	dec00504 	addi	sp,sp,20
  18295c:	f800283a 	ret

00182960 <alt_busy_sleep>:
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
  182960:	014666b4 	movhi	r5,6554
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
  182964:	defffe04 	addi	sp,sp,-8
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
  182968:	29666644 	addi	r5,r5,-26215
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
  18296c:	dc000015 	stw	r16,0(sp)
  182970:	dfc00115 	stw	ra,4(sp)
  182974:	2021883a 	mov	r16,r4
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
  182978:	0182cf80 	call	182cf8 <__udivsi3>
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  18297c:	10001026 	beq	r2,zero,1829c0 <alt_busy_sleep+0x60>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
  182980:	01600034 	movhi	r5,32768
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
  182984:	013999b4 	movhi	r4,58982
  182988:	0007883a 	mov	r3,zero
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
  18298c:	297fffc4 	addi	r5,r5,-1
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
  182990:	211999c4 	addi	r4,r4,26215
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
  182994:	297fffc4 	addi	r5,r5,-1
  182998:	283ffe1e 	bne	r5,zero,182994 <alt_busy_sleep+0x34>
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
  18299c:	18c00044 	addi	r3,r3,1
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
  1829a0:	8121883a 	add	r16,r16,r4
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
  1829a4:	18bffb16 	blt	r3,r2,182994 <alt_busy_sleep+0x34>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
  1829a8:	01400144 	movi	r5,5
  1829ac:	8009883a 	mov	r4,r16
  1829b0:	0181d9c0 	call	181d9c <__mulsi3>
  1829b4:	10bfffc4 	addi	r2,r2,-1
  1829b8:	103ffe1e 	bne	r2,zero,1829b4 <alt_busy_sleep+0x54>
  1829bc:	00000506 	br	1829d4 <alt_busy_sleep+0x74>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
  1829c0:	01400144 	movi	r5,5
  1829c4:	8009883a 	mov	r4,r16
  1829c8:	0181d9c0 	call	181d9c <__mulsi3>
  1829cc:	10bfffc4 	addi	r2,r2,-1
  1829d0:	00bffe16 	blt	zero,r2,1829cc <alt_busy_sleep+0x6c>
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
}
  1829d4:	0005883a 	mov	r2,zero
  1829d8:	dfc00117 	ldw	ra,4(sp)
  1829dc:	dc000017 	ldw	r16,0(sp)
  1829e0:	dec00204 	addi	sp,sp,8
  1829e4:	f800283a 	ret

001829e8 <alt_dcache_flush>:
 *
 * Any dirty lines in the data cache are written back to memory.
 */

void alt_dcache_flush (void* start, alt_u32 len)
{
  1829e8:	f800283a 	ret

001829ec <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
  1829ec:	f800283a 	ret

001829f0 <alt_dev_llist_insert>:
{
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  1829f0:	20000226 	beq	r4,zero,1829fc <alt_dev_llist_insert+0xc>
  1829f4:	20800217 	ldw	r2,8(r4)
  1829f8:	1000101e 	bne	r2,zero,182a3c <alt_dev_llist_insert+0x4c>
  1829fc:	d0a00517 	ldw	r2,-32748(gp)
  182a00:	10000926 	beq	r2,zero,182a28 <alt_dev_llist_insert+0x38>
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
  182a04:	deffff04 	addi	sp,sp,-4
  182a08:	dfc00015 	stw	ra,0(sp)
  182a0c:	103ee83a 	callr	r2
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  {
    ALT_ERRNO = EINVAL;
  182a10:	00c00584 	movi	r3,22
  182a14:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
  182a18:	00bffa84 	movi	r2,-22
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
}
  182a1c:	dfc00017 	ldw	ra,0(sp)
  182a20:	dec00104 	addi	sp,sp,4
  182a24:	f800283a 	ret
  182a28:	d0a23b04 	addi	r2,gp,-30484
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  {
    ALT_ERRNO = EINVAL;
  182a2c:	00c00584 	movi	r3,22
  182a30:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
  182a34:	00bffa84 	movi	r2,-22
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
}
  182a38:	f800283a 	ret

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  entry->next     = list->next;
  182a3c:	28800017 	ldw	r2,0(r5)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  182a40:	21400115 	stw	r5,4(r4)
  entry->next     = list->next;
  182a44:	20800015 	stw	r2,0(r4)

  list->next->previous = entry;
  182a48:	28800017 	ldw	r2,0(r5)
  182a4c:	11000115 	stw	r4,4(r2)
  list->next           = entry;
  182a50:	29000015 	stw	r4,0(r5)
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
  182a54:	0005883a 	mov	r2,zero
  182a58:	f800283a 	ret

00182a5c <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
  182a5c:	defffb04 	addi	sp,sp,-20
  182a60:	dcc00315 	stw	r19,12(sp)
  182a64:	dc800215 	stw	r18,8(sp)
  182a68:	dc400115 	stw	r17,4(sp)
  182a6c:	dc000015 	stw	r16,0(sp)
  182a70:	dfc00415 	stw	ra,16(sp)
  182a74:	2027883a 	mov	r19,r4
  182a78:	2823883a 	mov	r17,r5
  alt_dev* next = (alt_dev*) llist->next;
  182a7c:	2c000017 	ldw	r16,0(r5)
  alt_32 len;

  len  = strlen(name) + 1;
  182a80:	0181e100 	call	181e10 <strlen>
  182a84:	14800044 	addi	r18,r2,1
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
  182a88:	84400726 	beq	r16,r17,182aa8 <alt_find_dev+0x4c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
  182a8c:	81000217 	ldw	r4,8(r16)
  182a90:	900d883a 	mov	r6,r18
  182a94:	980b883a 	mov	r5,r19
  182a98:	0182bd00 	call	182bd0 <memcmp>
  182a9c:	10000426 	beq	r2,zero,182ab0 <alt_find_dev+0x54>
    {
      /* match found */

      return next;
    }
    next = (alt_dev*) next->llist.next;
  182aa0:	84000017 	ldw	r16,0(r16)
  182aa4:	003ff806 	br	182a88 <alt_find_dev+0x2c>
  }
  
  /* No match found */
  
  return NULL;
  182aa8:	0005883a 	mov	r2,zero
  182aac:	00000106 	br	182ab4 <alt_find_dev+0x58>
  182ab0:	8005883a 	mov	r2,r16
}
  182ab4:	dfc00417 	ldw	ra,16(sp)
  182ab8:	dcc00317 	ldw	r19,12(sp)
  182abc:	dc800217 	ldw	r18,8(sp)
  182ac0:	dc400117 	ldw	r17,4(sp)
  182ac4:	dc000017 	ldw	r16,0(sp)
  182ac8:	dec00504 	addi	sp,sp,20
  182acc:	f800283a 	ret

00182ad0 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
  182ad0:	f800283a 	ret

00182ad4 <alt_ic_isr_register>:
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
  182ad4:	0182b601 	jmpi	182b60 <alt_iic_isr_register>

00182ad8 <alt_ic_irq_enable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  182ad8:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  182adc:	00bfff84 	movi	r2,-2
  182ae0:	2084703a 	and	r2,r4,r2
  182ae4:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active |= (1 << id);
  182ae8:	00c00044 	movi	r3,1
  182aec:	d0a23f17 	ldw	r2,-30468(gp)
  182af0:	194a983a 	sll	r5,r3,r5
  182af4:	288ab03a 	or	r5,r5,r2
  182af8:	d1623f15 	stw	r5,-30468(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  182afc:	d0a23f17 	ldw	r2,-30468(gp)
  182b00:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  182b04:	2001703a 	wrctl	status,r4
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_enable(irq);
}
  182b08:	0005883a 	mov	r2,zero
  182b0c:	f800283a 	ret

00182b10 <alt_ic_irq_disable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  182b10:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  182b14:	00bfff84 	movi	r2,-2
  182b18:	2084703a 	and	r2,r4,r2
  182b1c:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active &= ~(1 << id);
  182b20:	00ffff84 	movi	r3,-2
  182b24:	d0a23f17 	ldw	r2,-30468(gp)
  182b28:	194a183a 	rol	r5,r3,r5
  182b2c:	288a703a 	and	r5,r5,r2
  182b30:	d1623f15 	stw	r5,-30468(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  182b34:	d0a23f17 	ldw	r2,-30468(gp)
  182b38:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  182b3c:	2001703a 	wrctl	status,r4
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_disable(irq);
}
  182b40:	0005883a 	mov	r2,zero
  182b44:	f800283a 	ret

00182b48 <alt_ic_irq_enabled>:
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
  182b48:	000730fa 	rdctl	r3,ienable

    return (irq_enabled & (1 << irq)) ? 1: 0;
  182b4c:	00800044 	movi	r2,1
  182b50:	1144983a 	sll	r2,r2,r5
  182b54:	10c4703a 	and	r2,r2,r3
}
  182b58:	1004c03a 	cmpne	r2,r2,zero
  182b5c:	f800283a 	ret

00182b60 <alt_iic_isr_register>:
{
  int rc = -EINVAL;  
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  alt_irq_context status;

  if (id < ALT_NIRQ)
  182b60:	00c007c4 	movi	r3,31
  182b64:	19401616 	blt	r3,r5,182bc0 <alt_iic_isr_register+0x60>
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  182b68:	defffe04 	addi	sp,sp,-8
  182b6c:	dfc00115 	stw	ra,4(sp)
  182b70:	dc000015 	stw	r16,0(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  182b74:	0021303a 	rdctl	r16,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  182b78:	00ffff84 	movi	r3,-2
  182b7c:	80c6703a 	and	r3,r16,r3
  182b80:	1801703a 	wrctl	status,r3
     * state.
     */

    status = alt_irq_disable_all();

    alt_irq[id].handler = isr;
  182b84:	280490fa 	slli	r2,r5,3
  182b88:	00c00634 	movhi	r3,24
  182b8c:	18d19d04 	addi	r3,r3,18036
  182b90:	1885883a 	add	r2,r3,r2
  182b94:	11800015 	stw	r6,0(r2)
    alt_irq[id].context = isr_context;
  182b98:	11c00115 	stw	r7,4(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
  182b9c:	30000226 	beq	r6,zero,182ba8 <alt_iic_isr_register+0x48>
  182ba0:	0182ad80 	call	182ad8 <alt_ic_irq_enable>
  182ba4:	00000106 	br	182bac <alt_iic_isr_register+0x4c>
  182ba8:	0182b100 	call	182b10 <alt_ic_irq_disable>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  182bac:	8001703a 	wrctl	status,r16

    alt_irq_enable_all(status);
  }

  return rc; 
}
  182bb0:	dfc00117 	ldw	ra,4(sp)
  182bb4:	dc000017 	ldw	r16,0(sp)
  182bb8:	dec00204 	addi	sp,sp,8
  182bbc:	f800283a 	ret
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  int rc = -EINVAL;  
  182bc0:	00bffa84 	movi	r2,-22
  182bc4:	f800283a 	ret

00182bc8 <altera_nios2_gen2_irq_init>:
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
  182bc8:	000170fa 	wrctl	ienable,zero
  182bcc:	f800283a 	ret

00182bd0 <memcmp>:
  182bd0:	218d883a 	add	r6,r4,r6
  182bd4:	21800826 	beq	r4,r6,182bf8 <memcmp+0x28>
  182bd8:	20800003 	ldbu	r2,0(r4)
  182bdc:	28c00003 	ldbu	r3,0(r5)
  182be0:	10c00226 	beq	r2,r3,182bec <memcmp+0x1c>
  182be4:	10c5c83a 	sub	r2,r2,r3
  182be8:	f800283a 	ret
  182bec:	21000044 	addi	r4,r4,1
  182bf0:	29400044 	addi	r5,r5,1
  182bf4:	003ff706 	br	182bd4 <memcmp+0x4>
  182bf8:	0005883a 	mov	r2,zero
  182bfc:	f800283a 	ret

00182c00 <__divsi3>:
  182c00:	20001b16 	blt	r4,zero,182c70 <__divsi3+0x70>
  182c04:	000f883a 	mov	r7,zero
  182c08:	28001616 	blt	r5,zero,182c64 <__divsi3+0x64>
  182c0c:	200d883a 	mov	r6,r4
  182c10:	29001a2e 	bgeu	r5,r4,182c7c <__divsi3+0x7c>
  182c14:	00800804 	movi	r2,32
  182c18:	00c00044 	movi	r3,1
  182c1c:	00000106 	br	182c24 <__divsi3+0x24>
  182c20:	10000d26 	beq	r2,zero,182c58 <__divsi3+0x58>
  182c24:	294b883a 	add	r5,r5,r5
  182c28:	10bfffc4 	addi	r2,r2,-1
  182c2c:	18c7883a 	add	r3,r3,r3
  182c30:	293ffb36 	bltu	r5,r4,182c20 <__divsi3+0x20>
  182c34:	0005883a 	mov	r2,zero
  182c38:	18000726 	beq	r3,zero,182c58 <__divsi3+0x58>
  182c3c:	0005883a 	mov	r2,zero
  182c40:	31400236 	bltu	r6,r5,182c4c <__divsi3+0x4c>
  182c44:	314dc83a 	sub	r6,r6,r5
  182c48:	10c4b03a 	or	r2,r2,r3
  182c4c:	1806d07a 	srli	r3,r3,1
  182c50:	280ad07a 	srli	r5,r5,1
  182c54:	183ffa1e 	bne	r3,zero,182c40 <__divsi3+0x40>
  182c58:	38000126 	beq	r7,zero,182c60 <__divsi3+0x60>
  182c5c:	0085c83a 	sub	r2,zero,r2
  182c60:	f800283a 	ret
  182c64:	014bc83a 	sub	r5,zero,r5
  182c68:	39c0005c 	xori	r7,r7,1
  182c6c:	003fe706 	br	182c0c <__divsi3+0xc>
  182c70:	0109c83a 	sub	r4,zero,r4
  182c74:	01c00044 	movi	r7,1
  182c78:	003fe306 	br	182c08 <__divsi3+0x8>
  182c7c:	00c00044 	movi	r3,1
  182c80:	003fee06 	br	182c3c <__divsi3+0x3c>

00182c84 <__modsi3>:
  182c84:	20001716 	blt	r4,zero,182ce4 <__modsi3+0x60>
  182c88:	000f883a 	mov	r7,zero
  182c8c:	2005883a 	mov	r2,r4
  182c90:	28001216 	blt	r5,zero,182cdc <__modsi3+0x58>
  182c94:	2900162e 	bgeu	r5,r4,182cf0 <__modsi3+0x6c>
  182c98:	01800804 	movi	r6,32
  182c9c:	00c00044 	movi	r3,1
  182ca0:	00000106 	br	182ca8 <__modsi3+0x24>
  182ca4:	30000a26 	beq	r6,zero,182cd0 <__modsi3+0x4c>
  182ca8:	294b883a 	add	r5,r5,r5
  182cac:	31bfffc4 	addi	r6,r6,-1
  182cb0:	18c7883a 	add	r3,r3,r3
  182cb4:	293ffb36 	bltu	r5,r4,182ca4 <__modsi3+0x20>
  182cb8:	18000526 	beq	r3,zero,182cd0 <__modsi3+0x4c>
  182cbc:	1806d07a 	srli	r3,r3,1
  182cc0:	11400136 	bltu	r2,r5,182cc8 <__modsi3+0x44>
  182cc4:	1145c83a 	sub	r2,r2,r5
  182cc8:	280ad07a 	srli	r5,r5,1
  182ccc:	183ffb1e 	bne	r3,zero,182cbc <__modsi3+0x38>
  182cd0:	38000126 	beq	r7,zero,182cd8 <__modsi3+0x54>
  182cd4:	0085c83a 	sub	r2,zero,r2
  182cd8:	f800283a 	ret
  182cdc:	014bc83a 	sub	r5,zero,r5
  182ce0:	003fec06 	br	182c94 <__modsi3+0x10>
  182ce4:	0109c83a 	sub	r4,zero,r4
  182ce8:	01c00044 	movi	r7,1
  182cec:	003fe706 	br	182c8c <__modsi3+0x8>
  182cf0:	00c00044 	movi	r3,1
  182cf4:	003ff106 	br	182cbc <__modsi3+0x38>

00182cf8 <__udivsi3>:
  182cf8:	200d883a 	mov	r6,r4
  182cfc:	2900152e 	bgeu	r5,r4,182d54 <__udivsi3+0x5c>
  182d00:	28001416 	blt	r5,zero,182d54 <__udivsi3+0x5c>
  182d04:	00800804 	movi	r2,32
  182d08:	00c00044 	movi	r3,1
  182d0c:	00000206 	br	182d18 <__udivsi3+0x20>
  182d10:	10000e26 	beq	r2,zero,182d4c <__udivsi3+0x54>
  182d14:	28000516 	blt	r5,zero,182d2c <__udivsi3+0x34>
  182d18:	294b883a 	add	r5,r5,r5
  182d1c:	10bfffc4 	addi	r2,r2,-1
  182d20:	18c7883a 	add	r3,r3,r3
  182d24:	293ffa36 	bltu	r5,r4,182d10 <__udivsi3+0x18>
  182d28:	18000826 	beq	r3,zero,182d4c <__udivsi3+0x54>
  182d2c:	0005883a 	mov	r2,zero
  182d30:	31400236 	bltu	r6,r5,182d3c <__udivsi3+0x44>
  182d34:	314dc83a 	sub	r6,r6,r5
  182d38:	10c4b03a 	or	r2,r2,r3
  182d3c:	1806d07a 	srli	r3,r3,1
  182d40:	280ad07a 	srli	r5,r5,1
  182d44:	183ffa1e 	bne	r3,zero,182d30 <__udivsi3+0x38>
  182d48:	f800283a 	ret
  182d4c:	0005883a 	mov	r2,zero
  182d50:	f800283a 	ret
  182d54:	00c00044 	movi	r3,1
  182d58:	003ff406 	br	182d2c <__udivsi3+0x34>

00182d5c <__umodsi3>:
  182d5c:	2005883a 	mov	r2,r4
  182d60:	2900122e 	bgeu	r5,r4,182dac <__umodsi3+0x50>
  182d64:	28001116 	blt	r5,zero,182dac <__umodsi3+0x50>
  182d68:	01800804 	movi	r6,32
  182d6c:	00c00044 	movi	r3,1
  182d70:	00000206 	br	182d7c <__umodsi3+0x20>
  182d74:	30000c26 	beq	r6,zero,182da8 <__umodsi3+0x4c>
  182d78:	28000516 	blt	r5,zero,182d90 <__umodsi3+0x34>
  182d7c:	294b883a 	add	r5,r5,r5
  182d80:	31bfffc4 	addi	r6,r6,-1
  182d84:	18c7883a 	add	r3,r3,r3
  182d88:	293ffa36 	bltu	r5,r4,182d74 <__umodsi3+0x18>
  182d8c:	18000626 	beq	r3,zero,182da8 <__umodsi3+0x4c>
  182d90:	1806d07a 	srli	r3,r3,1
  182d94:	11400136 	bltu	r2,r5,182d9c <__umodsi3+0x40>
  182d98:	1145c83a 	sub	r2,r2,r5
  182d9c:	280ad07a 	srli	r5,r5,1
  182da0:	183ffb1e 	bne	r3,zero,182d90 <__umodsi3+0x34>
  182da4:	f800283a 	ret
  182da8:	f800283a 	ret
  182dac:	00c00044 	movi	r3,1
  182db0:	003ff706 	br	182d90 <__umodsi3+0x34>
