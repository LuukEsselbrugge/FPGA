
barcode.elf:     file format elf32-littlenios2
barcode.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x0018014c

Program Header:
    LOAD off    0x00001000 vaddr 0x00180000 paddr 0x00180000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00180020 paddr 0x00180020 align 2**12
         filesz 0x0000362c memsz 0x0000362c flags r-x
    LOAD off    0x0000464c vaddr 0x0018364c paddr 0x00183f08 align 2**12
         filesz 0x000008bc memsz 0x000008bc flags rw-
    LOAD off    0x000057c4 vaddr 0x001847c4 paddr 0x001847c4 align 2**12
         filesz 0x00000000 memsz 0x00000628 flags rw-
    LOAD off    0x00005000 vaddr 0x00008000 paddr 0x00184dec align 2**12
         filesz 0x00000080 memsz 0x00000080 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00180000  00180000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   0000012c  00180020  00180020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         000032d4  0018014c  0018014c  0000114c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       0000022c  00183420  00183420  00004420  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       000008bc  0018364c  00183f08  0000464c  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00000628  001847c4  001847c4  000057c4  2**2
                  ALLOC, SMALL_DATA
  6 .VideoRAM     00000000  00000000  00000000  00005080  2**0
                  CONTENTS
  7 .descriptor_memory 00000080  00008000  00184dec  00005000  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  8 .onchip_memory 00000000  00184e6c  00184e6c  00005080  2**0
                  CONTENTS
  9 .comment      00000023  00000000  00000000  00005080  2**0
                  CONTENTS, READONLY
 10 .debug_aranges 000005d8  00000000  00000000  000050a8  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   0000804b  00000000  00000000  00005680  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 00002d3c  00000000  00000000  0000d6cb  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0000321e  00000000  00000000  00010407  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00000a88  00000000  00000000  00013628  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00001dad  00000000  00000000  000140b0  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    000055fb  00000000  00000000  00015e5d  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_alt_sim_info 00000040  00000000  00000000  0001b458  2**2
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_ranges 000008a0  00000000  00000000  0001b498  2**3
                  CONTENTS, READONLY, DEBUGGING
 19 .thread_model 00000003  00000000  00000000  0001db1a  2**0
                  CONTENTS, READONLY
 20 .cpu          00000005  00000000  00000000  0001db1d  2**0
                  CONTENTS, READONLY
 21 .qsys         00000001  00000000  00000000  0001db22  2**0
                  CONTENTS, READONLY
 22 .simulation_enabled 00000001  00000000  00000000  0001db23  2**0
                  CONTENTS, READONLY
 23 .stderr_dev   00000009  00000000  00000000  0001db24  2**0
                  CONTENTS, READONLY
 24 .stdin_dev    00000009  00000000  00000000  0001db2d  2**0
                  CONTENTS, READONLY
 25 .stdout_dev   00000009  00000000  00000000  0001db36  2**0
                  CONTENTS, READONLY
 26 .sopc_system_name 00000013  00000000  00000000  0001db3f  2**0
                  CONTENTS, READONLY
 27 .quartus_project_dir 0000001e  00000000  00000000  0001db52  2**0
                  CONTENTS, READONLY
 28 .jdi          0000587f  00000000  00000000  0001db70  2**0
                  CONTENTS, READONLY
 29 .sopcinfo     0008ba38  00000000  00000000  000233ef  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00180000 l    d  .entry	00000000 .entry
00180020 l    d  .exceptions	00000000 .exceptions
0018014c l    d  .text	00000000 .text
00183420 l    d  .rodata	00000000 .rodata
0018364c l    d  .rwdata	00000000 .rwdata
001847c4 l    d  .bss	00000000 .bss
00000000 l    d  .VideoRAM	00000000 .VideoRAM
00008000 l    d  .descriptor_memory	00000000 .descriptor_memory
00184e6c l    d  .onchip_memory	00000000 .onchip_memory
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../barcode_bsp//obj/HAL/src/crt0.o
00180184 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_exception_entry.o
00180094 l       .exceptions	00000000 alt_exception_unknown
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 main.c
00000000 l    df *ABS*	00000000 network.c
00000000 l    df *ABS*	00000000 adddf3.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 fixdfsi.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 lib2-mul.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 putchar.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 vfprintf.c
00181ee4 l     F .text	0000006c print_repeat
00000000 l    df *ABS*	00000000 fvwrite_small_dev.c
00000000 l    df *ABS*	00000000 impure.c
00183dac l     O .rwdata	000000e0 impure_data
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 alt_load.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_printf.c
00000000 l    df *ABS*	00000000 alt_putchar.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
00183ebc l     O .rwdata	00000030 sgdma_rx
00183e8c l     O .rwdata	00000030 sgdma_tx
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_sgdma.c
00182bbc l     F .text	0000005c alt_avalon_sgdma_irq
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_dcache_flush.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 memcmp.c
00181eac g     F .text	0000001c putchar
001828e8 g     F .text	0000002c alt_main
00180784 g     F .text	000000c8 rx_ethernet_isr
00184cec g     O .bss	00000100 alt_irq
00183f08 g       *ABS*	00000000 __flash_rwdata_start
00180240 g     F .text	000002cc showText
00181e58 g     F .text	0000004c printf
00182c94 g     F .text	00000080 alt_avalon_sgdma_do_sync_transfer
00182e20 g     F .text	00000114 alt_avalon_sgdma_construct_descriptor_burst
00183ef4 g     O .rwdata	00000004 jtag_uart
001833e8 g     F .text	00000008 altera_nios2_gen2_irq_init
00180000 g     F .entry	0000000c __reset
00182fb4 g     F .text	00000048 alt_avalon_sgdma_construct_stream_to_mem_desc_burst
00180020 g       *ABS*	00000000 __flash_exceptions_start
001847d8 g     O .bss	00000004 errno
001847e0 g     O .bss	00000004 alt_argv
0018beec g       *ABS*	00000000 _gp
00182acc g     F .text	00000004 usleep
001847ec g     O .bss	00000100 charcode
00000000 g       *ABS*	00000000 __alt_mem_VideoRAM
001847c4 g     O .bss	00000004 actualCount
00181ea4 g     F .text	00000008 _putchar_r
0018327c g     F .text	00000074 alt_find_dev
00181df4 g     F .text	00000028 memcpy
00181c8c g     F .text	000000dc .hidden __floatsidf
00183024 g     F .text	00000050 alt_avalon_sgdma_construct_mem_to_stream_desc_burst
00181e1c g     F .text	0000003c _printf_r
0018274c g     F .text	00000064 .hidden __udivsi3
001801a0 g     F .text	000000a0 drawChars
00182d3c g     F .text	0000001c alt_avalon_sgdma_stop
00183208 g     F .text	00000004 alt_dcache_flush
00180af4 g     F .text	000008ac .hidden __adddf3
00183eec g     O .rwdata	00000004 _global_impure_ptr
00184dec g       *ABS*	00000000 __bss_end
00183380 g     F .text	00000068 alt_iic_isr_register
00182c18 g     F .text	0000007c alt_avalon_sgdma_do_async_transfer
00008000 g     O .descriptor_memory	00000020 rx_descriptor_end
00183368 g     F .text	00000018 alt_ic_irq_enabled
00008000 g       *ABS*	00000000 __alt_mem_descriptor_memory
001847e8 g     O .bss	00000004 alt_irq_active
001839ac g     O .rwdata	00000400 tx_frame
001800ec g     F .exceptions	00000060 alt_irq_handler
00182d58 g     F .text	0000002c alt_avalon_sgdma_check_descriptor_status
0018320c g     F .text	00000004 alt_dcache_flush_all
00181c0c g     F .text	00000080 .hidden __fixdfsi
00008020 g     O .descriptor_memory	00000020 rx_descriptor
00183f08 g       *ABS*	00000000 __ram_rwdata_end
00180000 g       *ABS*	00000000 __alt_mem_onchip_memory
0018364c g     O .rwdata	00000360 charTemplate
00182ad0 g     F .text	00000060 write
00182dd0 g     F .text	00000030 alt_avalon_sgdma_enable_desc_poll
001825a4 g     F .text	00000058 _putc_r
0018364c g       *ABS*	00000000 __ram_rodata_end
001827b0 g     F .text	00000058 .hidden __umodsi3
00183074 g     F .text	00000040 alt_avalon_sgdma_construct_mem_to_stream_desc
00182d14 g     F .text	00000010 alt_avalon_sgdma_register_callback
001847c8 g     O .bss	00000004 barwidth
00184e6c g       *ABS*	00000000 end
001cb000 g       *ABS*	00000000 __alt_stack_pointer
00182e00 g     F .text	00000020 alt_avalon_sgdma_disable_desc_poll
00181d68 g     F .text	00000064 .hidden __clzsi2
00182b88 g     F .text	00000034 altera_avalon_jtag_uart_write
00182f7c g     F .text	00000038 alt_avalon_sgdma_construct_mem_to_mem_desc
00181f50 g     F .text	0000052c ___vfprintf_internal_r
00182ffc g     F .text	00000028 alt_avalon_sgdma_construct_stream_to_mem_desc
00182914 g     F .text	00000170 alt_printf
001809c0 g     F .text	00000004 refresh_ethernet
0018014c g     F .text	0000003c _start
001847cc g     O .bss	00000004 sgdma_tx_dev
00182d84 g     F .text	0000004c alt_avalon_sgdma_open
001847d0 g     O .bss	00000004 text_length
00182b50 g     F .text	00000038 alt_sys_init
00181dcc g     F .text	00000028 .hidden __mulsi3
0018364c g       *ABS*	00000000 __ram_rwdata_start
00183420 g       *ABS*	00000000 __ram_rodata_start
0018050c g     F .text	00000210 scanBarcode
00183180 g     F .text	00000088 alt_busy_sleep
001833f0 g     F .text	00000030 memcmp
00184e6c g       *ABS*	00000000 __alt_stack_base
001813a0 g     F .text	0000086c .hidden __muldf3
00183210 g     F .text	0000006c alt_dev_llist_insert
00182d24 g     F .text	00000018 alt_avalon_sgdma_start
00182498 g     F .text	000000b8 __sfvwrite_small_dev
001847c4 g       *ABS*	00000000 __bss_start
00180750 g     F .text	00000034 main
001847dc g     O .bss	00000004 alt_envp
00183ef8 g     O .rwdata	00000008 alt_sgdma_list
00183f00 g     O .rwdata	00000004 alt_errno
00008060 g     O .descriptor_memory	00000020 tx_descriptor
001848ec g     O .bss	00000400 rx_frame
00182550 g     F .text	00000054 putc
00182654 g     F .text	00000084 .hidden __divsi3
001809d8 g     F .text	00000068 transmit
00183420 g       *ABS*	00000000 __flash_rodata_start
00182b30 g     F .text	00000020 alt_irq_init
0018354c g     O .rodata	00000100 .hidden __clz_tab
001825fc g     F .text	00000058 _write_r
00183ef0 g     O .rwdata	00000004 _impure_ptr
001847e4 g     O .bss	00000004 alt_argc
00180020 g       .exceptions	00000000 alt_irq_entry
001809c4 g     F .text	00000014 tx_char
0018084c g     F .text	00000174 setup
00180020 g       *ABS*	00000000 __ram_exceptions_start
001832f4 g     F .text	00000004 alt_ic_isr_register
00183f08 g       *ABS*	00000000 _edata
00184e6c g       *ABS*	00000000 _end
0018014c g       *ABS*	00000000 __ram_exceptions_end
00180188 g     F .text	00000018 clearText
00180a40 g     F .text	000000b4 tx_ethernet_isr
00183330 g     F .text	00000038 alt_ic_irq_disable
00008040 g     O .descriptor_memory	00000020 tx_descriptor_end
001830b4 g     F .text	00000048 alt_avalon_sgdma_construct_descriptor
001826d8 g     F .text	00000074 .hidden __modsi3
001cb000 g       *ABS*	00000000 __alt_data_end
00180020 g     F .exceptions	00000000 alt_exception
001847d4 g     O .bss	00000004 sgdma_rx_dev
0018071c g     F .text	00000034 callback
0018000c g       .entry	00000000 _exit
00181ec8 g     F .text	0000001c strlen
00182a84 g     F .text	00000048 alt_putchar
001832f0 g     F .text	00000004 alt_icache_flush_all
00183f04 g     O .rwdata	00000004 alt_priority_mask
001832f8 g     F .text	00000038 alt_ic_irq_enable
0018247c g     F .text	0000001c __vfprintf_internal
00182f34 g     F .text	00000048 alt_avalon_sgdma_construct_mem_to_mem_desc_burst
00182808 g     F .text	000000e0 alt_load
001830fc g     F .text	00000084 alt_avalon_sgdma_init



Disassembly of section .entry:

00180000 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
  180000:	00400634 	movhi	at,24
    ori r1, r1, %lo(_start)
  180004:	08405314 	ori	at,at,332
    jmp r1
  180008:	0800683a 	jmp	at

0018000c <_exit>:
	...

Disassembly of section .exceptions:

00180020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
  180020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
  180024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
  180028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
  18002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
  180030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
  180034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
  180038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
  18003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
  180040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
  180044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
  180048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
  18004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
  180050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
  180054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
  180058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
  18005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
  180060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
  180064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
  180068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
  18006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
  180070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
  180074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
  180078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
  18007c:	10000326 	beq	r2,zero,18008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
  180080:	20000226 	beq	r4,zero,18008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
  180084:	01800ec0 	call	1800ec <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
  180088:	00000306 	br	180098 <alt_exception_unknown+0x4>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
  18008c:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
  180090:	e8bfff17 	ldw	r2,-4(ea)

00180094 <alt_exception_unknown>:
#ifdef NIOS2_HAS_DEBUG_STUB
       /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
  180094:	003da03a 	break	0
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
  180098:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
  18009c:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
  1800a0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
  1800a4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
  1800a8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
  1800ac:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
  1800b0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
  1800b4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
  1800b8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
  1800bc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
  1800c0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
  1800c4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
  1800c8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
  1800cc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
  1800d0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
  1800d4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
  1800d8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
  1800dc:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
  1800e0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
  1800e4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
  1800e8:	ef80083a 	eret

001800ec <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
  1800ec:	defffe04 	addi	sp,sp,-8
  1800f0:	dfc00115 	stw	ra,4(sp)
  1800f4:	dc000015 	stw	r16,0(sp)
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
  1800f8:	0009313a 	rdctl	r4,ipending
    do
    {
      if (active & mask)
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
  1800fc:	04000634 	movhi	r16,24
  180100:	84133b04 	addi	r16,r16,19692

  active = alt_irq_pending ();

  do
  {
    i = 0;
  180104:	0005883a 	mov	r2,zero
    mask = 1;
  180108:	00c00044 	movi	r3,1
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
  18010c:	20ca703a 	and	r5,r4,r3
  180110:	28000b26 	beq	r5,zero,180140 <alt_irq_handler+0x54>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
  180114:	100490fa 	slli	r2,r2,3
  180118:	8085883a 	add	r2,r16,r2
  18011c:	10c00017 	ldw	r3,0(r2)
  180120:	11000117 	ldw	r4,4(r2)
  180124:	183ee83a 	callr	r3
  180128:	0009313a 	rdctl	r4,ipending

    } while (1);

    active = alt_irq_pending ();
    
  } while (active);
  18012c:	203ff51e 	bne	r4,zero,180104 <alt_irq_handler+0x18>
  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
}
  180130:	dfc00117 	ldw	ra,4(sp)
  180134:	dc000017 	ldw	r16,0(sp)
  180138:	dec00204 	addi	sp,sp,8
  18013c:	f800283a 	ret
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
  180140:	18c7883a 	add	r3,r3,r3
      i++;
  180144:	10800044 	addi	r2,r2,1

    } while (1);
  180148:	003ff006 	br	18010c <alt_irq_handler+0x20>

Disassembly of section .text:

0018014c <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
  18014c:	06c00734 	movhi	sp,28
    ori sp, sp, %lo(__alt_stack_pointer)
  180150:	deec0014 	ori	sp,sp,45056
    movhi gp, %hi(_gp)
  180154:	06800634 	movhi	gp,24
    ori gp, gp, %lo(_gp)
  180158:	d6afbb14 	ori	gp,gp,48876
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
  18015c:	00800634 	movhi	r2,24
    ori r2, r2, %lo(__bss_start)
  180160:	1091f114 	ori	r2,r2,18372

    movhi r3, %hi(__bss_end)
  180164:	00c00634 	movhi	r3,24
    ori r3, r3, %lo(__bss_end)
  180168:	18d37b14 	ori	r3,r3,19948

    beq r2, r3, 1f
  18016c:	10c00326 	beq	r2,r3,18017c <_start+0x30>

0:
    stw zero, (r2)
  180170:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
  180174:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
  180178:	10fffd36 	bltu	r2,r3,180170 <_start+0x24>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
  18017c:	01828080 	call	182808 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
  180180:	01828e80 	call	1828e8 <alt_main>

00180184 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
  180184:	003fff06 	br	180184 <alt_after_alt_main>

00180188 <clearText>:
			}

	};

	void clearText(){
		for(int x = 0; x < 10000; x+=4){
  180188:	0005883a 	mov	r2,zero
  18018c:	00c9c404 	movi	r3,10000
			IOWR_ALTERA_AVALON_PIO_DATA(x ,(0<<16)| (0<<8) | 0);
  180190:	10000035 	stwio	zero,0(r2)
			}

	};

	void clearText(){
		for(int x = 0; x < 10000; x+=4){
  180194:	10800104 	addi	r2,r2,4
  180198:	10fffd1e 	bne	r2,r3,180190 <clearText+0x8>
			IOWR_ALTERA_AVALON_PIO_DATA(x ,(0<<16)| (0<<8) | 0);
		}
	}
  18019c:	f800283a 	ret

001801a0 <drawChars>:

	void drawChars(int pixels[35][8]){
  1801a0:	defffe04 	addi	sp,sp,-8
  1801a4:	dc000015 	stw	r16,0(sp)
  1801a8:	dfc00115 	stw	ra,4(sp)
  1801ac:	2021883a 	mov	r16,r4
			int totalChars = 35;
			int add = 0;
			int x = 0;
			int linePixelCount = 0;
			clearText();
  1801b0:	01801880 	call	180188 <clearText>
  1801b4:	8009883a 	mov	r4,r16
  1801b8:	82800804 	addi	r10,r16,32
		}
	}

	void drawChars(int pixels[35][8]){
			int totalChars = 35;
			int add = 0;
  1801bc:	000f883a 	mov	r7,zero
			clearText();
			int pixel = 0;
			while(x < 40*totalChars){
				//Draw all chars to video memory used by VGA controller
				for(int currentChar = 0; currentChar < totalChars; currentChar++){
					for(int bit = 4; bit >= 0; bit--){
  1801c0:	02ffffc4 	movi	r11,-1
			int linePixelCount = 0;
			clearText();
			int pixel = 0;
			while(x < 40*totalChars){
				//Draw all chars to video memory used by VGA controller
				for(int currentChar = 0; currentChar < totalChars; currentChar++){
  1801c4:	03011804 	movi	r12,1120
					for(int bit = 4; bit >= 0; bit--){
						linePixelCount++;
						int val = 0;
						if((pixels[currentChar][pixel] & (1 << bit)) != 0){
							val = 255;
  1801c8:	380d883a 	mov	r6,r7
  1801cc:	0007883a 	mov	r3,zero
		for(int x = 0; x < 10000; x+=4){
			IOWR_ALTERA_AVALON_PIO_DATA(x ,(0<<16)| (0<<8) | 0);
		}
	}

	void drawChars(int pixels[35][8]){
  1801d0:	3011883a 	mov	r8,r6
  1801d4:	01400104 	movi	r5,4
				//Draw all chars to video memory used by VGA controller
				for(int currentChar = 0; currentChar < totalChars; currentChar++){
					for(int bit = 4; bit >= 0; bit--){
						linePixelCount++;
						int val = 0;
						if((pixels[currentChar][pixel] & (1 << bit)) != 0){
  1801d8:	20db883a 	add	r13,r4,r3
  1801dc:	68800017 	ldw	r2,0(r13)
  1801e0:	1145d83a 	sra	r2,r2,r5
  1801e4:	1080004c 	andi	r2,r2,1
  1801e8:	10000226 	beq	r2,zero,1801f4 <drawChars+0x54>
							val = 255;
  1801ec:	00803fc4 	movi	r2,255
  1801f0:	00000106 	br	1801f8 <drawChars+0x58>
			while(x < 40*totalChars){
				//Draw all chars to video memory used by VGA controller
				for(int currentChar = 0; currentChar < totalChars; currentChar++){
					for(int bit = 4; bit >= 0; bit--){
						linePixelCount++;
						int val = 0;
  1801f4:	0005883a 	mov	r2,zero
						if((pixels[currentChar][pixel] & (1 << bit)) != 0){
							val = 255;
						}
						IOWR_ALTERA_AVALON_PIO_DATA(add ,(val<<16)| (val<<8) | val);
  1801f8:	101c943a 	slli	r14,r2,16
  1801fc:	1012923a 	slli	r9,r2,8
  180200:	7252b03a 	or	r9,r14,r9
  180204:	4884b03a 	or	r2,r9,r2
  180208:	40800035 	stwio	r2,0(r8)
			clearText();
			int pixel = 0;
			while(x < 40*totalChars){
				//Draw all chars to video memory used by VGA controller
				for(int currentChar = 0; currentChar < totalChars; currentChar++){
					for(int bit = 4; bit >= 0; bit--){
  18020c:	297fffc4 	addi	r5,r5,-1
						if((pixels[currentChar][pixel] & (1 << bit)) != 0){
							val = 255;
						}
						IOWR_ALTERA_AVALON_PIO_DATA(add ,(val<<16)| (val<<8) | val);
						x++;
						add+=4;
  180210:	42000104 	addi	r8,r8,4
			clearText();
			int pixel = 0;
			while(x < 40*totalChars){
				//Draw all chars to video memory used by VGA controller
				for(int currentChar = 0; currentChar < totalChars; currentChar++){
					for(int bit = 4; bit >= 0; bit--){
  180214:	2afff11e 	bne	r5,r11,1801dc <drawChars+0x3c>
  180218:	18c00804 	addi	r3,r3,32
  18021c:	31800604 	addi	r6,r6,24
			int linePixelCount = 0;
			clearText();
			int pixel = 0;
			while(x < 40*totalChars){
				//Draw all chars to video memory used by VGA controller
				for(int currentChar = 0; currentChar < totalChars; currentChar++){
  180220:	1b3feb1e 	bne	r3,r12,1801d0 <drawChars+0x30>
  180224:	21000104 	addi	r4,r4,4
						add+=4;
					}
					add+=4;
				}
				if(linePixelCount == (5*totalChars)){
					add+=(800-(24*totalChars));
  180228:	39c0c804 	addi	r7,r7,800
			int add = 0;
			int x = 0;
			int linePixelCount = 0;
			clearText();
			int pixel = 0;
			while(x < 40*totalChars){
  18022c:	513fe61e 	bne	r10,r4,1801c8 <drawChars+0x28>
					add+=(800-(24*totalChars));
					linePixelCount = 0;
				}
				pixel++;
			}
		}
  180230:	dfc00117 	ldw	ra,4(sp)
  180234:	dc000017 	ldw	r16,0(sp)
  180238:	dec00204 	addi	sp,sp,8
  18023c:	f800283a 	ret

00180240 <showText>:


void showText(char *chars){
  180240:	defee504 	addi	sp,sp,-1132
  180244:	dc411915 	stw	r17,1124(sp)
  180248:	dc011815 	stw	r16,1120(sp)
  18024c:	dfc11a15 	stw	ra,1128(sp)
  180250:	2021883a 	mov	r16,r4
  180254:	d807883a 	mov	r3,sp
  180258:	244008c4 	addi	r17,r4,35
	int pixeldata[35][8];
	for(int x = 0; x < 35; x++){
		switch (chars[x]) {
  18025c:	80800007 	ldb	r2,0(r16)
  180260:	01001b44 	movi	r4,109
  180264:	11007026 	beq	r2,r4,180428 <showText+0x1e8>
  180268:	20802616 	blt	r4,r2,180304 <showText+0xc4>
  18026c:	01001984 	movi	r4,102
  180270:	11005926 	beq	r2,r4,1803d8 <showText+0x198>
  180274:	20801116 	blt	r4,r2,1802bc <showText+0x7c>
  180278:	01001884 	movi	r4,98
  18027c:	11004a26 	beq	r2,r4,1803a8 <showText+0x168>
  180280:	20800716 	blt	r4,r2,1802a0 <showText+0x60>
  180284:	01800804 	movi	r6,32
  180288:	11808f26 	beq	r2,r6,1804c8 <showText+0x288>
  18028c:	01001844 	movi	r4,97
  180290:	11008f1e 	bne	r2,r4,1804d0 <showText+0x290>
		  case 'a': memcpy(&pixeldata[x], &charTemplate[0], sizeof(pixeldata[x]) ); break;
  180294:	01400634 	movhi	r5,24
  180298:	294d9304 	addi	r5,r5,13900
  18029c:	00008f06 	br	1804dc <showText+0x29c>


void showText(char *chars){
	int pixeldata[35][8];
	for(int x = 0; x < 35; x++){
		switch (chars[x]) {
  1802a0:	01001904 	movi	r4,100
  1802a4:	11004426 	beq	r2,r4,1803b8 <showText+0x178>
  1802a8:	20804716 	blt	r4,r2,1803c8 <showText+0x188>
		  case 'a': memcpy(&pixeldata[x], &charTemplate[0], sizeof(pixeldata[x]) ); break;
		  case 'b': memcpy(&pixeldata[x], &charTemplate[1], sizeof(pixeldata[x]) ); break;
		  case 'c': memcpy(&pixeldata[x], &charTemplate[2], sizeof(pixeldata[x]) ); break;
  1802ac:	01400634 	movhi	r5,24
  1802b0:	01800804 	movi	r6,32
  1802b4:	294da304 	addi	r5,r5,13964
  1802b8:	00008806 	br	1804dc <showText+0x29c>


void showText(char *chars){
	int pixeldata[35][8];
	for(int x = 0; x < 35; x++){
		switch (chars[x]) {
  1802bc:	01001a44 	movi	r4,105
  1802c0:	11004d26 	beq	r2,r4,1803f8 <showText+0x1b8>
  1802c4:	20800816 	blt	r4,r2,1802e8 <showText+0xa8>
  1802c8:	010019c4 	movi	r4,103
  1802cc:	11004626 	beq	r2,r4,1803e8 <showText+0x1a8>
  1802d0:	01001a04 	movi	r4,104
  1802d4:	11007e1e 	bne	r2,r4,1804d0 <showText+0x290>
		  case 'c': memcpy(&pixeldata[x], &charTemplate[2], sizeof(pixeldata[x]) ); break;
		  case 'd': memcpy(&pixeldata[x], &charTemplate[3], sizeof(pixeldata[x]) ); break;
		  case 'e': memcpy(&pixeldata[x], &charTemplate[4], sizeof(pixeldata[x]) ); break;
		  case 'f': memcpy(&pixeldata[x], &charTemplate[5], sizeof(pixeldata[x]) ); break;
		  case 'g': memcpy(&pixeldata[x], &charTemplate[6], sizeof(pixeldata[x]) ); break;
		  case 'h': memcpy(&pixeldata[x], &charTemplate[7], sizeof(pixeldata[x]) ); break;
  1802d8:	01400634 	movhi	r5,24
  1802dc:	01800804 	movi	r6,32
  1802e0:	294dcb04 	addi	r5,r5,14124
  1802e4:	00007d06 	br	1804dc <showText+0x29c>


void showText(char *chars){
	int pixeldata[35][8];
	for(int x = 0; x < 35; x++){
		switch (chars[x]) {
  1802e8:	01001ac4 	movi	r4,107
  1802ec:	11004626 	beq	r2,r4,180408 <showText+0x1c8>
  1802f0:	20804916 	blt	r4,r2,180418 <showText+0x1d8>
		  case 'e': memcpy(&pixeldata[x], &charTemplate[4], sizeof(pixeldata[x]) ); break;
		  case 'f': memcpy(&pixeldata[x], &charTemplate[5], sizeof(pixeldata[x]) ); break;
		  case 'g': memcpy(&pixeldata[x], &charTemplate[6], sizeof(pixeldata[x]) ); break;
		  case 'h': memcpy(&pixeldata[x], &charTemplate[7], sizeof(pixeldata[x]) ); break;
		  case 'i': memcpy(&pixeldata[x], &charTemplate[8], sizeof(pixeldata[x]) ); break;
		  case 'j': memcpy(&pixeldata[x], &charTemplate[9], sizeof(pixeldata[x]) ); break;
  1802f4:	01400634 	movhi	r5,24
  1802f8:	01800804 	movi	r6,32
  1802fc:	294ddb04 	addi	r5,r5,14188
  180300:	00007606 	br	1804dc <showText+0x29c>


void showText(char *chars){
	int pixeldata[35][8];
	for(int x = 0; x < 35; x++){
		switch (chars[x]) {
  180304:	01001d04 	movi	r4,116
  180308:	11005b26 	beq	r2,r4,180478 <showText+0x238>
  18030c:	20801216 	blt	r4,r2,180358 <showText+0x118>
  180310:	01001c04 	movi	r4,112
  180314:	11004c26 	beq	r2,r4,180448 <showText+0x208>
  180318:	20800816 	blt	r4,r2,18033c <showText+0xfc>
  18031c:	01001b84 	movi	r4,110
  180320:	11004526 	beq	r2,r4,180438 <showText+0x1f8>
  180324:	01001bc4 	movi	r4,111
  180328:	1100691e 	bne	r2,r4,1804d0 <showText+0x290>
		  case 'j': memcpy(&pixeldata[x], &charTemplate[9], sizeof(pixeldata[x]) ); break;
		  case 'k': memcpy(&pixeldata[x], &charTemplate[10], sizeof(pixeldata[x]) ); break;
		  case 'l': memcpy(&pixeldata[x], &charTemplate[11], sizeof(pixeldata[x]) ); break;
		  case 'm': memcpy(&pixeldata[x], &charTemplate[12], sizeof(pixeldata[x]) ); break;
		  case 'n': memcpy(&pixeldata[x], &charTemplate[13], sizeof(pixeldata[x]) ); break;
		  case 'o': memcpy(&pixeldata[x], &charTemplate[14], sizeof(pixeldata[x]) ); break;
  18032c:	01400634 	movhi	r5,24
  180330:	01800804 	movi	r6,32
  180334:	294e0304 	addi	r5,r5,14348
  180338:	00006806 	br	1804dc <showText+0x29c>


void showText(char *chars){
	int pixeldata[35][8];
	for(int x = 0; x < 35; x++){
		switch (chars[x]) {
  18033c:	01001c84 	movi	r4,114
  180340:	11004526 	beq	r2,r4,180458 <showText+0x218>
  180344:	20804816 	blt	r4,r2,180468 <showText+0x228>
		  case 'l': memcpy(&pixeldata[x], &charTemplate[11], sizeof(pixeldata[x]) ); break;
		  case 'm': memcpy(&pixeldata[x], &charTemplate[12], sizeof(pixeldata[x]) ); break;
		  case 'n': memcpy(&pixeldata[x], &charTemplate[13], sizeof(pixeldata[x]) ); break;
		  case 'o': memcpy(&pixeldata[x], &charTemplate[14], sizeof(pixeldata[x]) ); break;
		  case 'p': memcpy(&pixeldata[x], &charTemplate[15], sizeof(pixeldata[x]) ); break;
		  case 'q': memcpy(&pixeldata[x], &charTemplate[16], sizeof(pixeldata[x]) ); break;
  180348:	01400634 	movhi	r5,24
  18034c:	01800804 	movi	r6,32
  180350:	294e1304 	addi	r5,r5,14412
  180354:	00006106 	br	1804dc <showText+0x29c>


void showText(char *chars){
	int pixeldata[35][8];
	for(int x = 0; x < 35; x++){
		switch (chars[x]) {
  180358:	01001dc4 	movi	r4,119
  18035c:	11004e26 	beq	r2,r4,180498 <showText+0x258>
  180360:	20800816 	blt	r4,r2,180384 <showText+0x144>
  180364:	01001d44 	movi	r4,117
  180368:	11004726 	beq	r2,r4,180488 <showText+0x248>
  18036c:	01001d84 	movi	r4,118
  180370:	1100571e 	bne	r2,r4,1804d0 <showText+0x290>
		  case 'q': memcpy(&pixeldata[x], &charTemplate[16], sizeof(pixeldata[x]) ); break;
		  case 'r': memcpy(&pixeldata[x], &charTemplate[17], sizeof(pixeldata[x]) ); break;
		  case 's': memcpy(&pixeldata[x], &charTemplate[18], sizeof(pixeldata[x]) ); break;
		  case 't': memcpy(&pixeldata[x], &charTemplate[19], sizeof(pixeldata[x]) ); break;
		  case 'u': memcpy(&pixeldata[x], &charTemplate[20], sizeof(pixeldata[x]) ); break;
		  case 'v': memcpy(&pixeldata[x], &charTemplate[21], sizeof(pixeldata[x]) ); break;
  180374:	01400634 	movhi	r5,24
  180378:	01800804 	movi	r6,32
  18037c:	294e3b04 	addi	r5,r5,14572
  180380:	00005606 	br	1804dc <showText+0x29c>


void showText(char *chars){
	int pixeldata[35][8];
	for(int x = 0; x < 35; x++){
		switch (chars[x]) {
  180384:	01001e44 	movi	r4,121
  180388:	11004b26 	beq	r2,r4,1804b8 <showText+0x278>
  18038c:	11004616 	blt	r2,r4,1804a8 <showText+0x268>
  180390:	01001e84 	movi	r4,122
  180394:	11004e1e 	bne	r2,r4,1804d0 <showText+0x290>
		  case 'u': memcpy(&pixeldata[x], &charTemplate[20], sizeof(pixeldata[x]) ); break;
		  case 'v': memcpy(&pixeldata[x], &charTemplate[21], sizeof(pixeldata[x]) ); break;
		  case 'w': memcpy(&pixeldata[x], &charTemplate[22], sizeof(pixeldata[x]) ); break;
		  case 'x': memcpy(&pixeldata[x], &charTemplate[23], sizeof(pixeldata[x]) ); break;
		  case 'y': memcpy(&pixeldata[x], &charTemplate[24], sizeof(pixeldata[x]) ); break;
		  case 'z': memcpy(&pixeldata[x], &charTemplate[25], sizeof(pixeldata[x]) ); break;
  180398:	01400634 	movhi	r5,24
  18039c:	01800804 	movi	r6,32
  1803a0:	294e5b04 	addi	r5,r5,14700
  1803a4:	00004d06 	br	1804dc <showText+0x29c>
void showText(char *chars){
	int pixeldata[35][8];
	for(int x = 0; x < 35; x++){
		switch (chars[x]) {
		  case 'a': memcpy(&pixeldata[x], &charTemplate[0], sizeof(pixeldata[x]) ); break;
		  case 'b': memcpy(&pixeldata[x], &charTemplate[1], sizeof(pixeldata[x]) ); break;
  1803a8:	01400634 	movhi	r5,24
  1803ac:	01800804 	movi	r6,32
  1803b0:	294d9b04 	addi	r5,r5,13932
  1803b4:	00004906 	br	1804dc <showText+0x29c>
		  case 'c': memcpy(&pixeldata[x], &charTemplate[2], sizeof(pixeldata[x]) ); break;
		  case 'd': memcpy(&pixeldata[x], &charTemplate[3], sizeof(pixeldata[x]) ); break;
  1803b8:	01400634 	movhi	r5,24
  1803bc:	01800804 	movi	r6,32
  1803c0:	294dab04 	addi	r5,r5,13996
  1803c4:	00004506 	br	1804dc <showText+0x29c>
		  case 'e': memcpy(&pixeldata[x], &charTemplate[4], sizeof(pixeldata[x]) ); break;
  1803c8:	01400634 	movhi	r5,24
  1803cc:	01800804 	movi	r6,32
  1803d0:	294db304 	addi	r5,r5,14028
  1803d4:	00004106 	br	1804dc <showText+0x29c>
		  case 'f': memcpy(&pixeldata[x], &charTemplate[5], sizeof(pixeldata[x]) ); break;
  1803d8:	01400634 	movhi	r5,24
  1803dc:	01800804 	movi	r6,32
  1803e0:	294dbb04 	addi	r5,r5,14060
  1803e4:	00003d06 	br	1804dc <showText+0x29c>
		  case 'g': memcpy(&pixeldata[x], &charTemplate[6], sizeof(pixeldata[x]) ); break;
  1803e8:	01400634 	movhi	r5,24
  1803ec:	01800804 	movi	r6,32
  1803f0:	294dc304 	addi	r5,r5,14092
  1803f4:	00003906 	br	1804dc <showText+0x29c>
		  case 'h': memcpy(&pixeldata[x], &charTemplate[7], sizeof(pixeldata[x]) ); break;
		  case 'i': memcpy(&pixeldata[x], &charTemplate[8], sizeof(pixeldata[x]) ); break;
  1803f8:	01400634 	movhi	r5,24
  1803fc:	01800804 	movi	r6,32
  180400:	294dd304 	addi	r5,r5,14156
  180404:	00003506 	br	1804dc <showText+0x29c>
		  case 'j': memcpy(&pixeldata[x], &charTemplate[9], sizeof(pixeldata[x]) ); break;
		  case 'k': memcpy(&pixeldata[x], &charTemplate[10], sizeof(pixeldata[x]) ); break;
  180408:	01400634 	movhi	r5,24
  18040c:	01800804 	movi	r6,32
  180410:	294de304 	addi	r5,r5,14220
  180414:	00003106 	br	1804dc <showText+0x29c>
		  case 'l': memcpy(&pixeldata[x], &charTemplate[11], sizeof(pixeldata[x]) ); break;
  180418:	01400634 	movhi	r5,24
  18041c:	01800804 	movi	r6,32
  180420:	294deb04 	addi	r5,r5,14252
  180424:	00002d06 	br	1804dc <showText+0x29c>
		  case 'm': memcpy(&pixeldata[x], &charTemplate[12], sizeof(pixeldata[x]) ); break;
  180428:	01400634 	movhi	r5,24
  18042c:	01800804 	movi	r6,32
  180430:	294df304 	addi	r5,r5,14284
  180434:	00002906 	br	1804dc <showText+0x29c>
		  case 'n': memcpy(&pixeldata[x], &charTemplate[13], sizeof(pixeldata[x]) ); break;
  180438:	01400634 	movhi	r5,24
  18043c:	01800804 	movi	r6,32
  180440:	294dfb04 	addi	r5,r5,14316
  180444:	00002506 	br	1804dc <showText+0x29c>
		  case 'o': memcpy(&pixeldata[x], &charTemplate[14], sizeof(pixeldata[x]) ); break;
		  case 'p': memcpy(&pixeldata[x], &charTemplate[15], sizeof(pixeldata[x]) ); break;
  180448:	01400634 	movhi	r5,24
  18044c:	01800804 	movi	r6,32
  180450:	294e0b04 	addi	r5,r5,14380
  180454:	00002106 	br	1804dc <showText+0x29c>
		  case 'q': memcpy(&pixeldata[x], &charTemplate[16], sizeof(pixeldata[x]) ); break;
		  case 'r': memcpy(&pixeldata[x], &charTemplate[17], sizeof(pixeldata[x]) ); break;
  180458:	01400634 	movhi	r5,24
  18045c:	01800804 	movi	r6,32
  180460:	294e1b04 	addi	r5,r5,14444
  180464:	00001d06 	br	1804dc <showText+0x29c>
		  case 's': memcpy(&pixeldata[x], &charTemplate[18], sizeof(pixeldata[x]) ); break;
  180468:	01400634 	movhi	r5,24
  18046c:	01800804 	movi	r6,32
  180470:	294e2304 	addi	r5,r5,14476
  180474:	00001906 	br	1804dc <showText+0x29c>
		  case 't': memcpy(&pixeldata[x], &charTemplate[19], sizeof(pixeldata[x]) ); break;
  180478:	01400634 	movhi	r5,24
  18047c:	01800804 	movi	r6,32
  180480:	294e2b04 	addi	r5,r5,14508
  180484:	00001506 	br	1804dc <showText+0x29c>
		  case 'u': memcpy(&pixeldata[x], &charTemplate[20], sizeof(pixeldata[x]) ); break;
  180488:	01400634 	movhi	r5,24
  18048c:	01800804 	movi	r6,32
  180490:	294e3304 	addi	r5,r5,14540
  180494:	00001106 	br	1804dc <showText+0x29c>
		  case 'v': memcpy(&pixeldata[x], &charTemplate[21], sizeof(pixeldata[x]) ); break;
		  case 'w': memcpy(&pixeldata[x], &charTemplate[22], sizeof(pixeldata[x]) ); break;
  180498:	01400634 	movhi	r5,24
  18049c:	01800804 	movi	r6,32
  1804a0:	294e4304 	addi	r5,r5,14604
  1804a4:	00000d06 	br	1804dc <showText+0x29c>
		  case 'x': memcpy(&pixeldata[x], &charTemplate[23], sizeof(pixeldata[x]) ); break;
  1804a8:	01400634 	movhi	r5,24
  1804ac:	01800804 	movi	r6,32
  1804b0:	294e4b04 	addi	r5,r5,14636
  1804b4:	00000906 	br	1804dc <showText+0x29c>
		  case 'y': memcpy(&pixeldata[x], &charTemplate[24], sizeof(pixeldata[x]) ); break;
  1804b8:	01400634 	movhi	r5,24
  1804bc:	01800804 	movi	r6,32
  1804c0:	294e5304 	addi	r5,r5,14668
  1804c4:	00000506 	br	1804dc <showText+0x29c>
		  case 'z': memcpy(&pixeldata[x], &charTemplate[25], sizeof(pixeldata[x]) ); break;
		  case ' ': memcpy(&pixeldata[x], &charTemplate[26], sizeof(pixeldata[x]) ); break;
  1804c8:	100d883a 	mov	r6,r2
  1804cc:	00000106 	br	1804d4 <showText+0x294>
		  default: memcpy(&pixeldata[x], &charTemplate[26], sizeof(pixeldata[x]) );
  1804d0:	01800804 	movi	r6,32
  1804d4:	01400634 	movhi	r5,24
  1804d8:	294e6304 	addi	r5,r5,14732
  1804dc:	1809883a 	mov	r4,r3
  1804e0:	0181df40 	call	181df4 <memcpy>
  1804e4:	84000044 	addi	r16,r16,1
  1804e8:	10c00804 	addi	r3,r2,32
		}


void showText(char *chars){
	int pixeldata[35][8];
	for(int x = 0; x < 35; x++){
  1804ec:	847f5b1e 	bne	r16,r17,18025c <showText+0x1c>
		  default: memcpy(&pixeldata[x], &charTemplate[26], sizeof(pixeldata[x]) );

		 }
	}

	drawChars(pixeldata);
  1804f0:	d809883a 	mov	r4,sp
  1804f4:	01801a00 	call	1801a0 <drawChars>
}
  1804f8:	dfc11a17 	ldw	ra,1128(sp)
  1804fc:	dc411917 	ldw	r17,1124(sp)
  180500:	dc011817 	ldw	r16,1120(sp)
  180504:	dec11b04 	addi	sp,sp,1132
  180508:	f800283a 	ret

0018050c <scanBarcode>:

char charcode[256] = {};
int barwidth = 0;
int actualCount = 0;
void scanBarcode(){
  18050c:	defff704 	addi	sp,sp,-36
  180510:	dcc00315 	stw	r19,12(sp)
				charcode[actualCount] = '0';
				actualCount++;
			}
		}else{
			//alt_printf("1");
			charcode[actualCount] = '1';
  180514:	04c00634 	movhi	r19,24
}

char charcode[256] = {};
int barwidth = 0;
int actualCount = 0;
void scanBarcode(){
  180518:	dc800215 	stw	r18,8(sp)
  18051c:	dc400115 	stw	r17,4(sp)
  180520:	dc000015 	stw	r16,0(sp)
  180524:	dfc00815 	stw	ra,32(sp)
  180528:	ddc00715 	stw	r23,28(sp)
  18052c:	dd800615 	stw	r22,24(sp)
  180530:	dd400515 	stw	r21,20(sp)
  180534:	dd000415 	stw	r20,16(sp)
	int firstBit = 0;
	int countingBarWidth = 1;
	barwidth = 0;
  180538:	d0223715 	stw	zero,-30500(gp)
	actualCount = 0;
  18053c:	d0223615 	stw	zero,-30504(gp)

	for(int x =0; x < 255; x++){
  180540:	0021883a 	mov	r16,zero
char charcode[256] = {};
int barwidth = 0;
int actualCount = 0;
void scanBarcode(){
	int firstBit = 0;
	int countingBarWidth = 1;
  180544:	04800044 	movi	r18,1

char charcode[256] = {};
int barwidth = 0;
int actualCount = 0;
void scanBarcode(){
	int firstBit = 0;
  180548:	0023883a 	mov	r17,zero
				charcode[actualCount] = '0';
				actualCount++;
			}
		}else{
			//alt_printf("1");
			charcode[actualCount] = '1';
  18054c:	9cd1fb04 	addi	r19,r19,18412
	int countingBarWidth = 1;
	barwidth = 0;
	actualCount = 0;

	for(int x =0; x < 255; x++){
		IOWR_ALTERA_AVALON_PIO_DATA(0x4020, x);
  180550:	00900804 	movi	r2,16416
  180554:	14000035 	stwio	r16,0(r2)
		int r = IORD_ALTERA_AVALON_PIO_DATA(0x4000);
  180558:	00900004 	movi	r2,16384
  18055c:	15000037 	ldwio	r20,0(r2)
		int g = IORD_ALTERA_AVALON_PIO_DATA(0x4010);
  180560:	00900404 	movi	r2,16400
  180564:	15c00037 	ldwio	r23,0(r2)
		int b = IORD_ALTERA_AVALON_PIO_DATA(0x4040);
  180568:	00901004 	movi	r2,16448
  18056c:	15800037 	ldwio	r22,0(r2)

		int grey =  0.2126*r + 0.7152*g + 0.0722*b;

		//printf( " R=%d ",grey);
		usleep(5100);
  180570:	0104fb04 	movi	r4,5100
  180574:	0182acc0 	call	182acc <usleep>
		if(grey > 128){
  180578:	a009883a 	mov	r4,r20
  18057c:	0181c8c0 	call	181c8c <__floatsidf>
  180580:	0183e474 	movhi	r6,3985
  180584:	01cff2f4 	movhi	r7,16331
  180588:	31a5af04 	addi	r6,r6,-26948
  18058c:	39cd9e84 	addi	r7,r7,13946
  180590:	180b883a 	mov	r5,r3
  180594:	1009883a 	mov	r4,r2
  180598:	01813a00 	call	1813a0 <__muldf3>
  18059c:	b809883a 	mov	r4,r23
  1805a0:	102b883a 	mov	r21,r2
  1805a4:	1829883a 	mov	r20,r3
  1805a8:	0181c8c0 	call	181c8c <__floatsidf>
  1805ac:	018710f4 	movhi	r6,7235
  1805b0:	01cff9f4 	movhi	r7,16359
  1805b4:	318b2944 	addi	r6,r6,11429
  1805b8:	39f8bac4 	addi	r7,r7,-7445
  1805bc:	1009883a 	mov	r4,r2
  1805c0:	180b883a 	mov	r5,r3
  1805c4:	01813a00 	call	1813a0 <__muldf3>
  1805c8:	a00b883a 	mov	r5,r20
  1805cc:	100d883a 	mov	r6,r2
  1805d0:	180f883a 	mov	r7,r3
  1805d4:	a809883a 	mov	r4,r21
  1805d8:	0180af40 	call	180af4 <__adddf3>
  1805dc:	b009883a 	mov	r4,r22
  1805e0:	102b883a 	mov	r21,r2
  1805e4:	1829883a 	mov	r20,r3
  1805e8:	0181c8c0 	call	181c8c <__floatsidf>
  1805ec:	01bfb174 	movhi	r6,65221
  1805f0:	01cfecb4 	movhi	r7,16306
  1805f4:	319b5744 	addi	r6,r6,27997
  1805f8:	39deec84 	addi	r7,r7,31666
  1805fc:	1009883a 	mov	r4,r2
  180600:	180b883a 	mov	r5,r3
  180604:	01813a00 	call	1813a0 <__muldf3>
  180608:	100d883a 	mov	r6,r2
  18060c:	180f883a 	mov	r7,r3
  180610:	a809883a 	mov	r4,r21
  180614:	a00b883a 	mov	r5,r20
  180618:	0180af40 	call	180af4 <__adddf3>
  18061c:	1009883a 	mov	r4,r2
  180620:	180b883a 	mov	r5,r3
  180624:	0181c0c0 	call	181c0c <__fixdfsi>
  180628:	01002004 	movi	r4,128
  18062c:	00c00044 	movi	r3,1
  180630:	2080090e 	bge	r4,r2,180658 <scanBarcode+0x14c>
			if(firstBit==1){
  180634:	88c0141e 	bne	r17,r3,180688 <scanBarcode+0x17c>
				countingBarWidth = 0;
				//alt_printf("0");
				charcode[actualCount] = '0';
  180638:	d0a23617 	ldw	r2,-30504(gp)
  18063c:	01000c04 	movi	r4,48

		//printf( " R=%d ",grey);
		usleep(5100);
		if(grey > 128){
			if(firstBit==1){
				countingBarWidth = 0;
  180640:	0025883a 	mov	r18,zero
				//alt_printf("0");
				charcode[actualCount] = '0';
  180644:	9887883a 	add	r3,r19,r2
				actualCount++;
  180648:	10800044 	addi	r2,r2,1
		usleep(5100);
		if(grey > 128){
			if(firstBit==1){
				countingBarWidth = 0;
				//alt_printf("0");
				charcode[actualCount] = '0';
  18064c:	19000005 	stb	r4,0(r3)
				actualCount++;
  180650:	d0a23615 	stw	r2,-30504(gp)
  180654:	00000f06 	br	180694 <scanBarcode+0x188>
			}
		}else{
			//alt_printf("1");
			charcode[actualCount] = '1';
  180658:	d0a23617 	ldw	r2,-30504(gp)
  18065c:	01400c44 	movi	r5,49
  180660:	9889883a 	add	r4,r19,r2
			actualCount++;
  180664:	10800044 	addi	r2,r2,1
				charcode[actualCount] = '0';
				actualCount++;
			}
		}else{
			//alt_printf("1");
			charcode[actualCount] = '1';
  180668:	21400005 	stb	r5,0(r4)
			actualCount++;
  18066c:	d0a23615 	stw	r2,-30504(gp)
			if(countingBarWidth == 1){
  180670:	90c0071e 	bne	r18,r3,180690 <scanBarcode+0x184>
				barwidth++;
  180674:	d0a23717 	ldw	r2,-30500(gp)
			}
			firstBit = 1;
  180678:	9023883a 	mov	r17,r18
		}else{
			//alt_printf("1");
			charcode[actualCount] = '1';
			actualCount++;
			if(countingBarWidth == 1){
				barwidth++;
  18067c:	10800044 	addi	r2,r2,1
  180680:	d0a23715 	stw	r2,-30500(gp)
  180684:	00000306 	br	180694 <scanBarcode+0x188>
  180688:	0023883a 	mov	r17,zero
  18068c:	00000106 	br	180694 <scanBarcode+0x188>
			}
			firstBit = 1;
  180690:	1823883a 	mov	r17,r3
	int firstBit = 0;
	int countingBarWidth = 1;
	barwidth = 0;
	actualCount = 0;

	for(int x =0; x < 255; x++){
  180694:	84000044 	addi	r16,r16,1
  180698:	00803fc4 	movi	r2,255
  18069c:	80bfac1e 	bne	r16,r2,180550 <scanBarcode+0x44>
				barwidth++;
			}
			firstBit = 1;
		}
	}
	printf("\nWidth: %d",barwidth);
  1806a0:	d1623717 	ldw	r5,-30500(gp)
  1806a4:	01000634 	movhi	r4,24
  1806a8:	210d0804 	addi	r4,r4,13344
  1806ac:	0181e580 	call	181e58 <printf>
	alt_printf("\n");
  1806b0:	01000634 	movhi	r4,24
  1806b4:	210d5004 	addi	r4,r4,13632

	for(int x = 0; x < 255; x+=barwidth){
		printf("%c",charcode[x]);
  1806b8:	04c00634 	movhi	r19,24
			}
			firstBit = 1;
		}
	}
	printf("\nWidth: %d",barwidth);
	alt_printf("\n");
  1806bc:	01829140 	call	182914 <alt_printf>

	for(int x = 0; x < 255; x+=barwidth){
  1806c0:	0021883a 	mov	r16,zero
		printf("%c",charcode[x]);
  1806c4:	9cd1fb04 	addi	r19,r19,18412
		}
	}
	printf("\nWidth: %d",barwidth);
	alt_printf("\n");

	for(int x = 0; x < 255; x+=barwidth){
  1806c8:	04803f84 	movi	r18,254
		printf("%c",charcode[x]);
  1806cc:	9c23883a 	add	r17,r19,r16
  1806d0:	89000007 	ldb	r4,0(r17)
  1806d4:	0181eac0 	call	181eac <putchar>
		tx_char(charcode[x],x);
  1806d8:	89000007 	ldb	r4,0(r17)
  1806dc:	800b883a 	mov	r5,r16
  1806e0:	01809c40 	call	1809c4 <tx_char>
		}
	}
	printf("\nWidth: %d",barwidth);
	alt_printf("\n");

	for(int x = 0; x < 255; x+=barwidth){
  1806e4:	d0a23717 	ldw	r2,-30500(gp)
  1806e8:	80a1883a 	add	r16,r16,r2
  1806ec:	943ff70e 	bge	r18,r16,1806cc <scanBarcode+0x1c0>
		printf("%c",charcode[x]);
		tx_char(charcode[x],x);
	}
	transmit();
	//tx_ethernet_isr(tmp);
}
  1806f0:	dfc00817 	ldw	ra,32(sp)
  1806f4:	ddc00717 	ldw	r23,28(sp)
  1806f8:	dd800617 	ldw	r22,24(sp)
  1806fc:	dd400517 	ldw	r21,20(sp)
  180700:	dd000417 	ldw	r20,16(sp)
  180704:	dcc00317 	ldw	r19,12(sp)
  180708:	dc800217 	ldw	r18,8(sp)
  18070c:	dc400117 	ldw	r17,4(sp)
  180710:	dc000017 	ldw	r16,0(sp)
  180714:	dec00904 	addi	sp,sp,36

	for(int x = 0; x < 255; x+=barwidth){
		printf("%c",charcode[x]);
		tx_char(charcode[x],x);
	}
	transmit();
  180718:	01809d81 	jmpi	1809d8 <transmit>

0018071c <callback>:
	}

	return 0;
}

void callback(unsigned char *data){
  18071c:	defffe04 	addi	sp,sp,-8
  180720:	dc000015 	stw	r16,0(sp)
	alt_printf( "\nResponds: %s\n", data + 16);
  180724:	24000404 	addi	r16,r4,16
  180728:	01000634 	movhi	r4,24
  18072c:	800b883a 	mov	r5,r16
  180730:	210d1104 	addi	r4,r4,13380
	}

	return 0;
}

void callback(unsigned char *data){
  180734:	dfc00115 	stw	ra,4(sp)
	alt_printf( "\nResponds: %s\n", data + 16);
  180738:	01829140 	call	182914 <alt_printf>
	showText(data + 16);
  18073c:	8009883a 	mov	r4,r16
}
  180740:	dfc00117 	ldw	ra,4(sp)
  180744:	dc000017 	ldw	r16,0(sp)
  180748:	dec00204 	addi	sp,sp,8
	return 0;
}

void callback(unsigned char *data){
	alt_printf( "\nResponds: %s\n", data + 16);
	showText(data + 16);
  18074c:	01802401 	jmpi	180240 <showText>

00180750 <main>:
		tx_char(charcode[x],x);
	}
	transmit();
	//tx_ethernet_isr(tmp);
}
int main(void){
  180750:	deffff04 	addi	sp,sp,-4
  180754:	dfc00015 	stw	ra,0(sp)
	setup();
  180758:	018084c0 	call	18084c <setup>
	showText("please scan a barcode");
  18075c:	01000634 	movhi	r4,24
  180760:	210d0b04 	addi	r4,r4,13356
  180764:	01802400 	call	180240 <showText>

	scanBarcode();
  180768:	018050c0 	call	18050c <scanBarcode>
	scanBarcode();
  18076c:	018050c0 	call	18050c <scanBarcode>
	scanBarcode();
  180770:	018050c0 	call	18050c <scanBarcode>
	while(1){
		usleep(200000);
  180774:	010000f4 	movhi	r4,3
  180778:	21035004 	addi	r4,r4,3392
  18077c:	0182acc0 	call	182acc <usleep>
  180780:	003ffc06 	br	180774 <main+0x24>

00180784 <rx_ethernet_isr>:
	//while (alt_avalon_sgdma_check_descriptor_status(&tx_descriptor) != 0)

}

void rx_ethernet_isr (void *context)
{
  180784:	defffa04 	addi	sp,sp,-24
  180788:	dfc00515 	stw	ra,20(sp)
  18078c:	dc000415 	stw	r16,16(sp)
	int i;

		// Wait until receive descriptor transfer is complete
		while (alt_avalon_sgdma_check_descriptor_status(&rx_descriptor) != 0)
  180790:	01000074 	movhi	r4,1
  180794:	21200804 	addi	r4,r4,-32736
  180798:	0182d580 	call	182d58 <alt_avalon_sgdma_check_descriptor_status>
  18079c:	103ffc1e 	bne	r2,zero,180790 <rx_ethernet_isr+0xc>
		// Clear input line before writing
//		for (i = 0; i < (6 + text_length); i++) {
//			alt_printf( "%c", 0x08 );		 // 0x08 --> backspace
//		}
		//alt_printf( "got: %s\n", rx_frame + 16);
		if(rx_frame[2] == 0x69){
  1807a0:	04000634 	movhi	r16,24
  1807a4:	84123b04 	addi	r16,r16,18668
  1807a8:	80c00083 	ldbu	r3,2(r16)
  1807ac:	00801a44 	movi	r2,105
  1807b0:	1880021e 	bne	r3,r2,1807bc <rx_ethernet_isr+0x38>

			callback(rx_frame);
  1807b4:	8009883a 	mov	r4,r16
  1807b8:	018071c0 	call	18071c <callback>
		}

		alt_avalon_sgdma_construct_mem_to_stream_desc( &tx_descriptor, &tx_descriptor_end, (alt_u32 *)tx_frame, 62, 0, 1, 1, 0 );
  1807bc:	00800044 	movi	r2,1
  1807c0:	01800634 	movhi	r6,24
  1807c4:	01400074 	movhi	r5,1
  1807c8:	01000074 	movhi	r4,1
  1807cc:	d8800215 	stw	r2,8(sp)
  1807d0:	d8800115 	stw	r2,4(sp)
  1807d4:	01c00f84 	movi	r7,62
  1807d8:	318e6b04 	addi	r6,r6,14764
  1807dc:	29601004 	addi	r5,r5,-32704
  1807e0:	21201804 	addi	r4,r4,-32672
  1807e4:	d8000315 	stw	zero,12(sp)
  1807e8:	d8000015 	stw	zero,0(sp)
  1807ec:	01830740 	call	183074 <alt_avalon_sgdma_construct_mem_to_stream_desc>
		// Create new receive sgdma descriptor
		alt_avalon_sgdma_construct_stream_to_mem_desc( &rx_descriptor, &rx_descriptor_end, (alt_u32 *)rx_frame, 0, 0 );
  1807f0:	01800634 	movhi	r6,24
  1807f4:	01400074 	movhi	r5,1
  1807f8:	01000074 	movhi	r4,1
  1807fc:	000f883a 	mov	r7,zero
  180800:	31923b04 	addi	r6,r6,18668
  180804:	29600004 	addi	r5,r5,-32768
  180808:	21200804 	addi	r4,r4,-32736
  18080c:	d8000015 	stw	zero,0(sp)
  180810:	0182ffc0 	call	182ffc <alt_avalon_sgdma_construct_stream_to_mem_desc>


		// Set up non-blocking transfer of sgdma receive descriptor
		alt_avalon_sgdma_do_async_transfer( sgdma_rx_dev, &rx_descriptor );
  180814:	d1223a17 	ldw	r4,-30488(gp)
  180818:	01400074 	movhi	r5,1
  18081c:	29600804 	addi	r5,r5,-32736
  180820:	0182c180 	call	182c18 <alt_avalon_sgdma_do_async_transfer>

		// Output received text
			for(int x = 0; x < 1024; x++){
  180824:	0005883a 	mov	r2,zero
  180828:	00c10004 	movi	r3,1024
						rx_frame[x] = 0;
  18082c:	1409883a 	add	r4,r2,r16
  180830:	20000005 	stb	zero,0(r4)

		// Set up non-blocking transfer of sgdma receive descriptor
		alt_avalon_sgdma_do_async_transfer( sgdma_rx_dev, &rx_descriptor );

		// Output received text
			for(int x = 0; x < 1024; x++){
  180834:	10800044 	addi	r2,r2,1
  180838:	10fffc1e 	bne	r2,r3,18082c <rx_ethernet_isr+0xa8>
						rx_frame[x] = 0;
			}
}
  18083c:	dfc00517 	ldw	ra,20(sp)
  180840:	dc000417 	ldw	r16,16(sp)
  180844:	dec00604 	addi	sp,sp,24
  180848:	f800283a 	ret

0018084c <setup>:
alt_sgdma_descriptor rx_descriptor_end  __attribute__ (( section ( ".descriptor_memory" )));

void setup(void)
{
	// Open the sgdma transmit device
	sgdma_tx_dev = alt_avalon_sgdma_open ("/dev/sgdma_tx");
  18084c:	01000634 	movhi	r4,24

alt_sgdma_descriptor rx_descriptor  	__attribute__ (( section ( ".descriptor_memory" )));
alt_sgdma_descriptor rx_descriptor_end  __attribute__ (( section ( ".descriptor_memory" )));

void setup(void)
{
  180850:	defffe04 	addi	sp,sp,-8
	// Open the sgdma transmit device
	sgdma_tx_dev = alt_avalon_sgdma_open ("/dev/sgdma_tx");
  180854:	210d1504 	addi	r4,r4,13396

alt_sgdma_descriptor rx_descriptor  	__attribute__ (( section ( ".descriptor_memory" )));
alt_sgdma_descriptor rx_descriptor_end  __attribute__ (( section ( ".descriptor_memory" )));

void setup(void)
{
  180858:	dfc00115 	stw	ra,4(sp)
	// Open the sgdma transmit device
	sgdma_tx_dev = alt_avalon_sgdma_open ("/dev/sgdma_tx");
  18085c:	0182d840 	call	182d84 <alt_avalon_sgdma_open>
  180860:	d0a23815 	stw	r2,-30496(gp)
	if (sgdma_tx_dev == NULL) {
  180864:	1000031e 	bne	r2,zero,180874 <setup+0x28>
		alt_printf ("Error: could not open scatter-gather dma transmit device\n");
  180868:	01000634 	movhi	r4,24
  18086c:	210d1904 	addi	r4,r4,13412
  180870:	00000206 	br	18087c <setup+0x30>
	} else alt_printf ("Opened scatter-gather dma transmit device\n");
  180874:	01000634 	movhi	r4,24
  180878:	210d2804 	addi	r4,r4,13472
  18087c:	01829140 	call	182914 <alt_printf>

	// Open the sgdma receive device
	sgdma_rx_dev = alt_avalon_sgdma_open ("/dev/sgdma_rx");
  180880:	01000634 	movhi	r4,24
  180884:	210d3304 	addi	r4,r4,13516
  180888:	0182d840 	call	182d84 <alt_avalon_sgdma_open>
  18088c:	d0a23a15 	stw	r2,-30488(gp)
	if (sgdma_rx_dev == NULL) {
  180890:	1000031e 	bne	r2,zero,1808a0 <setup+0x54>
		alt_printf ("Error: could not open scatter-gather dma receive device\n");
  180894:	01000634 	movhi	r4,24
  180898:	210d3704 	addi	r4,r4,13532
  18089c:	00000206 	br	1808a8 <setup+0x5c>
	} else alt_printf ("Opened scatter-gather dma receive device\n");
  1808a0:	01000634 	movhi	r4,24
  1808a4:	210d4604 	addi	r4,r4,13592
  1808a8:	01829140 	call	182914 <alt_printf>

	// Set interrupts for the sgdma receive device
	alt_avalon_sgdma_register_callback( sgdma_rx_dev, (alt_avalon_sgdma_callback) rx_ethernet_isr, 0x00000014, NULL );
  1808ac:	d1223a17 	ldw	r4,-30488(gp)
  1808b0:	01400634 	movhi	r5,24
  1808b4:	000f883a 	mov	r7,zero
  1808b8:	01800504 	movi	r6,20
  1808bc:	2941e104 	addi	r5,r5,1924
  1808c0:	0182d140 	call	182d14 <alt_avalon_sgdma_register_callback>

	// Create sgdma receive descriptor
	alt_avalon_sgdma_construct_stream_to_mem_desc( &rx_descriptor, &rx_descriptor_end, (alt_u32 *)rx_frame, 0, 0 );
  1808c4:	01800634 	movhi	r6,24
  1808c8:	01400074 	movhi	r5,1
  1808cc:	01000074 	movhi	r4,1
  1808d0:	000f883a 	mov	r7,zero
  1808d4:	31923b04 	addi	r6,r6,18668
  1808d8:	29600004 	addi	r5,r5,-32768
  1808dc:	21200804 	addi	r4,r4,-32736
  1808e0:	d8000015 	stw	zero,0(sp)
  1808e4:	0182ffc0 	call	182ffc <alt_avalon_sgdma_construct_stream_to_mem_desc>

	// Set up non-blocking transfer of sgdma receive descriptor
	alt_avalon_sgdma_do_async_transfer( sgdma_rx_dev, &rx_descriptor );
  1808e8:	d1223a17 	ldw	r4,-30488(gp)
  1808ec:	01400074 	movhi	r5,1
  1808f0:	29600804 	addi	r5,r5,-32736
  1808f4:	0182c180 	call	182c18 <alt_avalon_sgdma_do_async_transfer>

	// Triple-speed Ethernet MegaCore base address
	volatile int * tse = (int *) ETH_TSE_BASE;

	// Initialize the MAC address
	*(tse + 3) = 0x116E6001;
  1808f8:	00800434 	movhi	r2,16
  1808fc:	00c45bb4 	movhi	r3,4462
  180900:	18d80044 	addi	r3,r3,24577
  180904:	10880304 	addi	r2,r2,8204
  180908:	10c00015 	stw	r3,0(r2)
	*(tse + 4) = 0x00000F02;
  18090c:	00800434 	movhi	r2,16
  180910:	00c3c084 	movi	r3,3842
  180914:	10880404 	addi	r2,r2,8208
  180918:	10c00015 	stw	r3,0(r2)

	// Specify the addresses of the PHY devices to be accessed through MDIO interface
	*(tse + 0x0F) = 0x10;
  18091c:	00800434 	movhi	r2,16
  180920:	00c00404 	movi	r3,16
  180924:	10880f04 	addi	r2,r2,8252
  180928:	10c00015 	stw	r3,0(r2)
	*(tse + 0x10) = 0x11;
  18092c:	00800434 	movhi	r2,16
  180930:	00c00444 	movi	r3,17
  180934:	10881004 	addi	r2,r2,8256
  180938:	10c00015 	stw	r3,0(r2)

	// Write to register 20 of the PHY chip for Ethernet port 0 to set up line loopback
	*(tse + 0x94) = 0x4000;
  18093c:	00800434 	movhi	r2,16
  180940:	00d00004 	movi	r3,16384
  180944:	10889404 	addi	r2,r2,8784
  180948:	10c00015 	stw	r3,0(r2)

	// Write to register 16 of the PHY chip for Ethernet port 1 to enable automatic crossover for all modes
	*(tse + 0xB0) = *(tse + 0xB0) | 0x0060;
  18094c:	00c00434 	movhi	r3,16
  180950:	18c8b004 	addi	r3,r3,8896
  180954:	18800017 	ldw	r2,0(r3)
  180958:	10801814 	ori	r2,r2,96
  18095c:	18800015 	stw	r2,0(r3)

	// Write to register 20 of the PHY chip for Ethernet port 2 to set up delay for input/output clk
	*(tse + 0xB4) = *(tse + 0xB4) | 0x0082;
  180960:	00c00434 	movhi	r3,16
  180964:	18c8b404 	addi	r3,r3,8912
  180968:	18800017 	ldw	r2,0(r3)
  18096c:	10802094 	ori	r2,r2,130
  180970:	18800015 	stw	r2,0(r3)

	// Software reset the second PHY chip and wait
	*(tse + 0xA0) = *(tse + 0xA0) | 0x8000;
  180974:	00800434 	movhi	r2,16
  180978:	1088a004 	addi	r2,r2,8832
  18097c:	10c00017 	ldw	r3,0(r2)
  180980:	18e00014 	ori	r3,r3,32768
  180984:	10c00015 	stw	r3,0(r2)

	while ( *(tse + 0xA0) & 0x8000 );
  180988:	10c00017 	ldw	r3,0(r2)
  18098c:	18e0000c 	andi	r3,r3,32768
  180990:	183ffd1e 	bne	r3,zero,180988 <setup+0x13c>
	alt_printf("help");
  180994:	01000634 	movhi	r4,24
  180998:	210d5104 	addi	r4,r4,13636
  18099c:	01829140 	call	182914 <alt_printf>

	// Enable read and write transfers, 100 mbit Ethernet operation, and CRC forwarding
	//*(tse + 2) = *(tse + 2) | 0x00000043;

	// Enable read and write transfers, gigabit Ethernet operation, and CRC forwarding
	*(tse + 2) = *(tse + 2) | 0x0000004B;
  1809a0:	00c00434 	movhi	r3,16
  1809a4:	18c80204 	addi	r3,r3,8200
  1809a8:	18800017 	ldw	r2,0(r3)
  1809ac:	108012d4 	ori	r2,r2,75
  1809b0:	18800015 	stw	r2,0(r3)
}
  1809b4:	dfc00117 	ldw	ra,4(sp)
  1809b8:	dec00204 	addi	sp,sp,8
  1809bc:	f800283a 	ret

001809c0 <refresh_ethernet>:

void refresh_ethernet(){
  1809c0:	f800283a 	ret

001809c4 <tx_char>:
						rx_frame[x] = 0;
			}
}

void tx_char(char *c, int x){
	tx_frame[16 + x] = c;
  1809c4:	00800634 	movhi	r2,24
  1809c8:	108e6f04 	addi	r2,r2,14780
  1809cc:	288b883a 	add	r5,r5,r2
  1809d0:	29000005 	stb	r4,0(r5)
  1809d4:	f800283a 	ret

001809d8 <transmit>:
}

void transmit(){
  1809d8:	defffb04 	addi	sp,sp,-20
	// Create transmit sgdma descriptor
				alt_avalon_sgdma_construct_mem_to_stream_desc( &tx_descriptor, &tx_descriptor_end, (alt_u32 *)tx_frame, 62, 0, 1, 1, 0 );
  1809dc:	00800044 	movi	r2,1
  1809e0:	01800634 	movhi	r6,24
  1809e4:	01400074 	movhi	r5,1
  1809e8:	01000074 	movhi	r4,1
  1809ec:	29601004 	addi	r5,r5,-32704
  1809f0:	21201804 	addi	r4,r4,-32672
  1809f4:	d8000315 	stw	zero,12(sp)
  1809f8:	d8800215 	stw	r2,8(sp)
  1809fc:	d8800115 	stw	r2,4(sp)
  180a00:	d8000015 	stw	zero,0(sp)
  180a04:	01c00f84 	movi	r7,62
  180a08:	318e6b04 	addi	r6,r6,14764

void tx_char(char *c, int x){
	tx_frame[16 + x] = c;
}

void transmit(){
  180a0c:	dfc00415 	stw	ra,16(sp)
	// Create transmit sgdma descriptor
				alt_avalon_sgdma_construct_mem_to_stream_desc( &tx_descriptor, &tx_descriptor_end, (alt_u32 *)tx_frame, 62, 0, 1, 1, 0 );
  180a10:	01830740 	call	183074 <alt_avalon_sgdma_construct_mem_to_stream_desc>
				// Set up non-blocking transfer of sgdma transmit descriptor
				alt_avalon_sgdma_do_async_transfer( sgdma_tx_dev, &tx_descriptor );
  180a14:	d1223817 	ldw	r4,-30496(gp)
  180a18:	01400074 	movhi	r5,1
  180a1c:	29601804 	addi	r5,r5,-32672
  180a20:	0182c180 	call	182c18 <alt_avalon_sgdma_do_async_transfer>
				// Wait until transmit descriptor transfer is complete
				while (alt_avalon_sgdma_check_descriptor_status(&tx_descriptor) != 0);
  180a24:	01000074 	movhi	r4,1
  180a28:	21201804 	addi	r4,r4,-32672
  180a2c:	0182d580 	call	182d58 <alt_avalon_sgdma_check_descriptor_status>
  180a30:	103ffc1e 	bne	r2,zero,180a24 <transmit+0x4c>
}
  180a34:	dfc00417 	ldw	ra,16(sp)
  180a38:	dec00504 	addi	sp,sp,20
  180a3c:	f800283a 	ret

00180a40 <tx_ethernet_isr>:

void tx_ethernet_isr(char *chars){
  180a40:	defff804 	addi	sp,sp,-32
  180a44:	dc800615 	stw	r18,24(sp)
  180a48:	04800634 	movhi	r18,24
  180a4c:	dc400515 	stw	r17,20(sp)
  180a50:	dc000415 	stw	r16,16(sp)
  180a54:	dfc00715 	stw	ra,28(sp)
  180a58:	2023883a 	mov	r17,r4
  180a5c:	948e6f04 	addi	r18,r18,14780
			for(int x = 0; x < strlen(chars); x++){
  180a60:	2021883a 	mov	r16,r4
  180a64:	8809883a 	mov	r4,r17
  180a68:	0181ec80 	call	181ec8 <strlen>
  180a6c:	8447c83a 	sub	r3,r16,r17
  180a70:	1880052e 	bgeu	r3,r2,180a88 <tx_ethernet_isr+0x48>
				tx_frame[16 + x] = chars[x];
  180a74:	80800003 	ldbu	r2,0(r16)
  180a78:	94800044 	addi	r18,r18,1
  180a7c:	84000044 	addi	r16,r16,1
  180a80:	90bfffc5 	stb	r2,-1(r18)
  180a84:	003ff706 	br	180a64 <tx_ethernet_isr+0x24>
			}
			// Create transmit sgdma descriptor
			alt_avalon_sgdma_construct_mem_to_stream_desc( &tx_descriptor, &tx_descriptor_end, (alt_u32 *)tx_frame, 62, 0, 1, 1, 0 );
  180a88:	00800044 	movi	r2,1
  180a8c:	01800634 	movhi	r6,24
  180a90:	01400074 	movhi	r5,1
  180a94:	01000074 	movhi	r4,1
  180a98:	29601004 	addi	r5,r5,-32704
  180a9c:	21201804 	addi	r4,r4,-32672
  180aa0:	d8000315 	stw	zero,12(sp)
  180aa4:	d8800215 	stw	r2,8(sp)
  180aa8:	d8800115 	stw	r2,4(sp)
  180aac:	d8000015 	stw	zero,0(sp)
  180ab0:	01c00f84 	movi	r7,62
  180ab4:	318e6b04 	addi	r6,r6,14764
  180ab8:	01830740 	call	183074 <alt_avalon_sgdma_construct_mem_to_stream_desc>
			// Set up non-blocking transfer of sgdma transmit descriptor
			alt_avalon_sgdma_do_async_transfer( sgdma_tx_dev, &tx_descriptor );
  180abc:	d1223817 	ldw	r4,-30496(gp)
  180ac0:	01400074 	movhi	r5,1
  180ac4:	29601804 	addi	r5,r5,-32672
  180ac8:	0182c180 	call	182c18 <alt_avalon_sgdma_do_async_transfer>
			// Wait until transmit descriptor transfer is complete
			while (alt_avalon_sgdma_check_descriptor_status(&tx_descriptor) != 0);
  180acc:	01000074 	movhi	r4,1
  180ad0:	21201804 	addi	r4,r4,-32672
  180ad4:	0182d580 	call	182d58 <alt_avalon_sgdma_check_descriptor_status>
  180ad8:	103ffc1e 	bne	r2,zero,180acc <tx_ethernet_isr+0x8c>

}
  180adc:	dfc00717 	ldw	ra,28(sp)
  180ae0:	dc800617 	ldw	r18,24(sp)
  180ae4:	dc400517 	ldw	r17,20(sp)
  180ae8:	dc000417 	ldw	r16,16(sp)
  180aec:	dec00804 	addi	sp,sp,32
  180af0:	f800283a 	ret

00180af4 <__adddf3>:
  180af4:	02c00434 	movhi	r11,16
  180af8:	5affffc4 	addi	r11,r11,-1
  180afc:	2806d7fa 	srli	r3,r5,31
  180b00:	2ad4703a 	and	r10,r5,r11
  180b04:	3ad2703a 	and	r9,r7,r11
  180b08:	3804d53a 	srli	r2,r7,20
  180b0c:	3018d77a 	srli	r12,r6,29
  180b10:	280ad53a 	srli	r5,r5,20
  180b14:	501490fa 	slli	r10,r10,3
  180b18:	2010d77a 	srli	r8,r4,29
  180b1c:	481290fa 	slli	r9,r9,3
  180b20:	380ed7fa 	srli	r7,r7,31
  180b24:	defffb04 	addi	sp,sp,-20
  180b28:	dc800215 	stw	r18,8(sp)
  180b2c:	dc400115 	stw	r17,4(sp)
  180b30:	dc000015 	stw	r16,0(sp)
  180b34:	dfc00415 	stw	ra,16(sp)
  180b38:	dcc00315 	stw	r19,12(sp)
  180b3c:	1c803fcc 	andi	r18,r3,255
  180b40:	2c01ffcc 	andi	r16,r5,2047
  180b44:	5210b03a 	or	r8,r10,r8
  180b48:	202290fa 	slli	r17,r4,3
  180b4c:	1081ffcc 	andi	r2,r2,2047
  180b50:	4b12b03a 	or	r9,r9,r12
  180b54:	300c90fa 	slli	r6,r6,3
  180b58:	91c07526 	beq	r18,r7,180d30 <__adddf3+0x23c>
  180b5c:	8087c83a 	sub	r3,r16,r2
  180b60:	00c0ab0e 	bge	zero,r3,180e10 <__adddf3+0x31c>
  180b64:	10002a1e 	bne	r2,zero,180c10 <__adddf3+0x11c>
  180b68:	4984b03a 	or	r2,r9,r6
  180b6c:	1000961e 	bne	r2,zero,180dc8 <__adddf3+0x2d4>
  180b70:	888001cc 	andi	r2,r17,7
  180b74:	10000726 	beq	r2,zero,180b94 <__adddf3+0xa0>
  180b78:	888003cc 	andi	r2,r17,15
  180b7c:	00c00104 	movi	r3,4
  180b80:	10c00426 	beq	r2,r3,180b94 <__adddf3+0xa0>
  180b84:	88c7883a 	add	r3,r17,r3
  180b88:	1c63803a 	cmpltu	r17,r3,r17
  180b8c:	4451883a 	add	r8,r8,r17
  180b90:	1823883a 	mov	r17,r3
  180b94:	4080202c 	andhi	r2,r8,128
  180b98:	10005926 	beq	r2,zero,180d00 <__adddf3+0x20c>
  180b9c:	84000044 	addi	r16,r16,1
  180ba0:	0081ffc4 	movi	r2,2047
  180ba4:	8080ba26 	beq	r16,r2,180e90 <__adddf3+0x39c>
  180ba8:	00bfe034 	movhi	r2,65408
  180bac:	10bfffc4 	addi	r2,r2,-1
  180bb0:	4090703a 	and	r8,r8,r2
  180bb4:	4004977a 	slli	r2,r8,29
  180bb8:	4010927a 	slli	r8,r8,9
  180bbc:	8822d0fa 	srli	r17,r17,3
  180bc0:	8401ffcc 	andi	r16,r16,2047
  180bc4:	4010d33a 	srli	r8,r8,12
  180bc8:	9007883a 	mov	r3,r18
  180bcc:	1444b03a 	or	r2,r2,r17
  180bd0:	8401ffcc 	andi	r16,r16,2047
  180bd4:	8020953a 	slli	r16,r16,20
  180bd8:	18c03fcc 	andi	r3,r3,255
  180bdc:	01000434 	movhi	r4,16
  180be0:	213fffc4 	addi	r4,r4,-1
  180be4:	180697fa 	slli	r3,r3,31
  180be8:	4110703a 	and	r8,r8,r4
  180bec:	4410b03a 	or	r8,r8,r16
  180bf0:	40c6b03a 	or	r3,r8,r3
  180bf4:	dfc00417 	ldw	ra,16(sp)
  180bf8:	dcc00317 	ldw	r19,12(sp)
  180bfc:	dc800217 	ldw	r18,8(sp)
  180c00:	dc400117 	ldw	r17,4(sp)
  180c04:	dc000017 	ldw	r16,0(sp)
  180c08:	dec00504 	addi	sp,sp,20
  180c0c:	f800283a 	ret
  180c10:	0081ffc4 	movi	r2,2047
  180c14:	80bfd626 	beq	r16,r2,180b70 <__adddf3+0x7c>
  180c18:	4a402034 	orhi	r9,r9,128
  180c1c:	00800e04 	movi	r2,56
  180c20:	10c09f16 	blt	r2,r3,180ea0 <__adddf3+0x3ac>
  180c24:	008007c4 	movi	r2,31
  180c28:	10c0c216 	blt	r2,r3,180f34 <__adddf3+0x440>
  180c2c:	00800804 	movi	r2,32
  180c30:	10c5c83a 	sub	r2,r2,r3
  180c34:	488a983a 	sll	r5,r9,r2
  180c38:	30c8d83a 	srl	r4,r6,r3
  180c3c:	3084983a 	sll	r2,r6,r2
  180c40:	48c6d83a 	srl	r3,r9,r3
  180c44:	290cb03a 	or	r6,r5,r4
  180c48:	1004c03a 	cmpne	r2,r2,zero
  180c4c:	308cb03a 	or	r6,r6,r2
  180c50:	898dc83a 	sub	r6,r17,r6
  180c54:	89a3803a 	cmpltu	r17,r17,r6
  180c58:	40d1c83a 	sub	r8,r8,r3
  180c5c:	4451c83a 	sub	r8,r8,r17
  180c60:	3023883a 	mov	r17,r6
  180c64:	4080202c 	andhi	r2,r8,128
  180c68:	10002326 	beq	r2,zero,180cf8 <__adddf3+0x204>
  180c6c:	04c02034 	movhi	r19,128
  180c70:	9cffffc4 	addi	r19,r19,-1
  180c74:	44e6703a 	and	r19,r8,r19
  180c78:	98007626 	beq	r19,zero,180e54 <__adddf3+0x360>
  180c7c:	9809883a 	mov	r4,r19
  180c80:	0181d680 	call	181d68 <__clzsi2>
  180c84:	10fffe04 	addi	r3,r2,-8
  180c88:	010007c4 	movi	r4,31
  180c8c:	20c07716 	blt	r4,r3,180e6c <__adddf3+0x378>
  180c90:	00800804 	movi	r2,32
  180c94:	10c5c83a 	sub	r2,r2,r3
  180c98:	8884d83a 	srl	r2,r17,r2
  180c9c:	98d0983a 	sll	r8,r19,r3
  180ca0:	88e2983a 	sll	r17,r17,r3
  180ca4:	1204b03a 	or	r2,r2,r8
  180ca8:	1c007416 	blt	r3,r16,180e7c <__adddf3+0x388>
  180cac:	1c21c83a 	sub	r16,r3,r16
  180cb0:	82000044 	addi	r8,r16,1
  180cb4:	00c007c4 	movi	r3,31
  180cb8:	1a009116 	blt	r3,r8,180f00 <__adddf3+0x40c>
  180cbc:	00c00804 	movi	r3,32
  180cc0:	1a07c83a 	sub	r3,r3,r8
  180cc4:	8a08d83a 	srl	r4,r17,r8
  180cc8:	88e2983a 	sll	r17,r17,r3
  180ccc:	10c6983a 	sll	r3,r2,r3
  180cd0:	1210d83a 	srl	r8,r2,r8
  180cd4:	8804c03a 	cmpne	r2,r17,zero
  180cd8:	1906b03a 	or	r3,r3,r4
  180cdc:	18a2b03a 	or	r17,r3,r2
  180ce0:	0021883a 	mov	r16,zero
  180ce4:	003fa206 	br	180b70 <__adddf3+0x7c>
  180ce8:	1890b03a 	or	r8,r3,r2
  180cec:	40017d26 	beq	r8,zero,1812e4 <__adddf3+0x7f0>
  180cf0:	1011883a 	mov	r8,r2
  180cf4:	1823883a 	mov	r17,r3
  180cf8:	888001cc 	andi	r2,r17,7
  180cfc:	103f9e1e 	bne	r2,zero,180b78 <__adddf3+0x84>
  180d00:	4004977a 	slli	r2,r8,29
  180d04:	8822d0fa 	srli	r17,r17,3
  180d08:	4010d0fa 	srli	r8,r8,3
  180d0c:	9007883a 	mov	r3,r18
  180d10:	1444b03a 	or	r2,r2,r17
  180d14:	0101ffc4 	movi	r4,2047
  180d18:	81002426 	beq	r16,r4,180dac <__adddf3+0x2b8>
  180d1c:	8120703a 	and	r16,r16,r4
  180d20:	01000434 	movhi	r4,16
  180d24:	213fffc4 	addi	r4,r4,-1
  180d28:	4110703a 	and	r8,r8,r4
  180d2c:	003fa806 	br	180bd0 <__adddf3+0xdc>
  180d30:	8089c83a 	sub	r4,r16,r2
  180d34:	01005e0e 	bge	zero,r4,180eb0 <__adddf3+0x3bc>
  180d38:	10002b26 	beq	r2,zero,180de8 <__adddf3+0x2f4>
  180d3c:	0081ffc4 	movi	r2,2047
  180d40:	80bf8b26 	beq	r16,r2,180b70 <__adddf3+0x7c>
  180d44:	4a402034 	orhi	r9,r9,128
  180d48:	00800e04 	movi	r2,56
  180d4c:	1100a40e 	bge	r2,r4,180fe0 <__adddf3+0x4ec>
  180d50:	498cb03a 	or	r6,r9,r6
  180d54:	300ac03a 	cmpne	r5,r6,zero
  180d58:	0013883a 	mov	r9,zero
  180d5c:	2c4b883a 	add	r5,r5,r17
  180d60:	2c63803a 	cmpltu	r17,r5,r17
  180d64:	4a11883a 	add	r8,r9,r8
  180d68:	8a11883a 	add	r8,r17,r8
  180d6c:	2823883a 	mov	r17,r5
  180d70:	4080202c 	andhi	r2,r8,128
  180d74:	103fe026 	beq	r2,zero,180cf8 <__adddf3+0x204>
  180d78:	84000044 	addi	r16,r16,1
  180d7c:	0081ffc4 	movi	r2,2047
  180d80:	8080d226 	beq	r16,r2,1810cc <__adddf3+0x5d8>
  180d84:	00bfe034 	movhi	r2,65408
  180d88:	10bfffc4 	addi	r2,r2,-1
  180d8c:	4090703a 	and	r8,r8,r2
  180d90:	880ad07a 	srli	r5,r17,1
  180d94:	400897fa 	slli	r4,r8,31
  180d98:	88c0004c 	andi	r3,r17,1
  180d9c:	28e2b03a 	or	r17,r5,r3
  180da0:	4010d07a 	srli	r8,r8,1
  180da4:	2462b03a 	or	r17,r4,r17
  180da8:	003f7106 	br	180b70 <__adddf3+0x7c>
  180dac:	4088b03a 	or	r4,r8,r2
  180db0:	20014526 	beq	r4,zero,1812c8 <__adddf3+0x7d4>
  180db4:	01000434 	movhi	r4,16
  180db8:	42000234 	orhi	r8,r8,8
  180dbc:	213fffc4 	addi	r4,r4,-1
  180dc0:	4110703a 	and	r8,r8,r4
  180dc4:	003f8206 	br	180bd0 <__adddf3+0xdc>
  180dc8:	18ffffc4 	addi	r3,r3,-1
  180dcc:	1800491e 	bne	r3,zero,180ef4 <__adddf3+0x400>
  180dd0:	898bc83a 	sub	r5,r17,r6
  180dd4:	8963803a 	cmpltu	r17,r17,r5
  180dd8:	4251c83a 	sub	r8,r8,r9
  180ddc:	4451c83a 	sub	r8,r8,r17
  180de0:	2823883a 	mov	r17,r5
  180de4:	003f9f06 	br	180c64 <__adddf3+0x170>
  180de8:	4984b03a 	or	r2,r9,r6
  180dec:	103f6026 	beq	r2,zero,180b70 <__adddf3+0x7c>
  180df0:	213fffc4 	addi	r4,r4,-1
  180df4:	2000931e 	bne	r4,zero,181044 <__adddf3+0x550>
  180df8:	898d883a 	add	r6,r17,r6
  180dfc:	3463803a 	cmpltu	r17,r6,r17
  180e00:	4251883a 	add	r8,r8,r9
  180e04:	8a11883a 	add	r8,r17,r8
  180e08:	3023883a 	mov	r17,r6
  180e0c:	003fd806 	br	180d70 <__adddf3+0x27c>
  180e10:	1800541e 	bne	r3,zero,180f64 <__adddf3+0x470>
  180e14:	80800044 	addi	r2,r16,1
  180e18:	1081ffcc 	andi	r2,r2,2047
  180e1c:	00c00044 	movi	r3,1
  180e20:	1880a00e 	bge	r3,r2,1810a4 <__adddf3+0x5b0>
  180e24:	8989c83a 	sub	r4,r17,r6
  180e28:	8905803a 	cmpltu	r2,r17,r4
  180e2c:	4267c83a 	sub	r19,r8,r9
  180e30:	98a7c83a 	sub	r19,r19,r2
  180e34:	9880202c 	andhi	r2,r19,128
  180e38:	10006326 	beq	r2,zero,180fc8 <__adddf3+0x4d4>
  180e3c:	3463c83a 	sub	r17,r6,r17
  180e40:	4a07c83a 	sub	r3,r9,r8
  180e44:	344d803a 	cmpltu	r6,r6,r17
  180e48:	19a7c83a 	sub	r19,r3,r6
  180e4c:	3825883a 	mov	r18,r7
  180e50:	983f8a1e 	bne	r19,zero,180c7c <__adddf3+0x188>
  180e54:	8809883a 	mov	r4,r17
  180e58:	0181d680 	call	181d68 <__clzsi2>
  180e5c:	10800804 	addi	r2,r2,32
  180e60:	10fffe04 	addi	r3,r2,-8
  180e64:	010007c4 	movi	r4,31
  180e68:	20ff890e 	bge	r4,r3,180c90 <__adddf3+0x19c>
  180e6c:	10bff604 	addi	r2,r2,-40
  180e70:	8884983a 	sll	r2,r17,r2
  180e74:	0023883a 	mov	r17,zero
  180e78:	1c3f8c0e 	bge	r3,r16,180cac <__adddf3+0x1b8>
  180e7c:	023fe034 	movhi	r8,65408
  180e80:	423fffc4 	addi	r8,r8,-1
  180e84:	80e1c83a 	sub	r16,r16,r3
  180e88:	1210703a 	and	r8,r2,r8
  180e8c:	003f3806 	br	180b70 <__adddf3+0x7c>
  180e90:	9007883a 	mov	r3,r18
  180e94:	0011883a 	mov	r8,zero
  180e98:	0005883a 	mov	r2,zero
  180e9c:	003f4c06 	br	180bd0 <__adddf3+0xdc>
  180ea0:	498cb03a 	or	r6,r9,r6
  180ea4:	300cc03a 	cmpne	r6,r6,zero
  180ea8:	0007883a 	mov	r3,zero
  180eac:	003f6806 	br	180c50 <__adddf3+0x15c>
  180eb0:	20009c1e 	bne	r4,zero,181124 <__adddf3+0x630>
  180eb4:	80800044 	addi	r2,r16,1
  180eb8:	1141ffcc 	andi	r5,r2,2047
  180ebc:	01000044 	movi	r4,1
  180ec0:	2140670e 	bge	r4,r5,181060 <__adddf3+0x56c>
  180ec4:	0101ffc4 	movi	r4,2047
  180ec8:	11007f26 	beq	r2,r4,1810c8 <__adddf3+0x5d4>
  180ecc:	898d883a 	add	r6,r17,r6
  180ed0:	4247883a 	add	r3,r8,r9
  180ed4:	3451803a 	cmpltu	r8,r6,r17
  180ed8:	40d1883a 	add	r8,r8,r3
  180edc:	402297fa 	slli	r17,r8,31
  180ee0:	300cd07a 	srli	r6,r6,1
  180ee4:	4010d07a 	srli	r8,r8,1
  180ee8:	1021883a 	mov	r16,r2
  180eec:	89a2b03a 	or	r17,r17,r6
  180ef0:	003f1f06 	br	180b70 <__adddf3+0x7c>
  180ef4:	0081ffc4 	movi	r2,2047
  180ef8:	80bf481e 	bne	r16,r2,180c1c <__adddf3+0x128>
  180efc:	003f1c06 	br	180b70 <__adddf3+0x7c>
  180f00:	843ff844 	addi	r16,r16,-31
  180f04:	01000804 	movi	r4,32
  180f08:	1406d83a 	srl	r3,r2,r16
  180f0c:	41005026 	beq	r8,r4,181050 <__adddf3+0x55c>
  180f10:	01001004 	movi	r4,64
  180f14:	2211c83a 	sub	r8,r4,r8
  180f18:	1204983a 	sll	r2,r2,r8
  180f1c:	88a2b03a 	or	r17,r17,r2
  180f20:	8822c03a 	cmpne	r17,r17,zero
  180f24:	1c62b03a 	or	r17,r3,r17
  180f28:	0011883a 	mov	r8,zero
  180f2c:	0021883a 	mov	r16,zero
  180f30:	003f7106 	br	180cf8 <__adddf3+0x204>
  180f34:	193ff804 	addi	r4,r3,-32
  180f38:	00800804 	movi	r2,32
  180f3c:	4908d83a 	srl	r4,r9,r4
  180f40:	18804526 	beq	r3,r2,181058 <__adddf3+0x564>
  180f44:	00801004 	movi	r2,64
  180f48:	10c5c83a 	sub	r2,r2,r3
  180f4c:	4886983a 	sll	r3,r9,r2
  180f50:	198cb03a 	or	r6,r3,r6
  180f54:	300cc03a 	cmpne	r6,r6,zero
  180f58:	218cb03a 	or	r6,r4,r6
  180f5c:	0007883a 	mov	r3,zero
  180f60:	003f3b06 	br	180c50 <__adddf3+0x15c>
  180f64:	80002a26 	beq	r16,zero,181010 <__adddf3+0x51c>
  180f68:	0101ffc4 	movi	r4,2047
  180f6c:	11006826 	beq	r2,r4,181110 <__adddf3+0x61c>
  180f70:	00c7c83a 	sub	r3,zero,r3
  180f74:	42002034 	orhi	r8,r8,128
  180f78:	01000e04 	movi	r4,56
  180f7c:	20c07c16 	blt	r4,r3,181170 <__adddf3+0x67c>
  180f80:	010007c4 	movi	r4,31
  180f84:	20c0da16 	blt	r4,r3,1812f0 <__adddf3+0x7fc>
  180f88:	01000804 	movi	r4,32
  180f8c:	20c9c83a 	sub	r4,r4,r3
  180f90:	4114983a 	sll	r10,r8,r4
  180f94:	88cad83a 	srl	r5,r17,r3
  180f98:	8908983a 	sll	r4,r17,r4
  180f9c:	40c6d83a 	srl	r3,r8,r3
  180fa0:	5162b03a 	or	r17,r10,r5
  180fa4:	2008c03a 	cmpne	r4,r4,zero
  180fa8:	8922b03a 	or	r17,r17,r4
  180fac:	3463c83a 	sub	r17,r6,r17
  180fb0:	48c7c83a 	sub	r3,r9,r3
  180fb4:	344d803a 	cmpltu	r6,r6,r17
  180fb8:	1991c83a 	sub	r8,r3,r6
  180fbc:	1021883a 	mov	r16,r2
  180fc0:	3825883a 	mov	r18,r7
  180fc4:	003f2706 	br	180c64 <__adddf3+0x170>
  180fc8:	24d0b03a 	or	r8,r4,r19
  180fcc:	40001b1e 	bne	r8,zero,18103c <__adddf3+0x548>
  180fd0:	0005883a 	mov	r2,zero
  180fd4:	0007883a 	mov	r3,zero
  180fd8:	0021883a 	mov	r16,zero
  180fdc:	003f4d06 	br	180d14 <__adddf3+0x220>
  180fe0:	008007c4 	movi	r2,31
  180fe4:	11003c16 	blt	r2,r4,1810d8 <__adddf3+0x5e4>
  180fe8:	00800804 	movi	r2,32
  180fec:	1105c83a 	sub	r2,r2,r4
  180ff0:	488e983a 	sll	r7,r9,r2
  180ff4:	310ad83a 	srl	r5,r6,r4
  180ff8:	3084983a 	sll	r2,r6,r2
  180ffc:	4912d83a 	srl	r9,r9,r4
  181000:	394ab03a 	or	r5,r7,r5
  181004:	1004c03a 	cmpne	r2,r2,zero
  181008:	288ab03a 	or	r5,r5,r2
  18100c:	003f5306 	br	180d5c <__adddf3+0x268>
  181010:	4448b03a 	or	r4,r8,r17
  181014:	20003e26 	beq	r4,zero,181110 <__adddf3+0x61c>
  181018:	00c6303a 	nor	r3,zero,r3
  18101c:	18003a1e 	bne	r3,zero,181108 <__adddf3+0x614>
  181020:	3463c83a 	sub	r17,r6,r17
  181024:	4a07c83a 	sub	r3,r9,r8
  181028:	344d803a 	cmpltu	r6,r6,r17
  18102c:	1991c83a 	sub	r8,r3,r6
  181030:	1021883a 	mov	r16,r2
  181034:	3825883a 	mov	r18,r7
  181038:	003f0a06 	br	180c64 <__adddf3+0x170>
  18103c:	2023883a 	mov	r17,r4
  181040:	003f0d06 	br	180c78 <__adddf3+0x184>
  181044:	0081ffc4 	movi	r2,2047
  181048:	80bf3f1e 	bne	r16,r2,180d48 <__adddf3+0x254>
  18104c:	003ec806 	br	180b70 <__adddf3+0x7c>
  181050:	0005883a 	mov	r2,zero
  181054:	003fb106 	br	180f1c <__adddf3+0x428>
  181058:	0007883a 	mov	r3,zero
  18105c:	003fbc06 	br	180f50 <__adddf3+0x45c>
  181060:	4444b03a 	or	r2,r8,r17
  181064:	8000871e 	bne	r16,zero,181284 <__adddf3+0x790>
  181068:	1000ba26 	beq	r2,zero,181354 <__adddf3+0x860>
  18106c:	4984b03a 	or	r2,r9,r6
  181070:	103ebf26 	beq	r2,zero,180b70 <__adddf3+0x7c>
  181074:	8985883a 	add	r2,r17,r6
  181078:	4247883a 	add	r3,r8,r9
  18107c:	1451803a 	cmpltu	r8,r2,r17
  181080:	40d1883a 	add	r8,r8,r3
  181084:	40c0202c 	andhi	r3,r8,128
  181088:	1023883a 	mov	r17,r2
  18108c:	183f1a26 	beq	r3,zero,180cf8 <__adddf3+0x204>
  181090:	00bfe034 	movhi	r2,65408
  181094:	10bfffc4 	addi	r2,r2,-1
  181098:	2021883a 	mov	r16,r4
  18109c:	4090703a 	and	r8,r8,r2
  1810a0:	003eb306 	br	180b70 <__adddf3+0x7c>
  1810a4:	4444b03a 	or	r2,r8,r17
  1810a8:	8000291e 	bne	r16,zero,181150 <__adddf3+0x65c>
  1810ac:	10004b1e 	bne	r2,zero,1811dc <__adddf3+0x6e8>
  1810b0:	4990b03a 	or	r8,r9,r6
  1810b4:	40008b26 	beq	r8,zero,1812e4 <__adddf3+0x7f0>
  1810b8:	4811883a 	mov	r8,r9
  1810bc:	3023883a 	mov	r17,r6
  1810c0:	3825883a 	mov	r18,r7
  1810c4:	003eaa06 	br	180b70 <__adddf3+0x7c>
  1810c8:	1021883a 	mov	r16,r2
  1810cc:	0011883a 	mov	r8,zero
  1810d0:	0005883a 	mov	r2,zero
  1810d4:	003f0f06 	br	180d14 <__adddf3+0x220>
  1810d8:	217ff804 	addi	r5,r4,-32
  1810dc:	00800804 	movi	r2,32
  1810e0:	494ad83a 	srl	r5,r9,r5
  1810e4:	20807d26 	beq	r4,r2,1812dc <__adddf3+0x7e8>
  1810e8:	00801004 	movi	r2,64
  1810ec:	1109c83a 	sub	r4,r2,r4
  1810f0:	4912983a 	sll	r9,r9,r4
  1810f4:	498cb03a 	or	r6,r9,r6
  1810f8:	300cc03a 	cmpne	r6,r6,zero
  1810fc:	298ab03a 	or	r5,r5,r6
  181100:	0013883a 	mov	r9,zero
  181104:	003f1506 	br	180d5c <__adddf3+0x268>
  181108:	0101ffc4 	movi	r4,2047
  18110c:	113f9a1e 	bne	r2,r4,180f78 <__adddf3+0x484>
  181110:	4811883a 	mov	r8,r9
  181114:	3023883a 	mov	r17,r6
  181118:	1021883a 	mov	r16,r2
  18111c:	3825883a 	mov	r18,r7
  181120:	003e9306 	br	180b70 <__adddf3+0x7c>
  181124:	8000161e 	bne	r16,zero,181180 <__adddf3+0x68c>
  181128:	444ab03a 	or	r5,r8,r17
  18112c:	28005126 	beq	r5,zero,181274 <__adddf3+0x780>
  181130:	0108303a 	nor	r4,zero,r4
  181134:	20004d1e 	bne	r4,zero,18126c <__adddf3+0x778>
  181138:	89a3883a 	add	r17,r17,r6
  18113c:	4253883a 	add	r9,r8,r9
  181140:	898d803a 	cmpltu	r6,r17,r6
  181144:	3251883a 	add	r8,r6,r9
  181148:	1021883a 	mov	r16,r2
  18114c:	003f0806 	br	180d70 <__adddf3+0x27c>
  181150:	1000301e 	bne	r2,zero,181214 <__adddf3+0x720>
  181154:	4984b03a 	or	r2,r9,r6
  181158:	10007126 	beq	r2,zero,181320 <__adddf3+0x82c>
  18115c:	4811883a 	mov	r8,r9
  181160:	3023883a 	mov	r17,r6
  181164:	3825883a 	mov	r18,r7
  181168:	0401ffc4 	movi	r16,2047
  18116c:	003e8006 	br	180b70 <__adddf3+0x7c>
  181170:	4462b03a 	or	r17,r8,r17
  181174:	8822c03a 	cmpne	r17,r17,zero
  181178:	0007883a 	mov	r3,zero
  18117c:	003f8b06 	br	180fac <__adddf3+0x4b8>
  181180:	0141ffc4 	movi	r5,2047
  181184:	11403b26 	beq	r2,r5,181274 <__adddf3+0x780>
  181188:	0109c83a 	sub	r4,zero,r4
  18118c:	42002034 	orhi	r8,r8,128
  181190:	01400e04 	movi	r5,56
  181194:	29006716 	blt	r5,r4,181334 <__adddf3+0x840>
  181198:	014007c4 	movi	r5,31
  18119c:	29007016 	blt	r5,r4,181360 <__adddf3+0x86c>
  1811a0:	01400804 	movi	r5,32
  1811a4:	290bc83a 	sub	r5,r5,r4
  1811a8:	4154983a 	sll	r10,r8,r5
  1811ac:	890ed83a 	srl	r7,r17,r4
  1811b0:	894a983a 	sll	r5,r17,r5
  1811b4:	4108d83a 	srl	r4,r8,r4
  1811b8:	51e2b03a 	or	r17,r10,r7
  1811bc:	280ac03a 	cmpne	r5,r5,zero
  1811c0:	8962b03a 	or	r17,r17,r5
  1811c4:	89a3883a 	add	r17,r17,r6
  1811c8:	2253883a 	add	r9,r4,r9
  1811cc:	898d803a 	cmpltu	r6,r17,r6
  1811d0:	3251883a 	add	r8,r6,r9
  1811d4:	1021883a 	mov	r16,r2
  1811d8:	003ee506 	br	180d70 <__adddf3+0x27c>
  1811dc:	4984b03a 	or	r2,r9,r6
  1811e0:	103e6326 	beq	r2,zero,180b70 <__adddf3+0x7c>
  1811e4:	8987c83a 	sub	r3,r17,r6
  1811e8:	88c9803a 	cmpltu	r4,r17,r3
  1811ec:	4245c83a 	sub	r2,r8,r9
  1811f0:	1105c83a 	sub	r2,r2,r4
  1811f4:	1100202c 	andhi	r4,r2,128
  1811f8:	203ebb26 	beq	r4,zero,180ce8 <__adddf3+0x1f4>
  1811fc:	3463c83a 	sub	r17,r6,r17
  181200:	4a07c83a 	sub	r3,r9,r8
  181204:	344d803a 	cmpltu	r6,r6,r17
  181208:	1991c83a 	sub	r8,r3,r6
  18120c:	3825883a 	mov	r18,r7
  181210:	003e5706 	br	180b70 <__adddf3+0x7c>
  181214:	4984b03a 	or	r2,r9,r6
  181218:	10002e26 	beq	r2,zero,1812d4 <__adddf3+0x7e0>
  18121c:	4004d0fa 	srli	r2,r8,3
  181220:	8822d0fa 	srli	r17,r17,3
  181224:	4010977a 	slli	r8,r8,29
  181228:	10c0022c 	andhi	r3,r2,8
  18122c:	4462b03a 	or	r17,r8,r17
  181230:	18000826 	beq	r3,zero,181254 <__adddf3+0x760>
  181234:	4808d0fa 	srli	r4,r9,3
  181238:	20c0022c 	andhi	r3,r4,8
  18123c:	1800051e 	bne	r3,zero,181254 <__adddf3+0x760>
  181240:	300cd0fa 	srli	r6,r6,3
  181244:	4806977a 	slli	r3,r9,29
  181248:	2005883a 	mov	r2,r4
  18124c:	3825883a 	mov	r18,r7
  181250:	19a2b03a 	or	r17,r3,r6
  181254:	8810d77a 	srli	r8,r17,29
  181258:	100490fa 	slli	r2,r2,3
  18125c:	882290fa 	slli	r17,r17,3
  181260:	0401ffc4 	movi	r16,2047
  181264:	4090b03a 	or	r8,r8,r2
  181268:	003e4106 	br	180b70 <__adddf3+0x7c>
  18126c:	0141ffc4 	movi	r5,2047
  181270:	117fc71e 	bne	r2,r5,181190 <__adddf3+0x69c>
  181274:	4811883a 	mov	r8,r9
  181278:	3023883a 	mov	r17,r6
  18127c:	1021883a 	mov	r16,r2
  181280:	003e3b06 	br	180b70 <__adddf3+0x7c>
  181284:	10002f26 	beq	r2,zero,181344 <__adddf3+0x850>
  181288:	4984b03a 	or	r2,r9,r6
  18128c:	10001126 	beq	r2,zero,1812d4 <__adddf3+0x7e0>
  181290:	4004d0fa 	srli	r2,r8,3
  181294:	8822d0fa 	srli	r17,r17,3
  181298:	4010977a 	slli	r8,r8,29
  18129c:	10c0022c 	andhi	r3,r2,8
  1812a0:	4462b03a 	or	r17,r8,r17
  1812a4:	183feb26 	beq	r3,zero,181254 <__adddf3+0x760>
  1812a8:	4808d0fa 	srli	r4,r9,3
  1812ac:	20c0022c 	andhi	r3,r4,8
  1812b0:	183fe81e 	bne	r3,zero,181254 <__adddf3+0x760>
  1812b4:	300cd0fa 	srli	r6,r6,3
  1812b8:	4806977a 	slli	r3,r9,29
  1812bc:	2005883a 	mov	r2,r4
  1812c0:	19a2b03a 	or	r17,r3,r6
  1812c4:	003fe306 	br	181254 <__adddf3+0x760>
  1812c8:	0011883a 	mov	r8,zero
  1812cc:	0005883a 	mov	r2,zero
  1812d0:	003e3f06 	br	180bd0 <__adddf3+0xdc>
  1812d4:	0401ffc4 	movi	r16,2047
  1812d8:	003e2506 	br	180b70 <__adddf3+0x7c>
  1812dc:	0013883a 	mov	r9,zero
  1812e0:	003f8406 	br	1810f4 <__adddf3+0x600>
  1812e4:	0005883a 	mov	r2,zero
  1812e8:	0007883a 	mov	r3,zero
  1812ec:	003e8906 	br	180d14 <__adddf3+0x220>
  1812f0:	197ff804 	addi	r5,r3,-32
  1812f4:	01000804 	movi	r4,32
  1812f8:	414ad83a 	srl	r5,r8,r5
  1812fc:	19002426 	beq	r3,r4,181390 <__adddf3+0x89c>
  181300:	01001004 	movi	r4,64
  181304:	20c7c83a 	sub	r3,r4,r3
  181308:	40c6983a 	sll	r3,r8,r3
  18130c:	1c46b03a 	or	r3,r3,r17
  181310:	1806c03a 	cmpne	r3,r3,zero
  181314:	28e2b03a 	or	r17,r5,r3
  181318:	0007883a 	mov	r3,zero
  18131c:	003f2306 	br	180fac <__adddf3+0x4b8>
  181320:	0007883a 	mov	r3,zero
  181324:	5811883a 	mov	r8,r11
  181328:	00bfffc4 	movi	r2,-1
  18132c:	0401ffc4 	movi	r16,2047
  181330:	003e7806 	br	180d14 <__adddf3+0x220>
  181334:	4462b03a 	or	r17,r8,r17
  181338:	8822c03a 	cmpne	r17,r17,zero
  18133c:	0009883a 	mov	r4,zero
  181340:	003fa006 	br	1811c4 <__adddf3+0x6d0>
  181344:	4811883a 	mov	r8,r9
  181348:	3023883a 	mov	r17,r6
  18134c:	0401ffc4 	movi	r16,2047
  181350:	003e0706 	br	180b70 <__adddf3+0x7c>
  181354:	4811883a 	mov	r8,r9
  181358:	3023883a 	mov	r17,r6
  18135c:	003e0406 	br	180b70 <__adddf3+0x7c>
  181360:	21fff804 	addi	r7,r4,-32
  181364:	01400804 	movi	r5,32
  181368:	41ced83a 	srl	r7,r8,r7
  18136c:	21400a26 	beq	r4,r5,181398 <__adddf3+0x8a4>
  181370:	01401004 	movi	r5,64
  181374:	2909c83a 	sub	r4,r5,r4
  181378:	4108983a 	sll	r4,r8,r4
  18137c:	2448b03a 	or	r4,r4,r17
  181380:	2008c03a 	cmpne	r4,r4,zero
  181384:	3922b03a 	or	r17,r7,r4
  181388:	0009883a 	mov	r4,zero
  18138c:	003f8d06 	br	1811c4 <__adddf3+0x6d0>
  181390:	0007883a 	mov	r3,zero
  181394:	003fdd06 	br	18130c <__adddf3+0x818>
  181398:	0009883a 	mov	r4,zero
  18139c:	003ff706 	br	18137c <__adddf3+0x888>

001813a0 <__muldf3>:
  1813a0:	deffee04 	addi	sp,sp,-72
  1813a4:	dd000c15 	stw	r20,48(sp)
  1813a8:	2828d53a 	srli	r20,r5,20
  1813ac:	ddc00f15 	stw	r23,60(sp)
  1813b0:	282ed7fa 	srli	r23,r5,31
  1813b4:	dc000815 	stw	r16,32(sp)
  1813b8:	04000434 	movhi	r16,16
  1813bc:	dcc00b15 	stw	r19,44(sp)
  1813c0:	843fffc4 	addi	r16,r16,-1
  1813c4:	dfc01115 	stw	ra,68(sp)
  1813c8:	df001015 	stw	fp,64(sp)
  1813cc:	dd800e15 	stw	r22,56(sp)
  1813d0:	dd400d15 	stw	r21,52(sp)
  1813d4:	dc800a15 	stw	r18,40(sp)
  1813d8:	dc400915 	stw	r17,36(sp)
  1813dc:	a501ffcc 	andi	r20,r20,2047
  1813e0:	2c20703a 	and	r16,r5,r16
  1813e4:	b827883a 	mov	r19,r23
  1813e8:	ba403fcc 	andi	r9,r23,255
  1813ec:	a0006026 	beq	r20,zero,181570 <__muldf3+0x1d0>
  1813f0:	0081ffc4 	movi	r2,2047
  1813f4:	202d883a 	mov	r22,r4
  1813f8:	a0803626 	beq	r20,r2,1814d4 <__muldf3+0x134>
  1813fc:	84000434 	orhi	r16,r16,16
  181400:	200ad77a 	srli	r5,r4,29
  181404:	800490fa 	slli	r2,r16,3
  181408:	202c90fa 	slli	r22,r4,3
  18140c:	a53f0044 	addi	r20,r20,-1023
  181410:	28a0b03a 	or	r16,r5,r2
  181414:	002b883a 	mov	r21,zero
  181418:	000b883a 	mov	r5,zero
  18141c:	3804d53a 	srli	r2,r7,20
  181420:	3838d7fa 	srli	fp,r7,31
  181424:	04400434 	movhi	r17,16
  181428:	8c7fffc4 	addi	r17,r17,-1
  18142c:	1081ffcc 	andi	r2,r2,2047
  181430:	3025883a 	mov	r18,r6
  181434:	3c62703a 	and	r17,r7,r17
  181438:	e2803fcc 	andi	r10,fp,255
  18143c:	10006d26 	beq	r2,zero,1815f4 <__muldf3+0x254>
  181440:	00c1ffc4 	movi	r3,2047
  181444:	10c06526 	beq	r2,r3,1815dc <__muldf3+0x23c>
  181448:	8c400434 	orhi	r17,r17,16
  18144c:	300ed77a 	srli	r7,r6,29
  181450:	880690fa 	slli	r3,r17,3
  181454:	302490fa 	slli	r18,r6,3
  181458:	10bf0044 	addi	r2,r2,-1023
  18145c:	38e2b03a 	or	r17,r7,r3
  181460:	000f883a 	mov	r7,zero
  181464:	a087883a 	add	r3,r20,r2
  181468:	010003c4 	movi	r4,15
  18146c:	3d44b03a 	or	r2,r7,r21
  181470:	e5ccf03a 	xor	r6,fp,r23
  181474:	1a000044 	addi	r8,r3,1
  181478:	20809b36 	bltu	r4,r2,1816e8 <__muldf3+0x348>
  18147c:	100490ba 	slli	r2,r2,2
  181480:	01000634 	movhi	r4,24
  181484:	21052504 	addi	r4,r4,5268
  181488:	1105883a 	add	r2,r2,r4
  18148c:	10800017 	ldw	r2,0(r2)
  181490:	1000683a 	jmp	r2
  181494:	001816e8 	cmpgeui	zero,zero,24667
  181498:	001814f4 	movhi	zero,24659
  18149c:	001814f4 	movhi	zero,24659
  1814a0:	001814f0 	cmpltui	zero,zero,24659
  1814a4:	001816c4 	movi	zero,24667
  1814a8:	001816c4 	movi	zero,24667
  1814ac:	001816ac 	andhi	zero,zero,24666
  1814b0:	001814f0 	cmpltui	zero,zero,24659
  1814b4:	001816c4 	movi	zero,24667
  1814b8:	001816ac 	andhi	zero,zero,24666
  1814bc:	001816c4 	movi	zero,24667
  1814c0:	001814f0 	cmpltui	zero,zero,24659
  1814c4:	001816d4 	movui	zero,24667
  1814c8:	001816d4 	movui	zero,24667
  1814cc:	001816d4 	movui	zero,24667
  1814d0:	00181a34 	movhi	zero,24680
  1814d4:	2404b03a 	or	r2,r4,r16
  1814d8:	1000711e 	bne	r2,zero,1816a0 <__muldf3+0x300>
  1814dc:	05400204 	movi	r21,8
  1814e0:	0021883a 	mov	r16,zero
  1814e4:	002d883a 	mov	r22,zero
  1814e8:	01400084 	movi	r5,2
  1814ec:	003fcb06 	br	18141c <__muldf3+0x7c>
  1814f0:	500d883a 	mov	r6,r10
  1814f4:	00800084 	movi	r2,2
  1814f8:	38805926 	beq	r7,r2,181660 <__muldf3+0x2c0>
  1814fc:	008000c4 	movi	r2,3
  181500:	3881bb26 	beq	r7,r2,181bf0 <__muldf3+0x850>
  181504:	00800044 	movi	r2,1
  181508:	3881961e 	bne	r7,r2,181b64 <__muldf3+0x7c4>
  18150c:	3027883a 	mov	r19,r6
  181510:	0005883a 	mov	r2,zero
  181514:	0021883a 	mov	r16,zero
  181518:	002d883a 	mov	r22,zero
  18151c:	1004953a 	slli	r2,r2,20
  181520:	98c03fcc 	andi	r3,r19,255
  181524:	04400434 	movhi	r17,16
  181528:	8c7fffc4 	addi	r17,r17,-1
  18152c:	180697fa 	slli	r3,r3,31
  181530:	8460703a 	and	r16,r16,r17
  181534:	80a0b03a 	or	r16,r16,r2
  181538:	80c6b03a 	or	r3,r16,r3
  18153c:	b005883a 	mov	r2,r22
  181540:	dfc01117 	ldw	ra,68(sp)
  181544:	df001017 	ldw	fp,64(sp)
  181548:	ddc00f17 	ldw	r23,60(sp)
  18154c:	dd800e17 	ldw	r22,56(sp)
  181550:	dd400d17 	ldw	r21,52(sp)
  181554:	dd000c17 	ldw	r20,48(sp)
  181558:	dcc00b17 	ldw	r19,44(sp)
  18155c:	dc800a17 	ldw	r18,40(sp)
  181560:	dc400917 	ldw	r17,36(sp)
  181564:	dc000817 	ldw	r16,32(sp)
  181568:	dec01204 	addi	sp,sp,72
  18156c:	f800283a 	ret
  181570:	2404b03a 	or	r2,r4,r16
  181574:	202b883a 	mov	r21,r4
  181578:	10004426 	beq	r2,zero,18168c <__muldf3+0x2ec>
  18157c:	80015126 	beq	r16,zero,181ac4 <__muldf3+0x724>
  181580:	8009883a 	mov	r4,r16
  181584:	d9800715 	stw	r6,28(sp)
  181588:	d9c00215 	stw	r7,8(sp)
  18158c:	da400415 	stw	r9,16(sp)
  181590:	0181d680 	call	181d68 <__clzsi2>
  181594:	d9800717 	ldw	r6,28(sp)
  181598:	d9c00217 	ldw	r7,8(sp)
  18159c:	da400417 	ldw	r9,16(sp)
  1815a0:	113ffd44 	addi	r4,r2,-11
  1815a4:	00c00704 	movi	r3,28
  1815a8:	19014216 	blt	r3,r4,181ab4 <__muldf3+0x714>
  1815ac:	00c00744 	movi	r3,29
  1815b0:	15bffe04 	addi	r22,r2,-8
  1815b4:	1907c83a 	sub	r3,r3,r4
  1815b8:	85a0983a 	sll	r16,r16,r22
  1815bc:	a8c6d83a 	srl	r3,r21,r3
  1815c0:	adac983a 	sll	r22,r21,r22
  1815c4:	1c20b03a 	or	r16,r3,r16
  1815c8:	1080fcc4 	addi	r2,r2,1011
  1815cc:	00a9c83a 	sub	r20,zero,r2
  1815d0:	002b883a 	mov	r21,zero
  1815d4:	000b883a 	mov	r5,zero
  1815d8:	003f9006 	br	18141c <__muldf3+0x7c>
  1815dc:	3446b03a 	or	r3,r6,r17
  1815e0:	1800281e 	bne	r3,zero,181684 <__muldf3+0x2e4>
  1815e4:	0023883a 	mov	r17,zero
  1815e8:	0025883a 	mov	r18,zero
  1815ec:	01c00084 	movi	r7,2
  1815f0:	003f9c06 	br	181464 <__muldf3+0xc4>
  1815f4:	3446b03a 	or	r3,r6,r17
  1815f8:	18001e26 	beq	r3,zero,181674 <__muldf3+0x2d4>
  1815fc:	88012126 	beq	r17,zero,181a84 <__muldf3+0x6e4>
  181600:	8809883a 	mov	r4,r17
  181604:	d9400215 	stw	r5,8(sp)
  181608:	d9800715 	stw	r6,28(sp)
  18160c:	da400415 	stw	r9,16(sp)
  181610:	da800315 	stw	r10,12(sp)
  181614:	0181d680 	call	181d68 <__clzsi2>
  181618:	d9400217 	ldw	r5,8(sp)
  18161c:	d9800717 	ldw	r6,28(sp)
  181620:	da400417 	ldw	r9,16(sp)
  181624:	da800317 	ldw	r10,12(sp)
  181628:	113ffd44 	addi	r4,r2,-11
  18162c:	00c00704 	movi	r3,28
  181630:	19011016 	blt	r3,r4,181a74 <__muldf3+0x6d4>
  181634:	00c00744 	movi	r3,29
  181638:	14bffe04 	addi	r18,r2,-8
  18163c:	1907c83a 	sub	r3,r3,r4
  181640:	8ca2983a 	sll	r17,r17,r18
  181644:	30c6d83a 	srl	r3,r6,r3
  181648:	34a4983a 	sll	r18,r6,r18
  18164c:	1c62b03a 	or	r17,r3,r17
  181650:	1080fcc4 	addi	r2,r2,1011
  181654:	0085c83a 	sub	r2,zero,r2
  181658:	000f883a 	mov	r7,zero
  18165c:	003f8106 	br	181464 <__muldf3+0xc4>
  181660:	3027883a 	mov	r19,r6
  181664:	0081ffc4 	movi	r2,2047
  181668:	0021883a 	mov	r16,zero
  18166c:	002d883a 	mov	r22,zero
  181670:	003faa06 	br	18151c <__muldf3+0x17c>
  181674:	0023883a 	mov	r17,zero
  181678:	0025883a 	mov	r18,zero
  18167c:	01c00044 	movi	r7,1
  181680:	003f7806 	br	181464 <__muldf3+0xc4>
  181684:	01c000c4 	movi	r7,3
  181688:	003f7606 	br	181464 <__muldf3+0xc4>
  18168c:	05400104 	movi	r21,4
  181690:	0021883a 	mov	r16,zero
  181694:	002d883a 	mov	r22,zero
  181698:	01400044 	movi	r5,1
  18169c:	003f5f06 	br	18141c <__muldf3+0x7c>
  1816a0:	05400304 	movi	r21,12
  1816a4:	014000c4 	movi	r5,3
  1816a8:	003f5c06 	br	18141c <__muldf3+0x7c>
  1816ac:	04000434 	movhi	r16,16
  1816b0:	0027883a 	mov	r19,zero
  1816b4:	843fffc4 	addi	r16,r16,-1
  1816b8:	05bfffc4 	movi	r22,-1
  1816bc:	0081ffc4 	movi	r2,2047
  1816c0:	003f9606 	br	18151c <__muldf3+0x17c>
  1816c4:	8023883a 	mov	r17,r16
  1816c8:	b025883a 	mov	r18,r22
  1816cc:	280f883a 	mov	r7,r5
  1816d0:	003f8806 	br	1814f4 <__muldf3+0x154>
  1816d4:	8023883a 	mov	r17,r16
  1816d8:	b025883a 	mov	r18,r22
  1816dc:	480d883a 	mov	r6,r9
  1816e0:	280f883a 	mov	r7,r5
  1816e4:	003f8306 	br	1814f4 <__muldf3+0x154>
  1816e8:	b026d43a 	srli	r19,r22,16
  1816ec:	902ed43a 	srli	r23,r18,16
  1816f0:	b5bfffcc 	andi	r22,r22,65535
  1816f4:	94bfffcc 	andi	r18,r18,65535
  1816f8:	b00b883a 	mov	r5,r22
  1816fc:	9009883a 	mov	r4,r18
  181700:	d8c00515 	stw	r3,20(sp)
  181704:	d9800715 	stw	r6,28(sp)
  181708:	da000615 	stw	r8,24(sp)
  18170c:	0181dcc0 	call	181dcc <__mulsi3>
  181710:	980b883a 	mov	r5,r19
  181714:	9009883a 	mov	r4,r18
  181718:	1029883a 	mov	r20,r2
  18171c:	0181dcc0 	call	181dcc <__mulsi3>
  181720:	b80b883a 	mov	r5,r23
  181724:	9809883a 	mov	r4,r19
  181728:	102b883a 	mov	r21,r2
  18172c:	0181dcc0 	call	181dcc <__mulsi3>
  181730:	b809883a 	mov	r4,r23
  181734:	b00b883a 	mov	r5,r22
  181738:	1039883a 	mov	fp,r2
  18173c:	0181dcc0 	call	181dcc <__mulsi3>
  181740:	a008d43a 	srli	r4,r20,16
  181744:	1545883a 	add	r2,r2,r21
  181748:	d8c00517 	ldw	r3,20(sp)
  18174c:	2085883a 	add	r2,r4,r2
  181750:	d9800717 	ldw	r6,28(sp)
  181754:	da000617 	ldw	r8,24(sp)
  181758:	1540022e 	bgeu	r2,r21,181764 <__muldf3+0x3c4>
  18175c:	01000074 	movhi	r4,1
  181760:	e139883a 	add	fp,fp,r4
  181764:	100e943a 	slli	r7,r2,16
  181768:	1004d43a 	srli	r2,r2,16
  18176c:	882ad43a 	srli	r21,r17,16
  181770:	a53fffcc 	andi	r20,r20,65535
  181774:	8c7fffcc 	andi	r17,r17,65535
  181778:	3d29883a 	add	r20,r7,r20
  18177c:	b00b883a 	mov	r5,r22
  181780:	8809883a 	mov	r4,r17
  181784:	d8c00515 	stw	r3,20(sp)
  181788:	d9800715 	stw	r6,28(sp)
  18178c:	da000615 	stw	r8,24(sp)
  181790:	dd000115 	stw	r20,4(sp)
  181794:	d8800015 	stw	r2,0(sp)
  181798:	0181dcc0 	call	181dcc <__mulsi3>
  18179c:	980b883a 	mov	r5,r19
  1817a0:	8809883a 	mov	r4,r17
  1817a4:	d8800215 	stw	r2,8(sp)
  1817a8:	0181dcc0 	call	181dcc <__mulsi3>
  1817ac:	9809883a 	mov	r4,r19
  1817b0:	a80b883a 	mov	r5,r21
  1817b4:	1029883a 	mov	r20,r2
  1817b8:	0181dcc0 	call	181dcc <__mulsi3>
  1817bc:	b00b883a 	mov	r5,r22
  1817c0:	a809883a 	mov	r4,r21
  1817c4:	d8800415 	stw	r2,16(sp)
  1817c8:	0181dcc0 	call	181dcc <__mulsi3>
  1817cc:	d9c00217 	ldw	r7,8(sp)
  1817d0:	1505883a 	add	r2,r2,r20
  1817d4:	d8c00517 	ldw	r3,20(sp)
  1817d8:	3826d43a 	srli	r19,r7,16
  1817dc:	d9800717 	ldw	r6,28(sp)
  1817e0:	da000617 	ldw	r8,24(sp)
  1817e4:	9885883a 	add	r2,r19,r2
  1817e8:	da400417 	ldw	r9,16(sp)
  1817ec:	1500022e 	bgeu	r2,r20,1817f8 <__muldf3+0x458>
  1817f0:	01000074 	movhi	r4,1
  1817f4:	4913883a 	add	r9,r9,r4
  1817f8:	1028d43a 	srli	r20,r2,16
  1817fc:	1004943a 	slli	r2,r2,16
  181800:	802cd43a 	srli	r22,r16,16
  181804:	843fffcc 	andi	r16,r16,65535
  181808:	3cffffcc 	andi	r19,r7,65535
  18180c:	9009883a 	mov	r4,r18
  181810:	800b883a 	mov	r5,r16
  181814:	a269883a 	add	r20,r20,r9
  181818:	d8c00515 	stw	r3,20(sp)
  18181c:	d9800715 	stw	r6,28(sp)
  181820:	da000615 	stw	r8,24(sp)
  181824:	14e7883a 	add	r19,r2,r19
  181828:	0181dcc0 	call	181dcc <__mulsi3>
  18182c:	9009883a 	mov	r4,r18
  181830:	b00b883a 	mov	r5,r22
  181834:	d8800315 	stw	r2,12(sp)
  181838:	0181dcc0 	call	181dcc <__mulsi3>
  18183c:	b809883a 	mov	r4,r23
  181840:	b00b883a 	mov	r5,r22
  181844:	d8800215 	stw	r2,8(sp)
  181848:	0181dcc0 	call	181dcc <__mulsi3>
  18184c:	b80b883a 	mov	r5,r23
  181850:	8009883a 	mov	r4,r16
  181854:	d8800415 	stw	r2,16(sp)
  181858:	0181dcc0 	call	181dcc <__mulsi3>
  18185c:	da800317 	ldw	r10,12(sp)
  181860:	d9c00217 	ldw	r7,8(sp)
  181864:	d9000017 	ldw	r4,0(sp)
  181868:	502ed43a 	srli	r23,r10,16
  18186c:	11c5883a 	add	r2,r2,r7
  181870:	24e5883a 	add	r18,r4,r19
  181874:	b885883a 	add	r2,r23,r2
  181878:	d8c00517 	ldw	r3,20(sp)
  18187c:	d9800717 	ldw	r6,28(sp)
  181880:	da000617 	ldw	r8,24(sp)
  181884:	da400417 	ldw	r9,16(sp)
  181888:	11c0022e 	bgeu	r2,r7,181894 <__muldf3+0x4f4>
  18188c:	01000074 	movhi	r4,1
  181890:	4913883a 	add	r9,r9,r4
  181894:	100ed43a 	srli	r7,r2,16
  181898:	1004943a 	slli	r2,r2,16
  18189c:	55ffffcc 	andi	r23,r10,65535
  1818a0:	3a53883a 	add	r9,r7,r9
  1818a4:	8809883a 	mov	r4,r17
  1818a8:	800b883a 	mov	r5,r16
  1818ac:	d8c00515 	stw	r3,20(sp)
  1818b0:	d9800715 	stw	r6,28(sp)
  1818b4:	da000615 	stw	r8,24(sp)
  1818b8:	da400415 	stw	r9,16(sp)
  1818bc:	15ef883a 	add	r23,r2,r23
  1818c0:	0181dcc0 	call	181dcc <__mulsi3>
  1818c4:	8809883a 	mov	r4,r17
  1818c8:	b00b883a 	mov	r5,r22
  1818cc:	d8800215 	stw	r2,8(sp)
  1818d0:	0181dcc0 	call	181dcc <__mulsi3>
  1818d4:	b00b883a 	mov	r5,r22
  1818d8:	a809883a 	mov	r4,r21
  1818dc:	d8800315 	stw	r2,12(sp)
  1818e0:	0181dcc0 	call	181dcc <__mulsi3>
  1818e4:	8009883a 	mov	r4,r16
  1818e8:	a80b883a 	mov	r5,r21
  1818ec:	1023883a 	mov	r17,r2
  1818f0:	0181dcc0 	call	181dcc <__mulsi3>
  1818f4:	d9c00217 	ldw	r7,8(sp)
  1818f8:	da800317 	ldw	r10,12(sp)
  1818fc:	d8c00517 	ldw	r3,20(sp)
  181900:	3808d43a 	srli	r4,r7,16
  181904:	1285883a 	add	r2,r2,r10
  181908:	d9800717 	ldw	r6,28(sp)
  18190c:	2085883a 	add	r2,r4,r2
  181910:	da000617 	ldw	r8,24(sp)
  181914:	da400417 	ldw	r9,16(sp)
  181918:	1280022e 	bgeu	r2,r10,181924 <__muldf3+0x584>
  18191c:	01000074 	movhi	r4,1
  181920:	8923883a 	add	r17,r17,r4
  181924:	1008943a 	slli	r4,r2,16
  181928:	39ffffcc 	andi	r7,r7,65535
  18192c:	e4b9883a 	add	fp,fp,r18
  181930:	21cf883a 	add	r7,r4,r7
  181934:	e4e7803a 	cmpltu	r19,fp,r19
  181938:	3d0f883a 	add	r7,r7,r20
  18193c:	bf39883a 	add	fp,r23,fp
  181940:	99c9883a 	add	r4,r19,r7
  181944:	e5ef803a 	cmpltu	r23,fp,r23
  181948:	490b883a 	add	r5,r9,r4
  18194c:	1004d43a 	srli	r2,r2,16
  181950:	b965883a 	add	r18,r23,r5
  181954:	24c9803a 	cmpltu	r4,r4,r19
  181958:	3d29803a 	cmpltu	r20,r7,r20
  18195c:	a128b03a 	or	r20,r20,r4
  181960:	95ef803a 	cmpltu	r23,r18,r23
  181964:	2a53803a 	cmpltu	r9,r5,r9
  181968:	a0a9883a 	add	r20,r20,r2
  18196c:	4deeb03a 	or	r23,r9,r23
  181970:	a5ef883a 	add	r23,r20,r23
  181974:	bc63883a 	add	r17,r23,r17
  181978:	e004927a 	slli	r2,fp,9
  18197c:	d9000117 	ldw	r4,4(sp)
  181980:	882e927a 	slli	r23,r17,9
  181984:	9022d5fa 	srli	r17,r18,23
  181988:	e038d5fa 	srli	fp,fp,23
  18198c:	1104b03a 	or	r2,r2,r4
  181990:	9024927a 	slli	r18,r18,9
  181994:	1004c03a 	cmpne	r2,r2,zero
  181998:	bc62b03a 	or	r17,r23,r17
  18199c:	1738b03a 	or	fp,r2,fp
  1819a0:	8880402c 	andhi	r2,r17,256
  1819a4:	e4a4b03a 	or	r18,fp,r18
  1819a8:	10000726 	beq	r2,zero,1819c8 <__muldf3+0x628>
  1819ac:	9006d07a 	srli	r3,r18,1
  1819b0:	880497fa 	slli	r2,r17,31
  1819b4:	9480004c 	andi	r18,r18,1
  1819b8:	8822d07a 	srli	r17,r17,1
  1819bc:	1ca4b03a 	or	r18,r3,r18
  1819c0:	14a4b03a 	or	r18,r2,r18
  1819c4:	4007883a 	mov	r3,r8
  1819c8:	1880ffc4 	addi	r2,r3,1023
  1819cc:	0080460e 	bge	zero,r2,181ae8 <__muldf3+0x748>
  1819d0:	910001cc 	andi	r4,r18,7
  1819d4:	20000726 	beq	r4,zero,1819f4 <__muldf3+0x654>
  1819d8:	910003cc 	andi	r4,r18,15
  1819dc:	01400104 	movi	r5,4
  1819e0:	21400426 	beq	r4,r5,1819f4 <__muldf3+0x654>
  1819e4:	9149883a 	add	r4,r18,r5
  1819e8:	24a5803a 	cmpltu	r18,r4,r18
  1819ec:	8ca3883a 	add	r17,r17,r18
  1819f0:	2025883a 	mov	r18,r4
  1819f4:	8900402c 	andhi	r4,r17,256
  1819f8:	20000426 	beq	r4,zero,181a0c <__muldf3+0x66c>
  1819fc:	18810004 	addi	r2,r3,1024
  181a00:	00ffc034 	movhi	r3,65280
  181a04:	18ffffc4 	addi	r3,r3,-1
  181a08:	88e2703a 	and	r17,r17,r3
  181a0c:	00c1ff84 	movi	r3,2046
  181a10:	18bf1316 	blt	r3,r2,181660 <__muldf3+0x2c0>
  181a14:	882c977a 	slli	r22,r17,29
  181a18:	9024d0fa 	srli	r18,r18,3
  181a1c:	8822927a 	slli	r17,r17,9
  181a20:	1081ffcc 	andi	r2,r2,2047
  181a24:	b4acb03a 	or	r22,r22,r18
  181a28:	8820d33a 	srli	r16,r17,12
  181a2c:	3027883a 	mov	r19,r6
  181a30:	003eba06 	br	18151c <__muldf3+0x17c>
  181a34:	8080022c 	andhi	r2,r16,8
  181a38:	10000926 	beq	r2,zero,181a60 <__muldf3+0x6c0>
  181a3c:	8880022c 	andhi	r2,r17,8
  181a40:	1000071e 	bne	r2,zero,181a60 <__muldf3+0x6c0>
  181a44:	00800434 	movhi	r2,16
  181a48:	8c000234 	orhi	r16,r17,8
  181a4c:	10bfffc4 	addi	r2,r2,-1
  181a50:	e027883a 	mov	r19,fp
  181a54:	80a0703a 	and	r16,r16,r2
  181a58:	902d883a 	mov	r22,r18
  181a5c:	003f1706 	br	1816bc <__muldf3+0x31c>
  181a60:	00800434 	movhi	r2,16
  181a64:	84000234 	orhi	r16,r16,8
  181a68:	10bfffc4 	addi	r2,r2,-1
  181a6c:	80a0703a 	and	r16,r16,r2
  181a70:	003f1206 	br	1816bc <__muldf3+0x31c>
  181a74:	147ff604 	addi	r17,r2,-40
  181a78:	3462983a 	sll	r17,r6,r17
  181a7c:	0025883a 	mov	r18,zero
  181a80:	003ef306 	br	181650 <__muldf3+0x2b0>
  181a84:	3009883a 	mov	r4,r6
  181a88:	d9400215 	stw	r5,8(sp)
  181a8c:	d9800715 	stw	r6,28(sp)
  181a90:	da400415 	stw	r9,16(sp)
  181a94:	da800315 	stw	r10,12(sp)
  181a98:	0181d680 	call	181d68 <__clzsi2>
  181a9c:	10800804 	addi	r2,r2,32
  181aa0:	da800317 	ldw	r10,12(sp)
  181aa4:	da400417 	ldw	r9,16(sp)
  181aa8:	d9800717 	ldw	r6,28(sp)
  181aac:	d9400217 	ldw	r5,8(sp)
  181ab0:	003edd06 	br	181628 <__muldf3+0x288>
  181ab4:	143ff604 	addi	r16,r2,-40
  181ab8:	ac20983a 	sll	r16,r21,r16
  181abc:	002d883a 	mov	r22,zero
  181ac0:	003ec106 	br	1815c8 <__muldf3+0x228>
  181ac4:	d9800715 	stw	r6,28(sp)
  181ac8:	d9c00215 	stw	r7,8(sp)
  181acc:	da400415 	stw	r9,16(sp)
  181ad0:	0181d680 	call	181d68 <__clzsi2>
  181ad4:	10800804 	addi	r2,r2,32
  181ad8:	da400417 	ldw	r9,16(sp)
  181adc:	d9c00217 	ldw	r7,8(sp)
  181ae0:	d9800717 	ldw	r6,28(sp)
  181ae4:	003eae06 	br	1815a0 <__muldf3+0x200>
  181ae8:	00c00044 	movi	r3,1
  181aec:	1887c83a 	sub	r3,r3,r2
  181af0:	01000e04 	movi	r4,56
  181af4:	20fe8516 	blt	r4,r3,18150c <__muldf3+0x16c>
  181af8:	010007c4 	movi	r4,31
  181afc:	20c01b16 	blt	r4,r3,181b6c <__muldf3+0x7cc>
  181b00:	00800804 	movi	r2,32
  181b04:	10c5c83a 	sub	r2,r2,r3
  181b08:	888a983a 	sll	r5,r17,r2
  181b0c:	90c8d83a 	srl	r4,r18,r3
  181b10:	9084983a 	sll	r2,r18,r2
  181b14:	88e2d83a 	srl	r17,r17,r3
  181b18:	2906b03a 	or	r3,r5,r4
  181b1c:	1004c03a 	cmpne	r2,r2,zero
  181b20:	1886b03a 	or	r3,r3,r2
  181b24:	188001cc 	andi	r2,r3,7
  181b28:	10000726 	beq	r2,zero,181b48 <__muldf3+0x7a8>
  181b2c:	188003cc 	andi	r2,r3,15
  181b30:	01000104 	movi	r4,4
  181b34:	11000426 	beq	r2,r4,181b48 <__muldf3+0x7a8>
  181b38:	1805883a 	mov	r2,r3
  181b3c:	10c00104 	addi	r3,r2,4
  181b40:	1885803a 	cmpltu	r2,r3,r2
  181b44:	88a3883a 	add	r17,r17,r2
  181b48:	8880202c 	andhi	r2,r17,128
  181b4c:	10001c26 	beq	r2,zero,181bc0 <__muldf3+0x820>
  181b50:	3027883a 	mov	r19,r6
  181b54:	00800044 	movi	r2,1
  181b58:	0021883a 	mov	r16,zero
  181b5c:	002d883a 	mov	r22,zero
  181b60:	003e6e06 	br	18151c <__muldf3+0x17c>
  181b64:	4007883a 	mov	r3,r8
  181b68:	003f9706 	br	1819c8 <__muldf3+0x628>
  181b6c:	017ff844 	movi	r5,-31
  181b70:	2885c83a 	sub	r2,r5,r2
  181b74:	888ad83a 	srl	r5,r17,r2
  181b78:	00800804 	movi	r2,32
  181b7c:	18801a26 	beq	r3,r2,181be8 <__muldf3+0x848>
  181b80:	01001004 	movi	r4,64
  181b84:	20c7c83a 	sub	r3,r4,r3
  181b88:	88e2983a 	sll	r17,r17,r3
  181b8c:	8ca4b03a 	or	r18,r17,r18
  181b90:	9004c03a 	cmpne	r2,r18,zero
  181b94:	2884b03a 	or	r2,r5,r2
  181b98:	144001cc 	andi	r17,r2,7
  181b9c:	88000d1e 	bne	r17,zero,181bd4 <__muldf3+0x834>
  181ba0:	0021883a 	mov	r16,zero
  181ba4:	102cd0fa 	srli	r22,r2,3
  181ba8:	3027883a 	mov	r19,r6
  181bac:	0005883a 	mov	r2,zero
  181bb0:	b46cb03a 	or	r22,r22,r17
  181bb4:	003e5906 	br	18151c <__muldf3+0x17c>
  181bb8:	1007883a 	mov	r3,r2
  181bbc:	0023883a 	mov	r17,zero
  181bc0:	8820927a 	slli	r16,r17,9
  181bc4:	1805883a 	mov	r2,r3
  181bc8:	8822977a 	slli	r17,r17,29
  181bcc:	8020d33a 	srli	r16,r16,12
  181bd0:	003ff406 	br	181ba4 <__muldf3+0x804>
  181bd4:	10c003cc 	andi	r3,r2,15
  181bd8:	01000104 	movi	r4,4
  181bdc:	193ff626 	beq	r3,r4,181bb8 <__muldf3+0x818>
  181be0:	0023883a 	mov	r17,zero
  181be4:	003fd506 	br	181b3c <__muldf3+0x79c>
  181be8:	0023883a 	mov	r17,zero
  181bec:	003fe706 	br	181b8c <__muldf3+0x7ec>
  181bf0:	00800434 	movhi	r2,16
  181bf4:	8c000234 	orhi	r16,r17,8
  181bf8:	10bfffc4 	addi	r2,r2,-1
  181bfc:	3027883a 	mov	r19,r6
  181c00:	80a0703a 	and	r16,r16,r2
  181c04:	902d883a 	mov	r22,r18
  181c08:	003eac06 	br	1816bc <__muldf3+0x31c>

00181c0c <__fixdfsi>:
  181c0c:	280cd53a 	srli	r6,r5,20
  181c10:	00c00434 	movhi	r3,16
  181c14:	18ffffc4 	addi	r3,r3,-1
  181c18:	3181ffcc 	andi	r6,r6,2047
  181c1c:	01c0ff84 	movi	r7,1022
  181c20:	28c6703a 	and	r3,r5,r3
  181c24:	280ad7fa 	srli	r5,r5,31
  181c28:	3980120e 	bge	r7,r6,181c74 <__fixdfsi+0x68>
  181c2c:	00810744 	movi	r2,1053
  181c30:	11800c16 	blt	r2,r6,181c64 <__fixdfsi+0x58>
  181c34:	00810cc4 	movi	r2,1075
  181c38:	1185c83a 	sub	r2,r2,r6
  181c3c:	01c007c4 	movi	r7,31
  181c40:	18c00434 	orhi	r3,r3,16
  181c44:	38800d16 	blt	r7,r2,181c7c <__fixdfsi+0x70>
  181c48:	31befb44 	addi	r6,r6,-1043
  181c4c:	2084d83a 	srl	r2,r4,r2
  181c50:	1986983a 	sll	r3,r3,r6
  181c54:	1884b03a 	or	r2,r3,r2
  181c58:	28000726 	beq	r5,zero,181c78 <__fixdfsi+0x6c>
  181c5c:	0085c83a 	sub	r2,zero,r2
  181c60:	f800283a 	ret
  181c64:	00a00034 	movhi	r2,32768
  181c68:	10bfffc4 	addi	r2,r2,-1
  181c6c:	2885883a 	add	r2,r5,r2
  181c70:	f800283a 	ret
  181c74:	0005883a 	mov	r2,zero
  181c78:	f800283a 	ret
  181c7c:	008104c4 	movi	r2,1043
  181c80:	1185c83a 	sub	r2,r2,r6
  181c84:	1884d83a 	srl	r2,r3,r2
  181c88:	003ff306 	br	181c58 <__fixdfsi+0x4c>

00181c8c <__floatsidf>:
  181c8c:	defffd04 	addi	sp,sp,-12
  181c90:	dfc00215 	stw	ra,8(sp)
  181c94:	dc400115 	stw	r17,4(sp)
  181c98:	dc000015 	stw	r16,0(sp)
  181c9c:	20002b26 	beq	r4,zero,181d4c <__floatsidf+0xc0>
  181ca0:	2023883a 	mov	r17,r4
  181ca4:	2020d7fa 	srli	r16,r4,31
  181ca8:	20002d16 	blt	r4,zero,181d60 <__floatsidf+0xd4>
  181cac:	8809883a 	mov	r4,r17
  181cb0:	0181d680 	call	181d68 <__clzsi2>
  181cb4:	01410784 	movi	r5,1054
  181cb8:	288bc83a 	sub	r5,r5,r2
  181cbc:	01010cc4 	movi	r4,1075
  181cc0:	2149c83a 	sub	r4,r4,r5
  181cc4:	00c007c4 	movi	r3,31
  181cc8:	1900160e 	bge	r3,r4,181d24 <__floatsidf+0x98>
  181ccc:	00c104c4 	movi	r3,1043
  181cd0:	1947c83a 	sub	r3,r3,r5
  181cd4:	88c6983a 	sll	r3,r17,r3
  181cd8:	00800434 	movhi	r2,16
  181cdc:	10bfffc4 	addi	r2,r2,-1
  181ce0:	1886703a 	and	r3,r3,r2
  181ce4:	2941ffcc 	andi	r5,r5,2047
  181ce8:	800d883a 	mov	r6,r16
  181cec:	0005883a 	mov	r2,zero
  181cf0:	280a953a 	slli	r5,r5,20
  181cf4:	31803fcc 	andi	r6,r6,255
  181cf8:	01000434 	movhi	r4,16
  181cfc:	300c97fa 	slli	r6,r6,31
  181d00:	213fffc4 	addi	r4,r4,-1
  181d04:	1906703a 	and	r3,r3,r4
  181d08:	1946b03a 	or	r3,r3,r5
  181d0c:	1986b03a 	or	r3,r3,r6
  181d10:	dfc00217 	ldw	ra,8(sp)
  181d14:	dc400117 	ldw	r17,4(sp)
  181d18:	dc000017 	ldw	r16,0(sp)
  181d1c:	dec00304 	addi	sp,sp,12
  181d20:	f800283a 	ret
  181d24:	00c002c4 	movi	r3,11
  181d28:	1887c83a 	sub	r3,r3,r2
  181d2c:	88c6d83a 	srl	r3,r17,r3
  181d30:	8904983a 	sll	r2,r17,r4
  181d34:	01000434 	movhi	r4,16
  181d38:	213fffc4 	addi	r4,r4,-1
  181d3c:	2941ffcc 	andi	r5,r5,2047
  181d40:	1906703a 	and	r3,r3,r4
  181d44:	800d883a 	mov	r6,r16
  181d48:	003fe906 	br	181cf0 <__floatsidf+0x64>
  181d4c:	000d883a 	mov	r6,zero
  181d50:	000b883a 	mov	r5,zero
  181d54:	0007883a 	mov	r3,zero
  181d58:	0005883a 	mov	r2,zero
  181d5c:	003fe406 	br	181cf0 <__floatsidf+0x64>
  181d60:	0123c83a 	sub	r17,zero,r4
  181d64:	003fd106 	br	181cac <__floatsidf+0x20>

00181d68 <__clzsi2>:
  181d68:	00bfffd4 	movui	r2,65535
  181d6c:	11000536 	bltu	r2,r4,181d84 <__clzsi2+0x1c>
  181d70:	00803fc4 	movi	r2,255
  181d74:	11000f36 	bltu	r2,r4,181db4 <__clzsi2+0x4c>
  181d78:	00800804 	movi	r2,32
  181d7c:	0007883a 	mov	r3,zero
  181d80:	00000506 	br	181d98 <__clzsi2+0x30>
  181d84:	00804034 	movhi	r2,256
  181d88:	10bfffc4 	addi	r2,r2,-1
  181d8c:	11000c2e 	bgeu	r2,r4,181dc0 <__clzsi2+0x58>
  181d90:	00800204 	movi	r2,8
  181d94:	00c00604 	movi	r3,24
  181d98:	20c8d83a 	srl	r4,r4,r3
  181d9c:	00c00634 	movhi	r3,24
  181da0:	18cd5304 	addi	r3,r3,13644
  181da4:	1909883a 	add	r4,r3,r4
  181da8:	20c00003 	ldbu	r3,0(r4)
  181dac:	10c5c83a 	sub	r2,r2,r3
  181db0:	f800283a 	ret
  181db4:	00800604 	movi	r2,24
  181db8:	00c00204 	movi	r3,8
  181dbc:	003ff606 	br	181d98 <__clzsi2+0x30>
  181dc0:	00800404 	movi	r2,16
  181dc4:	1007883a 	mov	r3,r2
  181dc8:	003ff306 	br	181d98 <__clzsi2+0x30>

00181dcc <__mulsi3>:
  181dcc:	0005883a 	mov	r2,zero
  181dd0:	20000726 	beq	r4,zero,181df0 <__mulsi3+0x24>
  181dd4:	20c0004c 	andi	r3,r4,1
  181dd8:	2008d07a 	srli	r4,r4,1
  181ddc:	18000126 	beq	r3,zero,181de4 <__mulsi3+0x18>
  181de0:	1145883a 	add	r2,r2,r5
  181de4:	294b883a 	add	r5,r5,r5
  181de8:	203ffa1e 	bne	r4,zero,181dd4 <__mulsi3+0x8>
  181dec:	f800283a 	ret
  181df0:	f800283a 	ret

00181df4 <memcpy>:
  181df4:	2005883a 	mov	r2,r4
  181df8:	2007883a 	mov	r3,r4
  181dfc:	218d883a 	add	r6,r4,r6
  181e00:	19800526 	beq	r3,r6,181e18 <memcpy+0x24>
  181e04:	29000003 	ldbu	r4,0(r5)
  181e08:	18c00044 	addi	r3,r3,1
  181e0c:	29400044 	addi	r5,r5,1
  181e10:	193fffc5 	stb	r4,-1(r3)
  181e14:	003ffa06 	br	181e00 <memcpy+0xc>
  181e18:	f800283a 	ret

00181e1c <_printf_r>:
  181e1c:	defffd04 	addi	sp,sp,-12
  181e20:	dfc00015 	stw	ra,0(sp)
  181e24:	d9800115 	stw	r6,4(sp)
  181e28:	d9c00215 	stw	r7,8(sp)
  181e2c:	20c00217 	ldw	r3,8(r4)
  181e30:	01800634 	movhi	r6,24
  181e34:	31892604 	addi	r6,r6,9368
  181e38:	19800115 	stw	r6,4(r3)
  181e3c:	280d883a 	mov	r6,r5
  181e40:	21400217 	ldw	r5,8(r4)
  181e44:	d9c00104 	addi	r7,sp,4
  181e48:	0181f500 	call	181f50 <___vfprintf_internal_r>
  181e4c:	dfc00017 	ldw	ra,0(sp)
  181e50:	dec00304 	addi	sp,sp,12
  181e54:	f800283a 	ret

00181e58 <printf>:
  181e58:	defffc04 	addi	sp,sp,-16
  181e5c:	dfc00015 	stw	ra,0(sp)
  181e60:	d9400115 	stw	r5,4(sp)
  181e64:	d9800215 	stw	r6,8(sp)
  181e68:	d9c00315 	stw	r7,12(sp)
  181e6c:	00800634 	movhi	r2,24
  181e70:	108fbc04 	addi	r2,r2,16112
  181e74:	10800017 	ldw	r2,0(r2)
  181e78:	01400634 	movhi	r5,24
  181e7c:	29492604 	addi	r5,r5,9368
  181e80:	10c00217 	ldw	r3,8(r2)
  181e84:	d9800104 	addi	r6,sp,4
  181e88:	19400115 	stw	r5,4(r3)
  181e8c:	200b883a 	mov	r5,r4
  181e90:	11000217 	ldw	r4,8(r2)
  181e94:	018247c0 	call	18247c <__vfprintf_internal>
  181e98:	dfc00017 	ldw	ra,0(sp)
  181e9c:	dec00404 	addi	sp,sp,16
  181ea0:	f800283a 	ret

00181ea4 <_putchar_r>:
  181ea4:	21800217 	ldw	r6,8(r4)
  181ea8:	01825a41 	jmpi	1825a4 <_putc_r>

00181eac <putchar>:
  181eac:	00800634 	movhi	r2,24
  181eb0:	108fbc04 	addi	r2,r2,16112
  181eb4:	10800017 	ldw	r2,0(r2)
  181eb8:	200b883a 	mov	r5,r4
  181ebc:	11800217 	ldw	r6,8(r2)
  181ec0:	1009883a 	mov	r4,r2
  181ec4:	01825a41 	jmpi	1825a4 <_putc_r>

00181ec8 <strlen>:
  181ec8:	2005883a 	mov	r2,r4
  181ecc:	10c00007 	ldb	r3,0(r2)
  181ed0:	18000226 	beq	r3,zero,181edc <strlen+0x14>
  181ed4:	10800044 	addi	r2,r2,1
  181ed8:	003ffc06 	br	181ecc <strlen+0x4>
  181edc:	1105c83a 	sub	r2,r2,r4
  181ee0:	f800283a 	ret

00181ee4 <print_repeat>:
  181ee4:	defffb04 	addi	sp,sp,-20
  181ee8:	dc800315 	stw	r18,12(sp)
  181eec:	dc400215 	stw	r17,8(sp)
  181ef0:	dc000115 	stw	r16,4(sp)
  181ef4:	dfc00415 	stw	ra,16(sp)
  181ef8:	2025883a 	mov	r18,r4
  181efc:	2823883a 	mov	r17,r5
  181f00:	d9800005 	stb	r6,0(sp)
  181f04:	3821883a 	mov	r16,r7
  181f08:	04000a0e 	bge	zero,r16,181f34 <print_repeat+0x50>
  181f0c:	88800117 	ldw	r2,4(r17)
  181f10:	01c00044 	movi	r7,1
  181f14:	d80d883a 	mov	r6,sp
  181f18:	880b883a 	mov	r5,r17
  181f1c:	9009883a 	mov	r4,r18
  181f20:	103ee83a 	callr	r2
  181f24:	843fffc4 	addi	r16,r16,-1
  181f28:	103ff726 	beq	r2,zero,181f08 <print_repeat+0x24>
  181f2c:	00bfffc4 	movi	r2,-1
  181f30:	00000106 	br	181f38 <print_repeat+0x54>
  181f34:	0005883a 	mov	r2,zero
  181f38:	dfc00417 	ldw	ra,16(sp)
  181f3c:	dc800317 	ldw	r18,12(sp)
  181f40:	dc400217 	ldw	r17,8(sp)
  181f44:	dc000117 	ldw	r16,4(sp)
  181f48:	dec00504 	addi	sp,sp,20
  181f4c:	f800283a 	ret

00181f50 <___vfprintf_internal_r>:
  181f50:	deffe504 	addi	sp,sp,-108
  181f54:	d8c00804 	addi	r3,sp,32
  181f58:	ddc01815 	stw	r23,96(sp)
  181f5c:	dd801715 	stw	r22,92(sp)
  181f60:	dd401615 	stw	r21,88(sp)
  181f64:	dd001515 	stw	r20,84(sp)
  181f68:	dcc01415 	stw	r19,80(sp)
  181f6c:	dc801315 	stw	r18,76(sp)
  181f70:	dc401215 	stw	r17,72(sp)
  181f74:	dc001115 	stw	r16,68(sp)
  181f78:	dfc01a15 	stw	ra,104(sp)
  181f7c:	df001915 	stw	fp,100(sp)
  181f80:	2029883a 	mov	r20,r4
  181f84:	2823883a 	mov	r17,r5
  181f88:	382d883a 	mov	r22,r7
  181f8c:	d9800f15 	stw	r6,60(sp)
  181f90:	0021883a 	mov	r16,zero
  181f94:	d8000e15 	stw	zero,56(sp)
  181f98:	d8000a15 	stw	zero,40(sp)
  181f9c:	002b883a 	mov	r21,zero
  181fa0:	0027883a 	mov	r19,zero
  181fa4:	0025883a 	mov	r18,zero
  181fa8:	d8000c15 	stw	zero,48(sp)
  181fac:	d8000b15 	stw	zero,44(sp)
  181fb0:	002f883a 	mov	r23,zero
  181fb4:	d8c00915 	stw	r3,36(sp)
  181fb8:	d8c00f17 	ldw	r3,60(sp)
  181fbc:	19000003 	ldbu	r4,0(r3)
  181fc0:	20803fcc 	andi	r2,r4,255
  181fc4:	1080201c 	xori	r2,r2,128
  181fc8:	10bfe004 	addi	r2,r2,-128
  181fcc:	10011e26 	beq	r2,zero,182448 <___vfprintf_internal_r+0x4f8>
  181fd0:	00c00044 	movi	r3,1
  181fd4:	b8c01426 	beq	r23,r3,182028 <___vfprintf_internal_r+0xd8>
  181fd8:	1dc00216 	blt	r3,r23,181fe4 <___vfprintf_internal_r+0x94>
  181fdc:	b8000626 	beq	r23,zero,181ff8 <___vfprintf_internal_r+0xa8>
  181fe0:	00011506 	br	182438 <___vfprintf_internal_r+0x4e8>
  181fe4:	01400084 	movi	r5,2
  181fe8:	b9401d26 	beq	r23,r5,182060 <___vfprintf_internal_r+0x110>
  181fec:	014000c4 	movi	r5,3
  181ff0:	b9402b26 	beq	r23,r5,1820a0 <___vfprintf_internal_r+0x150>
  181ff4:	00011006 	br	182438 <___vfprintf_internal_r+0x4e8>
  181ff8:	01400944 	movi	r5,37
  181ffc:	1140fc26 	beq	r2,r5,1823f0 <___vfprintf_internal_r+0x4a0>
  182000:	88800117 	ldw	r2,4(r17)
  182004:	d9000005 	stb	r4,0(sp)
  182008:	01c00044 	movi	r7,1
  18200c:	d80d883a 	mov	r6,sp
  182010:	880b883a 	mov	r5,r17
  182014:	a009883a 	mov	r4,r20
  182018:	103ee83a 	callr	r2
  18201c:	1000d81e 	bne	r2,zero,182380 <___vfprintf_internal_r+0x430>
  182020:	84000044 	addi	r16,r16,1
  182024:	00010406 	br	182438 <___vfprintf_internal_r+0x4e8>
  182028:	01400c04 	movi	r5,48
  18202c:	1140fa26 	beq	r2,r5,182418 <___vfprintf_internal_r+0x4c8>
  182030:	01400944 	movi	r5,37
  182034:	11400a1e 	bne	r2,r5,182060 <___vfprintf_internal_r+0x110>
  182038:	d8800005 	stb	r2,0(sp)
  18203c:	88800117 	ldw	r2,4(r17)
  182040:	b80f883a 	mov	r7,r23
  182044:	d80d883a 	mov	r6,sp
  182048:	880b883a 	mov	r5,r17
  18204c:	a009883a 	mov	r4,r20
  182050:	103ee83a 	callr	r2
  182054:	1000ca1e 	bne	r2,zero,182380 <___vfprintf_internal_r+0x430>
  182058:	84000044 	addi	r16,r16,1
  18205c:	0000f506 	br	182434 <___vfprintf_internal_r+0x4e4>
  182060:	25fff404 	addi	r23,r4,-48
  182064:	bdc03fcc 	andi	r23,r23,255
  182068:	00c00244 	movi	r3,9
  18206c:	1dc00936 	bltu	r3,r23,182094 <___vfprintf_internal_r+0x144>
  182070:	00bfffc4 	movi	r2,-1
  182074:	90800426 	beq	r18,r2,182088 <___vfprintf_internal_r+0x138>
  182078:	01400284 	movi	r5,10
  18207c:	9009883a 	mov	r4,r18
  182080:	0181dcc0 	call	181dcc <__mulsi3>
  182084:	00000106 	br	18208c <___vfprintf_internal_r+0x13c>
  182088:	0005883a 	mov	r2,zero
  18208c:	b8a5883a 	add	r18,r23,r2
  182090:	0000e206 	br	18241c <___vfprintf_internal_r+0x4cc>
  182094:	01400b84 	movi	r5,46
  182098:	1140e426 	beq	r2,r5,18242c <___vfprintf_internal_r+0x4dc>
  18209c:	05c00084 	movi	r23,2
  1820a0:	213ff404 	addi	r4,r4,-48
  1820a4:	27003fcc 	andi	fp,r4,255
  1820a8:	00c00244 	movi	r3,9
  1820ac:	1f000936 	bltu	r3,fp,1820d4 <___vfprintf_internal_r+0x184>
  1820b0:	00bfffc4 	movi	r2,-1
  1820b4:	98800426 	beq	r19,r2,1820c8 <___vfprintf_internal_r+0x178>
  1820b8:	01400284 	movi	r5,10
  1820bc:	9809883a 	mov	r4,r19
  1820c0:	0181dcc0 	call	181dcc <__mulsi3>
  1820c4:	00000106 	br	1820cc <___vfprintf_internal_r+0x17c>
  1820c8:	0005883a 	mov	r2,zero
  1820cc:	e0a7883a 	add	r19,fp,r2
  1820d0:	0000d906 	br	182438 <___vfprintf_internal_r+0x4e8>
  1820d4:	00c01b04 	movi	r3,108
  1820d8:	10c0d226 	beq	r2,r3,182424 <___vfprintf_internal_r+0x4d4>
  1820dc:	013fffc4 	movi	r4,-1
  1820e0:	99000226 	beq	r19,r4,1820ec <___vfprintf_internal_r+0x19c>
  1820e4:	d8000b15 	stw	zero,44(sp)
  1820e8:	00000106 	br	1820f0 <___vfprintf_internal_r+0x1a0>
  1820ec:	04c00044 	movi	r19,1
  1820f0:	01001a44 	movi	r4,105
  1820f4:	11001626 	beq	r2,r4,182150 <___vfprintf_internal_r+0x200>
  1820f8:	20800916 	blt	r4,r2,182120 <___vfprintf_internal_r+0x1d0>
  1820fc:	010018c4 	movi	r4,99
  182100:	11008826 	beq	r2,r4,182324 <___vfprintf_internal_r+0x3d4>
  182104:	01001904 	movi	r4,100
  182108:	11001126 	beq	r2,r4,182150 <___vfprintf_internal_r+0x200>
  18210c:	01001604 	movi	r4,88
  182110:	1100c81e 	bne	r2,r4,182434 <___vfprintf_internal_r+0x4e4>
  182114:	00c00044 	movi	r3,1
  182118:	d8c00e15 	stw	r3,56(sp)
  18211c:	00001506 	br	182174 <___vfprintf_internal_r+0x224>
  182120:	01001cc4 	movi	r4,115
  182124:	11009826 	beq	r2,r4,182388 <___vfprintf_internal_r+0x438>
  182128:	20800416 	blt	r4,r2,18213c <___vfprintf_internal_r+0x1ec>
  18212c:	01001bc4 	movi	r4,111
  182130:	1100c01e 	bne	r2,r4,182434 <___vfprintf_internal_r+0x4e4>
  182134:	05400204 	movi	r21,8
  182138:	00000f06 	br	182178 <___vfprintf_internal_r+0x228>
  18213c:	01001d44 	movi	r4,117
  182140:	11000d26 	beq	r2,r4,182178 <___vfprintf_internal_r+0x228>
  182144:	01001e04 	movi	r4,120
  182148:	11000a26 	beq	r2,r4,182174 <___vfprintf_internal_r+0x224>
  18214c:	0000b906 	br	182434 <___vfprintf_internal_r+0x4e4>
  182150:	d8c00a17 	ldw	r3,40(sp)
  182154:	b7000104 	addi	fp,r22,4
  182158:	18000726 	beq	r3,zero,182178 <___vfprintf_internal_r+0x228>
  18215c:	df000d15 	stw	fp,52(sp)
  182160:	b5c00017 	ldw	r23,0(r22)
  182164:	b800080e 	bge	r23,zero,182188 <___vfprintf_internal_r+0x238>
  182168:	05efc83a 	sub	r23,zero,r23
  18216c:	02400044 	movi	r9,1
  182170:	00000606 	br	18218c <___vfprintf_internal_r+0x23c>
  182174:	05400404 	movi	r21,16
  182178:	b0c00104 	addi	r3,r22,4
  18217c:	d8c00d15 	stw	r3,52(sp)
  182180:	b5c00017 	ldw	r23,0(r22)
  182184:	d8000a15 	stw	zero,40(sp)
  182188:	0013883a 	mov	r9,zero
  18218c:	d839883a 	mov	fp,sp
  182190:	b8001726 	beq	r23,zero,1821f0 <___vfprintf_internal_r+0x2a0>
  182194:	a80b883a 	mov	r5,r21
  182198:	b809883a 	mov	r4,r23
  18219c:	da401015 	stw	r9,64(sp)
  1821a0:	018274c0 	call	18274c <__udivsi3>
  1821a4:	a80b883a 	mov	r5,r21
  1821a8:	1009883a 	mov	r4,r2
  1821ac:	102d883a 	mov	r22,r2
  1821b0:	0181dcc0 	call	181dcc <__mulsi3>
  1821b4:	b885c83a 	sub	r2,r23,r2
  1821b8:	00c00244 	movi	r3,9
  1821bc:	da401017 	ldw	r9,64(sp)
  1821c0:	18800216 	blt	r3,r2,1821cc <___vfprintf_internal_r+0x27c>
  1821c4:	10800c04 	addi	r2,r2,48
  1821c8:	00000506 	br	1821e0 <___vfprintf_internal_r+0x290>
  1821cc:	d8c00e17 	ldw	r3,56(sp)
  1821d0:	18000226 	beq	r3,zero,1821dc <___vfprintf_internal_r+0x28c>
  1821d4:	10800dc4 	addi	r2,r2,55
  1821d8:	00000106 	br	1821e0 <___vfprintf_internal_r+0x290>
  1821dc:	108015c4 	addi	r2,r2,87
  1821e0:	e0800005 	stb	r2,0(fp)
  1821e4:	b02f883a 	mov	r23,r22
  1821e8:	e7000044 	addi	fp,fp,1
  1821ec:	003fe806 	br	182190 <___vfprintf_internal_r+0x240>
  1821f0:	e6efc83a 	sub	r23,fp,sp
  1821f4:	9dc5c83a 	sub	r2,r19,r23
  1821f8:	0080090e 	bge	zero,r2,182220 <___vfprintf_internal_r+0x2d0>
  1821fc:	e085883a 	add	r2,fp,r2
  182200:	01400c04 	movi	r5,48
  182204:	d8c00917 	ldw	r3,36(sp)
  182208:	e009883a 	mov	r4,fp
  18220c:	e0c0032e 	bgeu	fp,r3,18221c <___vfprintf_internal_r+0x2cc>
  182210:	e7000044 	addi	fp,fp,1
  182214:	21400005 	stb	r5,0(r4)
  182218:	e0bffa1e 	bne	fp,r2,182204 <___vfprintf_internal_r+0x2b4>
  18221c:	e6efc83a 	sub	r23,fp,sp
  182220:	d8c00b17 	ldw	r3,44(sp)
  182224:	4dd1883a 	add	r8,r9,r23
  182228:	922dc83a 	sub	r22,r18,r8
  18222c:	18001626 	beq	r3,zero,182288 <___vfprintf_internal_r+0x338>
  182230:	48000a26 	beq	r9,zero,18225c <___vfprintf_internal_r+0x30c>
  182234:	00800b44 	movi	r2,45
  182238:	d8800805 	stb	r2,32(sp)
  18223c:	88800117 	ldw	r2,4(r17)
  182240:	01c00044 	movi	r7,1
  182244:	d9800804 	addi	r6,sp,32
  182248:	880b883a 	mov	r5,r17
  18224c:	a009883a 	mov	r4,r20
  182250:	103ee83a 	callr	r2
  182254:	10004a1e 	bne	r2,zero,182380 <___vfprintf_internal_r+0x430>
  182258:	84000044 	addi	r16,r16,1
  18225c:	0580070e 	bge	zero,r22,18227c <___vfprintf_internal_r+0x32c>
  182260:	b00f883a 	mov	r7,r22
  182264:	01800c04 	movi	r6,48
  182268:	880b883a 	mov	r5,r17
  18226c:	a009883a 	mov	r4,r20
  182270:	0181ee40 	call	181ee4 <print_repeat>
  182274:	1000421e 	bne	r2,zero,182380 <___vfprintf_internal_r+0x430>
  182278:	85a1883a 	add	r16,r16,r22
  18227c:	e02d883a 	mov	r22,fp
  182280:	bf2fc83a 	sub	r23,r23,fp
  182284:	00002006 	br	182308 <___vfprintf_internal_r+0x3b8>
  182288:	0580090e 	bge	zero,r22,1822b0 <___vfprintf_internal_r+0x360>
  18228c:	b00f883a 	mov	r7,r22
  182290:	01800804 	movi	r6,32
  182294:	880b883a 	mov	r5,r17
  182298:	a009883a 	mov	r4,r20
  18229c:	da401015 	stw	r9,64(sp)
  1822a0:	0181ee40 	call	181ee4 <print_repeat>
  1822a4:	da401017 	ldw	r9,64(sp)
  1822a8:	1000351e 	bne	r2,zero,182380 <___vfprintf_internal_r+0x430>
  1822ac:	85a1883a 	add	r16,r16,r22
  1822b0:	483ff226 	beq	r9,zero,18227c <___vfprintf_internal_r+0x32c>
  1822b4:	00800b44 	movi	r2,45
  1822b8:	d8800805 	stb	r2,32(sp)
  1822bc:	88800117 	ldw	r2,4(r17)
  1822c0:	01c00044 	movi	r7,1
  1822c4:	d9800804 	addi	r6,sp,32
  1822c8:	880b883a 	mov	r5,r17
  1822cc:	a009883a 	mov	r4,r20
  1822d0:	103ee83a 	callr	r2
  1822d4:	10002a1e 	bne	r2,zero,182380 <___vfprintf_internal_r+0x430>
  1822d8:	84000044 	addi	r16,r16,1
  1822dc:	003fe706 	br	18227c <___vfprintf_internal_r+0x32c>
  1822e0:	b5bfffc4 	addi	r22,r22,-1
  1822e4:	b0800003 	ldbu	r2,0(r22)
  1822e8:	01c00044 	movi	r7,1
  1822ec:	d9800804 	addi	r6,sp,32
  1822f0:	d8800805 	stb	r2,32(sp)
  1822f4:	88800117 	ldw	r2,4(r17)
  1822f8:	880b883a 	mov	r5,r17
  1822fc:	a009883a 	mov	r4,r20
  182300:	103ee83a 	callr	r2
  182304:	10001e1e 	bne	r2,zero,182380 <___vfprintf_internal_r+0x430>
  182308:	8585c83a 	sub	r2,r16,r22
  18230c:	b5c9883a 	add	r4,r22,r23
  182310:	e085883a 	add	r2,fp,r2
  182314:	013ff216 	blt	zero,r4,1822e0 <___vfprintf_internal_r+0x390>
  182318:	1021883a 	mov	r16,r2
  18231c:	dd800d17 	ldw	r22,52(sp)
  182320:	00004406 	br	182434 <___vfprintf_internal_r+0x4e4>
  182324:	00800044 	movi	r2,1
  182328:	1480080e 	bge	r2,r18,18234c <___vfprintf_internal_r+0x3fc>
  18232c:	95ffffc4 	addi	r23,r18,-1
  182330:	b80f883a 	mov	r7,r23
  182334:	01800804 	movi	r6,32
  182338:	880b883a 	mov	r5,r17
  18233c:	a009883a 	mov	r4,r20
  182340:	0181ee40 	call	181ee4 <print_repeat>
  182344:	10000e1e 	bne	r2,zero,182380 <___vfprintf_internal_r+0x430>
  182348:	85e1883a 	add	r16,r16,r23
  18234c:	b0800017 	ldw	r2,0(r22)
  182350:	01c00044 	movi	r7,1
  182354:	d80d883a 	mov	r6,sp
  182358:	d8800005 	stb	r2,0(sp)
  18235c:	88800117 	ldw	r2,4(r17)
  182360:	880b883a 	mov	r5,r17
  182364:	a009883a 	mov	r4,r20
  182368:	b5c00104 	addi	r23,r22,4
  18236c:	103ee83a 	callr	r2
  182370:	1000031e 	bne	r2,zero,182380 <___vfprintf_internal_r+0x430>
  182374:	84000044 	addi	r16,r16,1
  182378:	b82d883a 	mov	r22,r23
  18237c:	00002d06 	br	182434 <___vfprintf_internal_r+0x4e4>
  182380:	00bfffc4 	movi	r2,-1
  182384:	00003106 	br	18244c <___vfprintf_internal_r+0x4fc>
  182388:	b5c00017 	ldw	r23,0(r22)
  18238c:	b7000104 	addi	fp,r22,4
  182390:	b809883a 	mov	r4,r23
  182394:	0181ec80 	call	181ec8 <strlen>
  182398:	9091c83a 	sub	r8,r18,r2
  18239c:	102d883a 	mov	r22,r2
  1823a0:	0200090e 	bge	zero,r8,1823c8 <___vfprintf_internal_r+0x478>
  1823a4:	400f883a 	mov	r7,r8
  1823a8:	01800804 	movi	r6,32
  1823ac:	880b883a 	mov	r5,r17
  1823b0:	a009883a 	mov	r4,r20
  1823b4:	da001015 	stw	r8,64(sp)
  1823b8:	0181ee40 	call	181ee4 <print_repeat>
  1823bc:	da001017 	ldw	r8,64(sp)
  1823c0:	103fef1e 	bne	r2,zero,182380 <___vfprintf_internal_r+0x430>
  1823c4:	8221883a 	add	r16,r16,r8
  1823c8:	88800117 	ldw	r2,4(r17)
  1823cc:	b00f883a 	mov	r7,r22
  1823d0:	b80d883a 	mov	r6,r23
  1823d4:	880b883a 	mov	r5,r17
  1823d8:	a009883a 	mov	r4,r20
  1823dc:	103ee83a 	callr	r2
  1823e0:	103fe71e 	bne	r2,zero,182380 <___vfprintf_internal_r+0x430>
  1823e4:	85a1883a 	add	r16,r16,r22
  1823e8:	e02d883a 	mov	r22,fp
  1823ec:	00001106 	br	182434 <___vfprintf_internal_r+0x4e4>
  1823f0:	00c00044 	movi	r3,1
  1823f4:	04ffffc4 	movi	r19,-1
  1823f8:	d8000e15 	stw	zero,56(sp)
  1823fc:	d8c00a15 	stw	r3,40(sp)
  182400:	05400284 	movi	r21,10
  182404:	9825883a 	mov	r18,r19
  182408:	d8000c15 	stw	zero,48(sp)
  18240c:	d8000b15 	stw	zero,44(sp)
  182410:	182f883a 	mov	r23,r3
  182414:	00000806 	br	182438 <___vfprintf_internal_r+0x4e8>
  182418:	ddc00b15 	stw	r23,44(sp)
  18241c:	05c00084 	movi	r23,2
  182420:	00000506 	br	182438 <___vfprintf_internal_r+0x4e8>
  182424:	00c00044 	movi	r3,1
  182428:	d8c00c15 	stw	r3,48(sp)
  18242c:	05c000c4 	movi	r23,3
  182430:	00000106 	br	182438 <___vfprintf_internal_r+0x4e8>
  182434:	002f883a 	mov	r23,zero
  182438:	d8c00f17 	ldw	r3,60(sp)
  18243c:	18c00044 	addi	r3,r3,1
  182440:	d8c00f15 	stw	r3,60(sp)
  182444:	003edc06 	br	181fb8 <___vfprintf_internal_r+0x68>
  182448:	8005883a 	mov	r2,r16
  18244c:	dfc01a17 	ldw	ra,104(sp)
  182450:	df001917 	ldw	fp,100(sp)
  182454:	ddc01817 	ldw	r23,96(sp)
  182458:	dd801717 	ldw	r22,92(sp)
  18245c:	dd401617 	ldw	r21,88(sp)
  182460:	dd001517 	ldw	r20,84(sp)
  182464:	dcc01417 	ldw	r19,80(sp)
  182468:	dc801317 	ldw	r18,76(sp)
  18246c:	dc401217 	ldw	r17,72(sp)
  182470:	dc001117 	ldw	r16,68(sp)
  182474:	dec01b04 	addi	sp,sp,108
  182478:	f800283a 	ret

0018247c <__vfprintf_internal>:
  18247c:	00800634 	movhi	r2,24
  182480:	108fbc04 	addi	r2,r2,16112
  182484:	300f883a 	mov	r7,r6
  182488:	280d883a 	mov	r6,r5
  18248c:	200b883a 	mov	r5,r4
  182490:	11000017 	ldw	r4,0(r2)
  182494:	0181f501 	jmpi	181f50 <___vfprintf_internal_r>

00182498 <__sfvwrite_small_dev>:
  182498:	2880000b 	ldhu	r2,0(r5)
  18249c:	1080020c 	andi	r2,r2,8
  1824a0:	10002126 	beq	r2,zero,182528 <__sfvwrite_small_dev+0x90>
  1824a4:	2880008f 	ldh	r2,2(r5)
  1824a8:	defffa04 	addi	sp,sp,-24
  1824ac:	dc000015 	stw	r16,0(sp)
  1824b0:	dfc00515 	stw	ra,20(sp)
  1824b4:	dd000415 	stw	r20,16(sp)
  1824b8:	dcc00315 	stw	r19,12(sp)
  1824bc:	dc800215 	stw	r18,8(sp)
  1824c0:	dc400115 	stw	r17,4(sp)
  1824c4:	2821883a 	mov	r16,r5
  1824c8:	10001216 	blt	r2,zero,182514 <__sfvwrite_small_dev+0x7c>
  1824cc:	2027883a 	mov	r19,r4
  1824d0:	3025883a 	mov	r18,r6
  1824d4:	3823883a 	mov	r17,r7
  1824d8:	05010004 	movi	r20,1024
  1824dc:	04400b0e 	bge	zero,r17,18250c <__sfvwrite_small_dev+0x74>
  1824e0:	880f883a 	mov	r7,r17
  1824e4:	a440010e 	bge	r20,r17,1824ec <__sfvwrite_small_dev+0x54>
  1824e8:	01c10004 	movi	r7,1024
  1824ec:	8140008f 	ldh	r5,2(r16)
  1824f0:	900d883a 	mov	r6,r18
  1824f4:	9809883a 	mov	r4,r19
  1824f8:	01825fc0 	call	1825fc <_write_r>
  1824fc:	0080050e 	bge	zero,r2,182514 <__sfvwrite_small_dev+0x7c>
  182500:	88a3c83a 	sub	r17,r17,r2
  182504:	90a5883a 	add	r18,r18,r2
  182508:	003ff406 	br	1824dc <__sfvwrite_small_dev+0x44>
  18250c:	0005883a 	mov	r2,zero
  182510:	00000706 	br	182530 <__sfvwrite_small_dev+0x98>
  182514:	8080000b 	ldhu	r2,0(r16)
  182518:	10801014 	ori	r2,r2,64
  18251c:	8080000d 	sth	r2,0(r16)
  182520:	00bfffc4 	movi	r2,-1
  182524:	00000206 	br	182530 <__sfvwrite_small_dev+0x98>
  182528:	00bfffc4 	movi	r2,-1
  18252c:	f800283a 	ret
  182530:	dfc00517 	ldw	ra,20(sp)
  182534:	dd000417 	ldw	r20,16(sp)
  182538:	dcc00317 	ldw	r19,12(sp)
  18253c:	dc800217 	ldw	r18,8(sp)
  182540:	dc400117 	ldw	r17,4(sp)
  182544:	dc000017 	ldw	r16,0(sp)
  182548:	dec00604 	addi	sp,sp,24
  18254c:	f800283a 	ret

00182550 <putc>:
  182550:	defffd04 	addi	sp,sp,-12
  182554:	00800634 	movhi	r2,24
  182558:	dc000115 	stw	r16,4(sp)
  18255c:	dfc00215 	stw	ra,8(sp)
  182560:	10892604 	addi	r2,r2,9368
  182564:	28800115 	stw	r2,4(r5)
  182568:	00800634 	movhi	r2,24
  18256c:	108fbc04 	addi	r2,r2,16112
  182570:	d9000005 	stb	r4,0(sp)
  182574:	2021883a 	mov	r16,r4
  182578:	11000017 	ldw	r4,0(r2)
  18257c:	01c00044 	movi	r7,1
  182580:	d80d883a 	mov	r6,sp
  182584:	01824980 	call	182498 <__sfvwrite_small_dev>
  182588:	00ffffc4 	movi	r3,-1
  18258c:	10c00126 	beq	r2,r3,182594 <putc+0x44>
  182590:	8005883a 	mov	r2,r16
  182594:	dfc00217 	ldw	ra,8(sp)
  182598:	dc000117 	ldw	r16,4(sp)
  18259c:	dec00304 	addi	sp,sp,12
  1825a0:	f800283a 	ret

001825a4 <_putc_r>:
  1825a4:	defffd04 	addi	sp,sp,-12
  1825a8:	00800634 	movhi	r2,24
  1825ac:	dc000115 	stw	r16,4(sp)
  1825b0:	dfc00215 	stw	ra,8(sp)
  1825b4:	10892604 	addi	r2,r2,9368
  1825b8:	30800115 	stw	r2,4(r6)
  1825bc:	00800634 	movhi	r2,24
  1825c0:	108fbc04 	addi	r2,r2,16112
  1825c4:	11000017 	ldw	r4,0(r2)
  1825c8:	2821883a 	mov	r16,r5
  1825cc:	01c00044 	movi	r7,1
  1825d0:	300b883a 	mov	r5,r6
  1825d4:	d80d883a 	mov	r6,sp
  1825d8:	dc000005 	stb	r16,0(sp)
  1825dc:	01824980 	call	182498 <__sfvwrite_small_dev>
  1825e0:	00ffffc4 	movi	r3,-1
  1825e4:	10c00126 	beq	r2,r3,1825ec <_putc_r+0x48>
  1825e8:	8005883a 	mov	r2,r16
  1825ec:	dfc00217 	ldw	ra,8(sp)
  1825f0:	dc000117 	ldw	r16,4(sp)
  1825f4:	dec00304 	addi	sp,sp,12
  1825f8:	f800283a 	ret

001825fc <_write_r>:
  1825fc:	defffd04 	addi	sp,sp,-12
  182600:	dc000015 	stw	r16,0(sp)
  182604:	04000634 	movhi	r16,24
  182608:	dc400115 	stw	r17,4(sp)
  18260c:	8411f604 	addi	r16,r16,18392
  182610:	2023883a 	mov	r17,r4
  182614:	2809883a 	mov	r4,r5
  182618:	300b883a 	mov	r5,r6
  18261c:	380d883a 	mov	r6,r7
  182620:	dfc00215 	stw	ra,8(sp)
  182624:	80000015 	stw	zero,0(r16)
  182628:	0182ad00 	call	182ad0 <write>
  18262c:	00ffffc4 	movi	r3,-1
  182630:	10c0031e 	bne	r2,r3,182640 <_write_r+0x44>
  182634:	80c00017 	ldw	r3,0(r16)
  182638:	18000126 	beq	r3,zero,182640 <_write_r+0x44>
  18263c:	88c00015 	stw	r3,0(r17)
  182640:	dfc00217 	ldw	ra,8(sp)
  182644:	dc400117 	ldw	r17,4(sp)
  182648:	dc000017 	ldw	r16,0(sp)
  18264c:	dec00304 	addi	sp,sp,12
  182650:	f800283a 	ret

00182654 <__divsi3>:
  182654:	20001b16 	blt	r4,zero,1826c4 <__divsi3+0x70>
  182658:	000f883a 	mov	r7,zero
  18265c:	28001616 	blt	r5,zero,1826b8 <__divsi3+0x64>
  182660:	200d883a 	mov	r6,r4
  182664:	29001a2e 	bgeu	r5,r4,1826d0 <__divsi3+0x7c>
  182668:	00800804 	movi	r2,32
  18266c:	00c00044 	movi	r3,1
  182670:	00000106 	br	182678 <__divsi3+0x24>
  182674:	10000d26 	beq	r2,zero,1826ac <__divsi3+0x58>
  182678:	294b883a 	add	r5,r5,r5
  18267c:	10bfffc4 	addi	r2,r2,-1
  182680:	18c7883a 	add	r3,r3,r3
  182684:	293ffb36 	bltu	r5,r4,182674 <__divsi3+0x20>
  182688:	0005883a 	mov	r2,zero
  18268c:	18000726 	beq	r3,zero,1826ac <__divsi3+0x58>
  182690:	0005883a 	mov	r2,zero
  182694:	31400236 	bltu	r6,r5,1826a0 <__divsi3+0x4c>
  182698:	314dc83a 	sub	r6,r6,r5
  18269c:	10c4b03a 	or	r2,r2,r3
  1826a0:	1806d07a 	srli	r3,r3,1
  1826a4:	280ad07a 	srli	r5,r5,1
  1826a8:	183ffa1e 	bne	r3,zero,182694 <__divsi3+0x40>
  1826ac:	38000126 	beq	r7,zero,1826b4 <__divsi3+0x60>
  1826b0:	0085c83a 	sub	r2,zero,r2
  1826b4:	f800283a 	ret
  1826b8:	014bc83a 	sub	r5,zero,r5
  1826bc:	39c0005c 	xori	r7,r7,1
  1826c0:	003fe706 	br	182660 <__divsi3+0xc>
  1826c4:	0109c83a 	sub	r4,zero,r4
  1826c8:	01c00044 	movi	r7,1
  1826cc:	003fe306 	br	18265c <__divsi3+0x8>
  1826d0:	00c00044 	movi	r3,1
  1826d4:	003fee06 	br	182690 <__divsi3+0x3c>

001826d8 <__modsi3>:
  1826d8:	20001716 	blt	r4,zero,182738 <__modsi3+0x60>
  1826dc:	000f883a 	mov	r7,zero
  1826e0:	2005883a 	mov	r2,r4
  1826e4:	28001216 	blt	r5,zero,182730 <__modsi3+0x58>
  1826e8:	2900162e 	bgeu	r5,r4,182744 <__modsi3+0x6c>
  1826ec:	01800804 	movi	r6,32
  1826f0:	00c00044 	movi	r3,1
  1826f4:	00000106 	br	1826fc <__modsi3+0x24>
  1826f8:	30000a26 	beq	r6,zero,182724 <__modsi3+0x4c>
  1826fc:	294b883a 	add	r5,r5,r5
  182700:	31bfffc4 	addi	r6,r6,-1
  182704:	18c7883a 	add	r3,r3,r3
  182708:	293ffb36 	bltu	r5,r4,1826f8 <__modsi3+0x20>
  18270c:	18000526 	beq	r3,zero,182724 <__modsi3+0x4c>
  182710:	1806d07a 	srli	r3,r3,1
  182714:	11400136 	bltu	r2,r5,18271c <__modsi3+0x44>
  182718:	1145c83a 	sub	r2,r2,r5
  18271c:	280ad07a 	srli	r5,r5,1
  182720:	183ffb1e 	bne	r3,zero,182710 <__modsi3+0x38>
  182724:	38000126 	beq	r7,zero,18272c <__modsi3+0x54>
  182728:	0085c83a 	sub	r2,zero,r2
  18272c:	f800283a 	ret
  182730:	014bc83a 	sub	r5,zero,r5
  182734:	003fec06 	br	1826e8 <__modsi3+0x10>
  182738:	0109c83a 	sub	r4,zero,r4
  18273c:	01c00044 	movi	r7,1
  182740:	003fe706 	br	1826e0 <__modsi3+0x8>
  182744:	00c00044 	movi	r3,1
  182748:	003ff106 	br	182710 <__modsi3+0x38>

0018274c <__udivsi3>:
  18274c:	200d883a 	mov	r6,r4
  182750:	2900152e 	bgeu	r5,r4,1827a8 <__udivsi3+0x5c>
  182754:	28001416 	blt	r5,zero,1827a8 <__udivsi3+0x5c>
  182758:	00800804 	movi	r2,32
  18275c:	00c00044 	movi	r3,1
  182760:	00000206 	br	18276c <__udivsi3+0x20>
  182764:	10000e26 	beq	r2,zero,1827a0 <__udivsi3+0x54>
  182768:	28000516 	blt	r5,zero,182780 <__udivsi3+0x34>
  18276c:	294b883a 	add	r5,r5,r5
  182770:	10bfffc4 	addi	r2,r2,-1
  182774:	18c7883a 	add	r3,r3,r3
  182778:	293ffa36 	bltu	r5,r4,182764 <__udivsi3+0x18>
  18277c:	18000826 	beq	r3,zero,1827a0 <__udivsi3+0x54>
  182780:	0005883a 	mov	r2,zero
  182784:	31400236 	bltu	r6,r5,182790 <__udivsi3+0x44>
  182788:	314dc83a 	sub	r6,r6,r5
  18278c:	10c4b03a 	or	r2,r2,r3
  182790:	1806d07a 	srli	r3,r3,1
  182794:	280ad07a 	srli	r5,r5,1
  182798:	183ffa1e 	bne	r3,zero,182784 <__udivsi3+0x38>
  18279c:	f800283a 	ret
  1827a0:	0005883a 	mov	r2,zero
  1827a4:	f800283a 	ret
  1827a8:	00c00044 	movi	r3,1
  1827ac:	003ff406 	br	182780 <__udivsi3+0x34>

001827b0 <__umodsi3>:
  1827b0:	2005883a 	mov	r2,r4
  1827b4:	2900122e 	bgeu	r5,r4,182800 <__umodsi3+0x50>
  1827b8:	28001116 	blt	r5,zero,182800 <__umodsi3+0x50>
  1827bc:	01800804 	movi	r6,32
  1827c0:	00c00044 	movi	r3,1
  1827c4:	00000206 	br	1827d0 <__umodsi3+0x20>
  1827c8:	30000c26 	beq	r6,zero,1827fc <__umodsi3+0x4c>
  1827cc:	28000516 	blt	r5,zero,1827e4 <__umodsi3+0x34>
  1827d0:	294b883a 	add	r5,r5,r5
  1827d4:	31bfffc4 	addi	r6,r6,-1
  1827d8:	18c7883a 	add	r3,r3,r3
  1827dc:	293ffa36 	bltu	r5,r4,1827c8 <__umodsi3+0x18>
  1827e0:	18000626 	beq	r3,zero,1827fc <__umodsi3+0x4c>
  1827e4:	1806d07a 	srli	r3,r3,1
  1827e8:	11400136 	bltu	r2,r5,1827f0 <__umodsi3+0x40>
  1827ec:	1145c83a 	sub	r2,r2,r5
  1827f0:	280ad07a 	srli	r5,r5,1
  1827f4:	183ffb1e 	bne	r3,zero,1827e4 <__umodsi3+0x34>
  1827f8:	f800283a 	ret
  1827fc:	f800283a 	ret
  182800:	00c00044 	movi	r3,1
  182804:	003ff706 	br	1827e4 <__umodsi3+0x34>

00182808 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
  182808:	deffff04 	addi	sp,sp,-4
  18280c:	01000634 	movhi	r4,24
  182810:	01400634 	movhi	r5,24
  182814:	dfc00015 	stw	ra,0(sp)
  182818:	210d9304 	addi	r4,r4,13900
  18281c:	294fc204 	addi	r5,r5,16136

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  182820:	2140061e 	bne	r4,r5,18283c <alt_load+0x34>
  182824:	01000634 	movhi	r4,24
  182828:	01400634 	movhi	r5,24
  18282c:	21000804 	addi	r4,r4,32
  182830:	29400804 	addi	r5,r5,32
  182834:	2140121e 	bne	r4,r5,182880 <alt_load+0x78>
  182838:	00000b06 	br	182868 <alt_load+0x60>
  18283c:	00c00634 	movhi	r3,24
  182840:	18cfc204 	addi	r3,r3,16136
  182844:	1907c83a 	sub	r3,r3,r4
  182848:	0005883a 	mov	r2,zero
  {
    while( to != end )
  18284c:	10fff526 	beq	r2,r3,182824 <alt_load+0x1c>
    {
      *to++ = *from++;
  182850:	114f883a 	add	r7,r2,r5
  182854:	39c00017 	ldw	r7,0(r7)
  182858:	110d883a 	add	r6,r2,r4
  18285c:	10800104 	addi	r2,r2,4
  182860:	31c00015 	stw	r7,0(r6)
  182864:	003ff906 	br	18284c <alt_load+0x44>
  182868:	01000634 	movhi	r4,24
  18286c:	01400634 	movhi	r5,24
  182870:	210d0804 	addi	r4,r4,13344
  182874:	294d0804 	addi	r5,r5,13344

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  182878:	2140101e 	bne	r4,r5,1828bc <alt_load+0xb4>
  18287c:	00000b06 	br	1828ac <alt_load+0xa4>
  182880:	00c00634 	movhi	r3,24
  182884:	18c05304 	addi	r3,r3,332
  182888:	1907c83a 	sub	r3,r3,r4
  18288c:	0005883a 	mov	r2,zero
  {
    while( to != end )
  182890:	10fff526 	beq	r2,r3,182868 <alt_load+0x60>
    {
      *to++ = *from++;
  182894:	114f883a 	add	r7,r2,r5
  182898:	39c00017 	ldw	r7,0(r7)
  18289c:	110d883a 	add	r6,r2,r4
  1828a0:	10800104 	addi	r2,r2,4
  1828a4:	31c00015 	stw	r7,0(r6)
  1828a8:	003ff906 	br	182890 <alt_load+0x88>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  1828ac:	018320c0 	call	18320c <alt_dcache_flush_all>
  alt_icache_flush_all();
}
  1828b0:	dfc00017 	ldw	ra,0(sp)
  1828b4:	dec00104 	addi	sp,sp,4
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  alt_icache_flush_all();
  1828b8:	01832f01 	jmpi	1832f0 <alt_icache_flush_all>
  1828bc:	00c00634 	movhi	r3,24
  1828c0:	18cd9304 	addi	r3,r3,13900
  1828c4:	1907c83a 	sub	r3,r3,r4

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  1828c8:	0005883a 	mov	r2,zero
  {
    while( to != end )
  1828cc:	18bff726 	beq	r3,r2,1828ac <alt_load+0xa4>
    {
      *to++ = *from++;
  1828d0:	114f883a 	add	r7,r2,r5
  1828d4:	39c00017 	ldw	r7,0(r7)
  1828d8:	110d883a 	add	r6,r2,r4
  1828dc:	10800104 	addi	r2,r2,4
  1828e0:	31c00015 	stw	r7,0(r6)
  1828e4:	003ff906 	br	1828cc <alt_load+0xc4>

001828e8 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
  1828e8:	deffff04 	addi	sp,sp,-4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
  1828ec:	0009883a 	mov	r4,zero
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
  1828f0:	dfc00015 	stw	ra,0(sp)
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
  1828f4:	0182b300 	call	182b30 <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
  1828f8:	0182b500 	call	182b50 <alt_sys_init>
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
  1828fc:	d1a23c17 	ldw	r6,-30480(gp)
  182900:	d1623d17 	ldw	r5,-30476(gp)
  182904:	d1223e17 	ldw	r4,-30472(gp)
  close(STDOUT_FILENO);
  exit (result);
#endif

  ALT_LOG_PRINT_BOOT("[alt_main.c] After main - we should not be here?.\r\n");
}
  182908:	dfc00017 	ldw	ra,0(sp)
  18290c:	dec00104 	addi	sp,sp,4
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
  182910:	01807501 	jmpi	180750 <main>

00182914 <alt_printf>:
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
  182914:	defff204 	addi	sp,sp,-56
  182918:	2005883a 	mov	r2,r4
  18291c:	dfc00a15 	stw	ra,40(sp)
  182920:	df000915 	stw	fp,36(sp)
  182924:	ddc00815 	stw	r23,32(sp)
  182928:	dd800715 	stw	r22,28(sp)
  18292c:	dd400615 	stw	r21,24(sp)
  182930:	dd000515 	stw	r20,20(sp)
  182934:	dcc00415 	stw	r19,16(sp)
  182938:	dc800315 	stw	r18,12(sp)
  18293c:	dc400215 	stw	r17,8(sp)
  182940:	dc000115 	stw	r16,4(sp)
  182944:	d9400b15 	stw	r5,44(sp)
  182948:	d9800c15 	stw	r6,48(sp)
  18294c:	d9c00d15 	stw	r7,52(sp)
    w = fmt;
    while ((c = *w++) != 0)
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
  182950:	04000944 	movi	r16,37
 */
void 
alt_printf(const char* fmt, ... )
{
	va_list args;
	va_start(args, fmt);
  182954:	dd400b04 	addi	r21,sp,44
                if (c == '%')
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
                } 
                else if (c == 'c')
  182958:	048018c4 	movi	r18,99
                {
                    int v = va_arg(args, int);
                    alt_putchar(v);
                }
                else if (c == 'x')
  18295c:	04c01e04 	movi	r19,120
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
  182960:	05001cc4 	movi	r20,115
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
  182964:	11000007 	ldb	r4,0(r2)
  182968:	20003a26 	beq	r4,zero,182a54 <alt_printf+0x140>
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
  18296c:	24000226 	beq	r4,r16,182978 <alt_printf+0x64>
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
  182970:	14400044 	addi	r17,r2,1
  182974:	00001406 	br	1829c8 <alt_printf+0xb4>
        }
        else
        {
            /* Get format character.  If none     */
            /* available, processing is complete. */
            if ((c = *w++) != 0)
  182978:	14400084 	addi	r17,r2,2
  18297c:	10800047 	ldb	r2,1(r2)
  182980:	10003426 	beq	r2,zero,182a54 <alt_printf+0x140>
            {
                if (c == '%')
  182984:	1400021e 	bne	r2,r16,182990 <alt_printf+0x7c>
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
  182988:	8009883a 	mov	r4,r16
  18298c:	00000e06 	br	1829c8 <alt_printf+0xb4>
                } 
                else if (c == 'c')
  182990:	1480051e 	bne	r2,r18,1829a8 <alt_printf+0x94>
                {
                    int v = va_arg(args, int);
                    alt_putchar(v);
  182994:	a9000017 	ldw	r4,0(r21)
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
                } 
                else if (c == 'c')
                {
                    int v = va_arg(args, int);
  182998:	ad800104 	addi	r22,r21,4
  18299c:	b02b883a 	mov	r21,r22
                    alt_putchar(v);
  1829a0:	0182a840 	call	182a84 <alt_putchar>
  1829a4:	00002906 	br	182a4c <alt_printf+0x138>
                }
                else if (c == 'x')
  1829a8:	14c0201e 	bne	r2,r19,182a2c <alt_printf+0x118>
                {
                    /* Process hexadecimal number format. */
                    unsigned long v = va_arg(args, unsigned long);
  1829ac:	adc00017 	ldw	r23,0(r21)
  1829b0:	ad400104 	addi	r21,r21,4
                    unsigned long digit;
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
  1829b4:	b8000326 	beq	r23,zero,1829c4 <alt_printf+0xb0>
  1829b8:	05800704 	movi	r22,28
                        continue;
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
  1829bc:	00c003c4 	movi	r3,15
  1829c0:	00000306 	br	1829d0 <alt_printf+0xbc>
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
                    {
                        alt_putchar('0');
  1829c4:	01000c04 	movi	r4,48
  1829c8:	0182a840 	call	182a84 <alt_putchar>
                        continue;
  1829cc:	00001f06 	br	182a4c <alt_printf+0x138>
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
  1829d0:	1d84983a 	sll	r2,r3,r22
  1829d4:	15c4703a 	and	r2,r2,r23
  1829d8:	1000021e 	bne	r2,zero,1829e4 <alt_printf+0xd0>
                        digit_shift -= 4;
  1829dc:	b5bfff04 	addi	r22,r22,-4
  1829e0:	003ffb06 	br	1829d0 <alt_printf+0xbc>

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
  1829e4:	070003c4 	movi	fp,15
                        if (digit <= 9)
  1829e8:	00c00244 	movi	r3,9
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
  1829ec:	b0001716 	blt	r22,zero,182a4c <alt_printf+0x138>
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
  1829f0:	e588983a 	sll	r4,fp,r22
  1829f4:	25c8703a 	and	r4,r4,r23
  1829f8:	2588d83a 	srl	r4,r4,r22
                        if (digit <= 9)
  1829fc:	19000236 	bltu	r3,r4,182a08 <alt_printf+0xf4>
                            c = '0' + digit;
  182a00:	21000c04 	addi	r4,r4,48
  182a04:	00000106 	br	182a0c <alt_printf+0xf8>
                        else
                            c = 'a' + digit - 10;
  182a08:	210015c4 	addi	r4,r4,87
                        alt_putchar(c);
  182a0c:	21003fcc 	andi	r4,r4,255
  182a10:	2100201c 	xori	r4,r4,128
  182a14:	213fe004 	addi	r4,r4,-128
  182a18:	d8c00015 	stw	r3,0(sp)
  182a1c:	0182a840 	call	182a84 <alt_putchar>
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
  182a20:	b5bfff04 	addi	r22,r22,-4
  182a24:	d8c00017 	ldw	r3,0(sp)
  182a28:	003ff006 	br	1829ec <alt_printf+0xd8>
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
  182a2c:	1500071e 	bne	r2,r20,182a4c <alt_printf+0x138>
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);
  182a30:	ad800017 	ldw	r22,0(r21)
  182a34:	ad400104 	addi	r21,r21,4

                    while(*s)
  182a38:	b1000007 	ldb	r4,0(r22)
  182a3c:	20000326 	beq	r4,zero,182a4c <alt_printf+0x138>
                      alt_putchar(*s++);
  182a40:	b5800044 	addi	r22,r22,1
  182a44:	0182a840 	call	182a84 <alt_putchar>
  182a48:	003ffb06 	br	182a38 <alt_printf+0x124>
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
                } 
                else if (c == 'c')
                {
                    int v = va_arg(args, int);
  182a4c:	8805883a 	mov	r2,r17
  182a50:	003fc406 	br	182964 <alt_printf+0x50>
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
  182a54:	dfc00a17 	ldw	ra,40(sp)
  182a58:	df000917 	ldw	fp,36(sp)
  182a5c:	ddc00817 	ldw	r23,32(sp)
  182a60:	dd800717 	ldw	r22,28(sp)
  182a64:	dd400617 	ldw	r21,24(sp)
  182a68:	dd000517 	ldw	r20,20(sp)
  182a6c:	dcc00417 	ldw	r19,16(sp)
  182a70:	dc800317 	ldw	r18,12(sp)
  182a74:	dc400217 	ldw	r17,8(sp)
  182a78:	dc000117 	ldw	r16,4(sp)
  182a7c:	dec00e04 	addi	sp,sp,56
  182a80:	f800283a 	ret

00182a84 <alt_putchar>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
  182a84:	defffd04 	addi	sp,sp,-12
  182a88:	dc000115 	stw	r16,4(sp)
	char        c1 = (char)(c & 0xff);
    return write(STDOUT_FILENO,&c1,1);
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    char        c1 = (char)(c & 0xff);
  182a8c:	d9000005 	stb	r4,0(sp)
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
  182a90:	2021883a 	mov	r16,r4
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    char        c1 = (char)(c & 0xff);

    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
  182a94:	01000634 	movhi	r4,24
  182a98:	000f883a 	mov	r7,zero
  182a9c:	01800044 	movi	r6,1
  182aa0:	d80b883a 	mov	r5,sp
  182aa4:	210fbd04 	addi	r4,r4,16116
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
  182aa8:	dfc00215 	stw	ra,8(sp)
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    char        c1 = (char)(c & 0xff);

    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
  182aac:	0182b880 	call	182b88 <altera_avalon_jtag_uart_write>
  182ab0:	00ffffc4 	movi	r3,-1
  182ab4:	10c00126 	beq	r2,r3,182abc <alt_putchar+0x38>
        return -1;
    }
    return c;
  182ab8:	8005883a 	mov	r2,r16
#else
    return putchar(c);
#endif
#endif
}
  182abc:	dfc00217 	ldw	ra,8(sp)
  182ac0:	dc000117 	ldw	r16,4(sp)
  182ac4:	dec00304 	addi	sp,sp,12
  182ac8:	f800283a 	ret

00182acc <usleep>:
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
  return alt_busy_sleep(us);
  182acc:	01831801 	jmpi	183180 <alt_busy_sleep>

00182ad0 <write>:
#if !defined(ALT_STDOUT_PRESENT) && !defined(ALT_STDERR_PRESENT)
    /* Generate a link time warning, should this function ever be called. */
    ALT_STUB_WARNING(write);
#endif

    switch (file) {
  182ad0:	00800044 	movi	r2,1
  182ad4:	20800226 	beq	r4,r2,182ae0 <write+0x10>
  182ad8:	00800084 	movi	r2,2
  182adc:	2080041e 	bne	r4,r2,182af0 <write+0x20>
    case 1: /* stdout file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, ptr, len, 0);
#endif /* ALT_STDOUT_PRESENT */
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
  182ae0:	01000634 	movhi	r4,24
  182ae4:	000f883a 	mov	r7,zero
  182ae8:	210fbd04 	addi	r4,r4,16116
  182aec:	0182b881 	jmpi	182b88 <altera_avalon_jtag_uart_write>

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  return ((alt_errno) ? alt_errno() : &errno);
  182af0:	d0a00517 	ldw	r2,-32748(gp)
  182af4:	10000926 	beq	r2,zero,182b1c <write+0x4c>
 * Provide minimal version that just writes to the stdout/stderr devices
 * when provided.
 */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
  182af8:	deffff04 	addi	sp,sp,-4
  182afc:	dfc00015 	stw	ra,0(sp)
  182b00:	103ee83a 	callr	r2
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
#endif /* ALT_STDERR_PRESENT */
    default:
        ALT_ERRNO = EBADFD;
  182b04:	00c01444 	movi	r3,81
  182b08:	10c00015 	stw	r3,0(r2)
        return -1;
    }
}
  182b0c:	00bfffc4 	movi	r2,-1
  182b10:	dfc00017 	ldw	ra,0(sp)
  182b14:	dec00104 	addi	sp,sp,4
  182b18:	f800283a 	ret
  182b1c:	d0a23b04 	addi	r2,gp,-30484
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
#endif /* ALT_STDERR_PRESENT */
    default:
        ALT_ERRNO = EBADFD;
  182b20:	00c01444 	movi	r3,81
  182b24:	10c00015 	stw	r3,0(r2)
        return -1;
    }
}
  182b28:	00bfffc4 	movi	r2,-1
  182b2c:	f800283a 	ret

00182b30 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
  182b30:	deffff04 	addi	sp,sp,-4
  182b34:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2, nios2);
  182b38:	01833e80 	call	1833e8 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
  182b3c:	00800044 	movi	r2,1
  182b40:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
  182b44:	dfc00017 	ldw	ra,0(sp)
  182b48:	dec00104 	addi	sp,sp,4
  182b4c:	f800283a 	ret

00182b50 <alt_sys_init>:
 */

void alt_sys_init( void )
{
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_RX, sgdma_rx);
  182b50:	01000634 	movhi	r4,24
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
  182b54:	deffff04 	addi	sp,sp,-4
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_RX, sgdma_rx);
  182b58:	000d883a 	mov	r6,zero
  182b5c:	000b883a 	mov	r5,zero
  182b60:	210faf04 	addi	r4,r4,16060
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
  182b64:	dfc00015 	stw	ra,0(sp)
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_RX, sgdma_rx);
  182b68:	01830fc0 	call	1830fc <alt_avalon_sgdma_init>
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_TX, sgdma_tx);
  182b6c:	01000634 	movhi	r4,24
  182b70:	01800044 	movi	r6,1
  182b74:	000b883a 	mov	r5,zero
  182b78:	210fa304 	addi	r4,r4,16012
    ALTERA_ETH_TSE_INIT ( ETH_TSE, eth_tse);
}
  182b7c:	dfc00017 	ldw	ra,0(sp)
  182b80:	dec00104 	addi	sp,sp,4

void alt_sys_init( void )
{
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_RX, sgdma_rx);
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_TX, sgdma_tx);
  182b84:	01830fc1 	jmpi	1830fc <alt_avalon_sgdma_init>

00182b88 <altera_avalon_jtag_uart_write>:
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  unsigned int base = sp->base;
  182b88:	21000017 	ldw	r4,0(r4)
 * one FIFOs worth of data.  But you said you didn't want to use interrupts :-)
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  182b8c:	3005883a 	mov	r2,r6
  unsigned int base = sp->base;

  const char * end = ptr + count;
  182b90:	298d883a 	add	r6,r5,r6

  while (ptr < end)
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
  182b94:	21c00104 	addi	r7,r4,4
{
  unsigned int base = sp->base;

  const char * end = ptr + count;

  while (ptr < end)
  182b98:	2980072e 	bgeu	r5,r6,182bb8 <altera_avalon_jtag_uart_write+0x30>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
  182b9c:	38c00037 	ldwio	r3,0(r7)
  182ba0:	18ffffec 	andhi	r3,r3,65535
  182ba4:	183ffc26 	beq	r3,zero,182b98 <altera_avalon_jtag_uart_write+0x10>
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);
  182ba8:	28c00007 	ldb	r3,0(r5)
  182bac:	20c00035 	stwio	r3,0(r4)
  182bb0:	29400044 	addi	r5,r5,1
  182bb4:	003ff806 	br	182b98 <altera_avalon_jtag_uart_write+0x10>

  return count;
}
  182bb8:	f800283a 	ret

00182bbc <alt_avalon_sgdma_irq>:
   * Note: This is explicitly done before calling user interrupt-handling
   * code rather than after; if user ISR code initiates another SGDMA
   * transfer which completes quickly, reading the control register after
   * the callback routine may result in a lost interrupt.
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
  182bbc:	20800317 	ldw	r2,12(r4)
  182bc0:	10800404 	addi	r2,r2,16
  182bc4:	10c00037 	ldwio	r3,0(r2)
  182bc8:	18e00034 	orhi	r3,r3,32768
  182bcc:	10c00035 	stwio	r3,0(r2)
    IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) | 0x80000000);
  
  /* Dummy read to ensure IRQ is negated before the ISR returns */
  IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  182bd0:	20800317 	ldw	r2,12(r4)
  182bd4:	10800437 	ldwio	r2,16(r2)
   * Other interrupts are explicitly disabled if callbacks
   * are registered because there is no guarantee that they are 
   * preemption-safe. This allows the driver to support 
   * interrupt preemption.
   */
  if(dev->callback) {
  182bd8:	20c00917 	ldw	r3,36(r4)
  182bdc:	18000d26 	beq	r3,zero,182c14 <alt_avalon_sgdma_irq+0x58>
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_sgdma_irq(void *context)
#else
static void alt_avalon_sgdma_irq(void *context, alt_u32 id)
#endif
{
  182be0:	defffe04 	addi	sp,sp,-8
  182be4:	dfc00115 	stw	ra,4(sp)
  182be8:	dc000015 	stw	r16,0(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  182bec:	0021303a 	rdctl	r16,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  182bf0:	00bfff84 	movi	r2,-2
  182bf4:	8084703a 	and	r2,r16,r2
  182bf8:	1001703a 	wrctl	status,r2
   * preemption-safe. This allows the driver to support 
   * interrupt preemption.
   */
  if(dev->callback) {
    cpu_sr = alt_irq_disable_all();
    (dev->callback)(dev->callback_context);
  182bfc:	21000a17 	ldw	r4,40(r4)
  182c00:	183ee83a 	callr	r3
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  182c04:	8001703a 	wrctl	status,r16
    alt_irq_enable_all(cpu_sr);
  }
}
  182c08:	dfc00117 	ldw	ra,4(sp)
  182c0c:	dc000017 	ldw	r16,0(sp)
  182c10:	dec00204 	addi	sp,sp,8
  182c14:	f800283a 	ret

00182c18 <alt_avalon_sgdma_do_async_transfer>:
  alt_sgdma_descriptor *desc)
{
  alt_u32 control;

  /* Return with error immediately if controller is busy */
  if( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
  182c18:	20c00317 	ldw	r3,12(r4)
  182c1c:	18800037 	ldwio	r2,0(r3)
  182c20:	1080040c 	andi	r2,r2,16
  182c24:	1000191e 	bne	r2,zero,182c8c <alt_avalon_sgdma_do_async_transfer+0x74>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    return -EBUSY;
  }

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
  182c28:	18c00404 	addi	r3,r3,16
  182c2c:	19c00037 	ldwio	r7,0(r3)
  182c30:	01bff7c4 	movi	r6,-33
  182c34:	398c703a 	and	r6,r7,r6
  182c38:	19800035 	stwio	r6,0(r3)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
  182c3c:	20c00317 	ldw	r3,12(r4)
  182c40:	01803fc4 	movi	r6,255
  182c44:	19800035 	stwio	r6,0(r3)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
  182c48:	20c00317 	ldw	r3,12(r4)
  182c4c:	19400835 	stwio	r5,32(r3)
  182c50:	20c00317 	ldw	r3,12(r4)
   *  - Stop on an error with any particular descriptor
   *  - Include any control register bits registered with along with
   *    the callback routine (effectively, interrupts are controlled
   *    via the control bits set during callback-register time).
   */
  if(dev->callback) {
  182c54:	21400917 	ldw	r5,36(r4)
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  182c58:	18c00404 	addi	r3,r3,16
   *  - Stop on an error with any particular descriptor
   *  - Include any control register bits registered with along with
   *    the callback routine (effectively, interrupts are controlled
   *    via the control bits set during callback-register time).
   */
  if(dev->callback) {
  182c5c:	28000526 	beq	r5,zero,182c74 <alt_avalon_sgdma_do_async_transfer+0x5c>
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  182c60:	19400037 	ldwio	r5,0(r3)

    control |= (dev->chain_control                          |
                ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK  );

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
  182c64:	21000b17 	ldw	r4,44(r4)
  182c68:	21001814 	ori	r4,r4,96
  182c6c:	2148b03a 	or	r4,r4,r5
  182c70:	00000406 	br	182c84 <alt_avalon_sgdma_do_async_transfer+0x6c>
   *   - Run
   *   - Stop on an error with any particular descriptor
   *   - Disable interrupt generation
   */
  else {
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  182c74:	19400037 	ldwio	r5,0(r3)
  182c78:	013ffbc4 	movi	r4,-17
  182c7c:	2908703a 	and	r4,r5,r4

    control |= (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK );
    control &= ~ALTERA_AVALON_SGDMA_CONTROL_IE_GLOBAL_MSK;

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
  182c80:	21001814 	ori	r4,r4,96
  182c84:	19000035 	stwio	r4,0(r3)
  182c88:	f800283a 	ret
  alt_u32 control;

  /* Return with error immediately if controller is busy */
  if( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    return -EBUSY;
  182c8c:	00bffc04 	movi	r2,-16
  /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
  return 0;
}
  182c90:	f800283a 	ret

00182c94 <alt_avalon_sgdma_do_sync_transfer>:
  alt_sgdma_descriptor *desc)
{
  alt_u8 status;

  /* Wait for any pending transfers to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
  182c94:	20c00317 	ldw	r3,12(r4)
  182c98:	18800037 	ldwio	r2,0(r3)
  182c9c:	1080040c 	andi	r2,r2,16
  182ca0:	103ffc1e 	bne	r2,zero,182c94 <alt_avalon_sgdma_do_sync_transfer>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );


  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
  182ca4:	18c00404 	addi	r3,r3,16
  182ca8:	19800037 	ldwio	r6,0(r3)
  182cac:	00bff7c4 	movi	r2,-33
  182cb0:	308c703a 	and	r6,r6,r2
  182cb4:	19800035 	stwio	r6,0(r3)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
  182cb8:	20c00317 	ldw	r3,12(r4)
  182cbc:	01803fc4 	movi	r6,255
  182cc0:	19800035 	stwio	r6,0(r3)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
  182cc4:	20c00317 	ldw	r3,12(r4)
  182cc8:	19400835 	stwio	r5,32(r3)
   * Set up SGDMA controller to:
   * - Disable interrupt generation
   * - Run once a valid descriptor is written to controller
   * - Stop on an error with any particular descriptor
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
  182ccc:	20c00317 	ldw	r3,12(r4)
  182cd0:	18c00404 	addi	r3,r3,16
  182cd4:	19400037 	ldwio	r5,0(r3)
  182cd8:	29401814 	ori	r5,r5,96
  182cdc:	19400035 	stwio	r5,0(r3)
    (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK |
     ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK | 
     IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base)) );

  /* Wait for the descriptor (chain) to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
  182ce0:	20c00317 	ldw	r3,12(r4)
  182ce4:	19400037 	ldwio	r5,0(r3)
  182ce8:	2940040c 	andi	r5,r5,16
  182cec:	283ffc1e 	bne	r5,zero,182ce0 <alt_avalon_sgdma_do_sync_transfer+0x4c>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
  182cf0:	18c00404 	addi	r3,r3,16
  182cf4:	19400037 	ldwio	r5,0(r3)
  182cf8:	2884703a 	and	r2,r5,r2
  182cfc:	18800035 	stwio	r2,0(r3)
    (IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) &
     ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK) );

  /* Get & clear status register contents */
  status = IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base);
  182d00:	20c00317 	ldw	r3,12(r4)
  182d04:	18800037 	ldwio	r2,0(r3)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
  182d08:	01003fc4 	movi	r4,255
  182d0c:	19000035 	stwio	r4,0(r3)

  return status;
}
  182d10:	f800283a 	ret

00182d14 <alt_avalon_sgdma_register_callback>:
  alt_sgdma_dev *dev,
  alt_avalon_sgdma_callback callback,
  alt_u32 chain_control,
  void *context)
{
  dev->callback         = callback;
  182d14:	21400915 	stw	r5,36(r4)
  dev->callback_context = context;
  182d18:	21c00a15 	stw	r7,40(r4)
  dev->chain_control    = chain_control;
  182d1c:	21800b15 	stw	r6,44(r4)
  182d20:	f800283a 	ret

00182d24 <alt_avalon_sgdma_start>:
 */
void alt_avalon_sgdma_start(alt_sgdma_dev *dev)
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  182d24:	20800317 	ldw	r2,12(r4)
  182d28:	10800404 	addi	r2,r2,16
  182d2c:	10c00037 	ldwio	r3,0(r2)
  control |= ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
  182d30:	18c00814 	ori	r3,r3,32
  182d34:	10c00035 	stwio	r3,0(r2)
  182d38:	f800283a 	ret

00182d3c <alt_avalon_sgdma_stop>:
 */
void alt_avalon_sgdma_stop(alt_sgdma_dev *dev)
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  182d3c:	20800317 	ldw	r2,12(r4)
  182d40:	10800404 	addi	r2,r2,16
  182d44:	11000037 	ldwio	r4,0(r2)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
  182d48:	00fff7c4 	movi	r3,-33
  182d4c:	20c6703a 	and	r3,r4,r3
  182d50:	10c00035 	stwio	r3,0(r2)
  182d54:	f800283a 	ret

00182d58 <alt_avalon_sgdma_check_descriptor_status>:
 *   normally. Or, various error conditions defined in <errno.h>
 */
int alt_avalon_sgdma_check_descriptor_status(alt_sgdma_descriptor *desc)
{
  /* Errors take precedence */
  if( IORD_8DIRECT(&desc->status, 0) &
  182d58:	208007a3 	ldbuio	r2,30(r4)
  182d5c:	10801fcc 	andi	r2,r2,127
  182d60:	1000041e 	bne	r2,zero,182d74 <alt_avalon_sgdma_check_descriptor_status+0x1c>
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) {
    return -EIO;
  }

  if( IORD_8DIRECT(&desc->control, 0) &
  182d64:	208007e3 	ldbuio	r2,31(r4)
  182d68:	1080200c 	andi	r2,r2,128
  182d6c:	1000031e 	bne	r2,zero,182d7c <alt_avalon_sgdma_check_descriptor_status+0x24>
  182d70:	f800283a 	ret
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_OVERFLOW_MSK |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) {
    return -EIO;
  182d74:	00bffec4 	movi	r2,-5
  182d78:	f800283a 	ret
  }

  if( IORD_8DIRECT(&desc->control, 0) &
      ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK) {
    return -EINPROGRESS;
  182d7c:	00bfe244 	movi	r2,-119
  }

    return 0;
}
  182d80:	f800283a 	ret

00182d84 <alt_avalon_sgdma_open>:
 * Returns:
 * - Pointer to SGDMA device instance struct, or null if the device
 *   could not be opened.
 */
alt_sgdma_dev* alt_avalon_sgdma_open (const char* name)
{
  182d84:	defffe04 	addi	sp,sp,-8
  alt_sgdma_dev* dev;

  dev = (alt_sgdma_dev*) alt_find_dev (name, &alt_sgdma_list);
  182d88:	d1600304 	addi	r5,gp,-32756
 * Returns:
 * - Pointer to SGDMA device instance struct, or null if the device
 *   could not be opened.
 */
alt_sgdma_dev* alt_avalon_sgdma_open (const char* name)
{
  182d8c:	dc000015 	stw	r16,0(sp)
  182d90:	dfc00115 	stw	ra,4(sp)
  alt_sgdma_dev* dev;

  dev = (alt_sgdma_dev*) alt_find_dev (name, &alt_sgdma_list);
  182d94:	018327c0 	call	18327c <alt_find_dev>
  182d98:	1021883a 	mov	r16,r2

  if (NULL == dev) {
  182d9c:	1000071e 	bne	r2,zero,182dbc <alt_avalon_sgdma_open+0x38>
  182da0:	d0a00517 	ldw	r2,-32748(gp)
  182da4:	10000226 	beq	r2,zero,182db0 <alt_avalon_sgdma_open+0x2c>
  182da8:	103ee83a 	callr	r2
  182dac:	00000106 	br	182db4 <alt_avalon_sgdma_open+0x30>
  182db0:	d0a23b04 	addi	r2,gp,-30484
    ALT_ERRNO = ENODEV;
  182db4:	00c004c4 	movi	r3,19
  182db8:	10c00015 	stw	r3,0(r2)
  }

  return dev;
}
  182dbc:	8005883a 	mov	r2,r16
  182dc0:	dfc00117 	ldw	ra,4(sp)
  182dc4:	dc000017 	ldw	r16,0(sp)
  182dc8:	dec00204 	addi	sp,sp,8
  182dcc:	f800283a 	ret

00182dd0 <alt_avalon_sgdma_enable_desc_poll>:
 */
void alt_avalon_sgdma_enable_desc_poll(alt_sgdma_dev *dev, alt_u32 frequency)
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  182dd0:	20c00317 	ldw	r3,12(r4)
  182dd4:	18c00404 	addi	r3,r3,16
  182dd8:	19000037 	ldwio	r4,0(r3)
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
  182ddc:	00a00434 	movhi	r2,32784
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
            ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
  182de0:	280a953a 	slli	r5,r5,20
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
  182de4:	10bfffc4 	addi	r2,r2,-1
  182de8:	2084703a 	and	r2,r4,r2
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
            ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
  182dec:	295ffc2c 	andhi	r5,r5,32752
  182df0:	29400134 	orhi	r5,r5,4
  182df4:	288ab03a 	or	r5,r5,r2
  182df8:	19400035 	stwio	r5,0(r3)
  182dfc:	f800283a 	ret

00182e00 <alt_avalon_sgdma_disable_desc_poll>:
 */
void alt_avalon_sgdma_disable_desc_poll(alt_sgdma_dev *dev)
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  182e00:	20800317 	ldw	r2,12(r4)
  182e04:	10800404 	addi	r2,r2,16
  182e08:	11000037 	ldwio	r4,0(r2)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK;

  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
  182e0c:	00ffff34 	movhi	r3,65532
  182e10:	18ffffc4 	addi	r3,r3,-1
  182e14:	20c6703a 	and	r3,r4,r3
  182e18:	10c00035 	stwio	r3,0(r2)
  182e1c:	f800283a 	ret

00182e20 <alt_avalon_sgdma_construct_descriptor_burst>:
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
  182e20:	288007c3 	ldbu	r2,31(r5)
  int                   read_fixed,
  int                   write_fixed_or_sop,
  int                   read_burst,
  int                   write_burst,
  alt_u8                atlantic_channel)
{
  182e24:	d8c00617 	ldw	r3,24(sp)
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
  182e28:	10801fcc 	andi	r2,r2,127
  182e2c:	288007e5 	stbio	r2,31(r5)
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  182e30:	3004d23a 	srli	r2,r6,8
  182e34:	21800005 	stb	r6,0(r4)
  desc->write_addr               = write_addr;
  182e38:	21c00205 	stb	r7,8(r4)
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  182e3c:	20800045 	stb	r2,1(r4)
  182e40:	3004d43a 	srli	r2,r6,16
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  182e44:	21400405 	stb	r5,16(r4)
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  182e48:	300cd63a 	srli	r6,r6,24
  182e4c:	20800085 	stb	r2,2(r4)
  desc->write_addr               = write_addr;
  182e50:	3804d23a 	srli	r2,r7,8
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  182e54:	218000c5 	stb	r6,3(r4)
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
  182e58:	20000105 	stb	zero,4(r4)
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  182e5c:	20800245 	stb	r2,9(r4)
  182e60:	3804d43a 	srli	r2,r7,16
  182e64:	380ed63a 	srli	r7,r7,24
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
  182e68:	20000145 	stb	zero,5(r4)
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  182e6c:	20800285 	stb	r2,10(r4)
  desc->next                     = (alt_u32 *) next;
  182e70:	2804d23a 	srli	r2,r5,8
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  182e74:	21c002c5 	stb	r7,11(r4)
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
  182e78:	20000185 	stb	zero,6(r4)
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  182e7c:	20800445 	stb	r2,17(r4)
  182e80:	2804d43a 	srli	r2,r5,16
  182e84:	280ad63a 	srli	r5,r5,24
  desc->read_addr_pad            = 0x0;
  182e88:	200001c5 	stb	zero,7(r4)
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  182e8c:	20800485 	stb	r2,18(r4)
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
  desc->next_pad                 = 0x0;
  desc->bytes_to_transfer        = length_or_eop;
  182e90:	d880000b 	ldhu	r2,0(sp)
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  182e94:	214004c5 	stb	r5,19(r4)
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
  182e98:	20000305 	stb	zero,12(r4)
  desc->next_pad                 = 0x0;
  desc->bytes_to_transfer        = length_or_eop;
  182e9c:	20800605 	stb	r2,24(r4)
  182ea0:	1004d23a 	srli	r2,r2,8

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
  182ea4:	20000345 	stb	zero,13(r4)
  182ea8:	20000385 	stb	zero,14(r4)
  desc->next_pad                 = 0x0;
  desc->bytes_to_transfer        = length_or_eop;
  182eac:	20800645 	stb	r2,25(r4)
  desc->actual_bytes_transferred = 0;
  desc->status                   = 0x0;

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
  182eb0:	d8800417 	ldw	r2,16(sp)

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
  182eb4:	200003c5 	stb	zero,15(r4)
  desc->next_pad                 = 0x0;
  182eb8:	20000505 	stb	zero,20(r4)
  182ebc:	20000545 	stb	zero,21(r4)
  182ec0:	20000585 	stb	zero,22(r4)
  182ec4:	200005c5 	stb	zero,23(r4)
  desc->bytes_to_transfer        = length_or_eop;
  desc->actual_bytes_transferred = 0;
  182ec8:	20000705 	stb	zero,28(r4)
  182ecc:	20000745 	stb	zero,29(r4)
  desc->status                   = 0x0;
  182ed0:	20000785 	stb	zero,30(r4)

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
  182ed4:	20800685 	stb	r2,26(r4)
  desc->write_burst              = write_burst;
  182ed8:	d8800517 	ldw	r2,20(sp)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
  182edc:	d9400117 	ldw	r5,4(sp)
  desc->actual_bytes_transferred = 0;
  desc->status                   = 0x0;

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
  desc->write_burst              = write_burst;
  182ee0:	208006c5 	stb	r2,27(r4)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
  182ee4:	d8800217 	ldw	r2,8(sp)
  182ee8:	280ac03a 	cmpne	r5,r5,zero
  182eec:	297fe004 	addi	r5,r5,-128
  182ef0:	1004c03a 	cmpne	r2,r2,zero
  182ef4:	1004907a 	slli	r2,r2,1
  182ef8:	2884b03a 	or	r2,r5,r2
  182efc:	d9400317 	ldw	r5,12(sp)
  182f00:	280ac03a 	cmpne	r5,r5,zero
  182f04:	280a90ba 	slli	r5,r5,2
  182f08:	114ab03a 	or	r5,r2,r5
  182f0c:	18803fcc 	andi	r2,r3,255
  182f10:	10000326 	beq	r2,zero,182f20 <alt_avalon_sgdma_construct_descriptor_burst+0x100>
  182f14:	18c003cc 	andi	r3,r3,15
  182f18:	180490fa 	slli	r2,r3,3
  182f1c:	00000106 	br	182f24 <alt_avalon_sgdma_construct_descriptor_burst+0x104>
  182f20:	0005883a 	mov	r2,zero
  182f24:	2884b03a 	or	r2,r5,r2
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to.
   */
  alt_dcache_flush(desc, sizeof(alt_sgdma_descriptor));
  182f28:	01400804 	movi	r5,32
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
  182f2c:	208007c5 	stb	r2,31(r4)
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to.
   */
  alt_dcache_flush(desc, sizeof(alt_sgdma_descriptor));
  182f30:	01832081 	jmpi	183208 <alt_dcache_flush>

00182f34 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>:
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed,
  int                   read_burst,
  int                   write_burst)
{
  182f34:	defff804 	addi	sp,sp,-32
  alt_avalon_sgdma_construct_descriptor_burst(
  182f38:	d8800c17 	ldw	r2,48(sp)
  182f3c:	d8000615 	stw	zero,24(sp)
  182f40:	d8000115 	stw	zero,4(sp)
  182f44:	d8800515 	stw	r2,20(sp)
  182f48:	d8800b17 	ldw	r2,44(sp)
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed,
  int                   read_burst,
  int                   write_burst)
{
  182f4c:	dfc00715 	stw	ra,28(sp)
  alt_avalon_sgdma_construct_descriptor_burst(
  182f50:	d8800415 	stw	r2,16(sp)
  182f54:	d8800a17 	ldw	r2,40(sp)
  182f58:	d8800315 	stw	r2,12(sp)
  182f5c:	d8800917 	ldw	r2,36(sp)
  182f60:	d8800215 	stw	r2,8(sp)
  182f64:	d880080b 	ldhu	r2,32(sp)
  182f68:	d8800015 	stw	r2,0(sp)
  182f6c:	0182e200 	call	182e20 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    write_fixed,
    read_burst,
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in mem-to-mem mode
}
  182f70:	dfc00717 	ldw	ra,28(sp)
  182f74:	dec00804 	addi	sp,sp,32
  182f78:	f800283a 	ret

00182f7c <alt_avalon_sgdma_construct_mem_to_mem_desc>:
  alt_u32              *read_addr,
  alt_u32              *write_addr,
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed)
{
  182f7c:	defffa04 	addi	sp,sp,-24
  alt_avalon_sgdma_construct_mem_to_mem_desc_burst(desc, next, read_addr, 
  182f80:	d8800817 	ldw	r2,32(sp)
  182f84:	d8000415 	stw	zero,16(sp)
  182f88:	d8000315 	stw	zero,12(sp)
  182f8c:	d8800215 	stw	r2,8(sp)
  182f90:	d8800717 	ldw	r2,28(sp)
  alt_u32              *read_addr,
  alt_u32              *write_addr,
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed)
{
  182f94:	dfc00515 	stw	ra,20(sp)
  alt_avalon_sgdma_construct_mem_to_mem_desc_burst(desc, next, read_addr, 
  182f98:	d8800115 	stw	r2,4(sp)
  182f9c:	d880060b 	ldhu	r2,24(sp)
  182fa0:	d8800015 	stw	r2,0(sp)
  182fa4:	0182f340 	call	182f34 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>
    write_addr, length, read_fixed, write_fixed, 0, 0);
}
  182fa8:	dfc00517 	ldw	ra,20(sp)
  182fac:	dec00604 	addi	sp,sp,24
  182fb0:	f800283a 	ret

00182fb4 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>:
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed,
  int                   write_burst)
{
  182fb4:	defff804 	addi	sp,sp,-32
  alt_avalon_sgdma_construct_descriptor_burst(
  182fb8:	d8800917 	ldw	r2,36(sp)
  182fbc:	39ffffcc 	andi	r7,r7,65535
  182fc0:	d9c00015 	stw	r7,0(sp)
  182fc4:	d8800515 	stw	r2,20(sp)
  182fc8:	d8800817 	ldw	r2,32(sp)
  182fcc:	300f883a 	mov	r7,r6
  182fd0:	d8000615 	stw	zero,24(sp)
  182fd4:	d8000415 	stw	zero,16(sp)
  182fd8:	d8800315 	stw	r2,12(sp)
  182fdc:	d8000215 	stw	zero,8(sp)
  182fe0:	d8000115 	stw	zero,4(sp)
  182fe4:	000d883a 	mov	r6,zero
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed,
  int                   write_burst)
{
  182fe8:	dfc00715 	stw	ra,28(sp)
  alt_avalon_sgdma_construct_descriptor_burst(
  182fec:	0182e200 	call	182e20 <alt_avalon_sgdma_construct_descriptor_burst>
    0x0,            // Read fixed: N/A in stream-to-mem mode
    write_fixed,
    0,              // Read_burst : N/A in stream-to-mem mode
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in stream-to-mem mode
}
  182ff0:	dfc00717 	ldw	ra,28(sp)
  182ff4:	dec00804 	addi	sp,sp,32
  182ff8:	f800283a 	ret

00182ffc <alt_avalon_sgdma_construct_stream_to_mem_desc>:
  alt_sgdma_descriptor *desc,
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed)
{
  182ffc:	defffd04 	addi	sp,sp,-12
  alt_avalon_sgdma_construct_stream_to_mem_desc_burst(desc, next, write_addr, 
  183000:	d8800317 	ldw	r2,12(sp)
  183004:	d8000115 	stw	zero,4(sp)
  183008:	39ffffcc 	andi	r7,r7,65535
  18300c:	d8800015 	stw	r2,0(sp)
  alt_sgdma_descriptor *desc,
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed)
{
  183010:	dfc00215 	stw	ra,8(sp)
  alt_avalon_sgdma_construct_stream_to_mem_desc_burst(desc, next, write_addr, 
  183014:	0182fb40 	call	182fb4 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>
    length_or_eop, write_fixed, 0);
}
  183018:	dfc00217 	ldw	ra,8(sp)
  18301c:	dec00304 	addi	sp,sp,12
  183020:	f800283a 	ret

00183024 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>:
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  int                   read_burst,
  alt_u8                atlantic_channel)
{
  183024:	defff804 	addi	sp,sp,-32
  alt_avalon_sgdma_construct_descriptor_burst(
  183028:	d8800c03 	ldbu	r2,48(sp)
  18302c:	39ffffcc 	andi	r7,r7,65535
  183030:	d9c00015 	stw	r7,0(sp)
  183034:	d8800615 	stw	r2,24(sp)
  183038:	d8800b17 	ldw	r2,44(sp)
  18303c:	d8000515 	stw	zero,20(sp)
  183040:	000f883a 	mov	r7,zero
  183044:	d8800415 	stw	r2,16(sp)
  183048:	d8800917 	ldw	r2,36(sp)
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  int                   read_burst,
  alt_u8                atlantic_channel)
{
  18304c:	dfc00715 	stw	ra,28(sp)
  alt_avalon_sgdma_construct_descriptor_burst(
  183050:	d8800315 	stw	r2,12(sp)
  183054:	d8800817 	ldw	r2,32(sp)
  183058:	d8800215 	stw	r2,8(sp)
  18305c:	d8800a17 	ldw	r2,40(sp)
  183060:	d8800115 	stw	r2,4(sp)
  183064:	0182e200 	call	182e20 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    generate_sop,
    read_burst,
    0,                 // Write_burst : N/A in mem-to-stream mode
    atlantic_channel);
}
  183068:	dfc00717 	ldw	ra,28(sp)
  18306c:	dec00804 	addi	sp,sp,32
  183070:	f800283a 	ret

00183074 <alt_avalon_sgdma_construct_mem_to_stream_desc>:
  alt_u16               length,
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  alt_u8                atlantic_channel)
{
  183074:	defffa04 	addi	sp,sp,-24
  alt_avalon_sgdma_construct_mem_to_stream_desc_burst(desc, next, read_addr, 
  183078:	d8800903 	ldbu	r2,36(sp)
  18307c:	d8000315 	stw	zero,12(sp)
  183080:	39ffffcc 	andi	r7,r7,65535
  183084:	d8800415 	stw	r2,16(sp)
  183088:	d8800817 	ldw	r2,32(sp)
  alt_u16               length,
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  alt_u8                atlantic_channel)
{
  18308c:	dfc00515 	stw	ra,20(sp)
  alt_avalon_sgdma_construct_mem_to_stream_desc_burst(desc, next, read_addr, 
  183090:	d8800215 	stw	r2,8(sp)
  183094:	d8800717 	ldw	r2,28(sp)
  183098:	d8800115 	stw	r2,4(sp)
  18309c:	d8800617 	ldw	r2,24(sp)
  1830a0:	d8800015 	stw	r2,0(sp)
  1830a4:	01830240 	call	183024 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>
    length, read_fixed, generate_sop, generate_eop, 0, atlantic_channel);

}
  1830a8:	dfc00517 	ldw	ra,20(sp)
  1830ac:	dec00604 	addi	sp,sp,24
  1830b0:	f800283a 	ret

001830b4 <alt_avalon_sgdma_construct_descriptor>:
  alt_u16               length_or_eop,
  int                   generate_eop,
  int                   read_fixed,
  int                   write_fixed_or_sop,
  alt_u8                atlantic_channel)
{
  1830b4:	defff804 	addi	sp,sp,-32
  alt_avalon_sgdma_construct_descriptor_burst(desc, next, read_addr, 
  1830b8:	d8800c03 	ldbu	r2,48(sp)
  1830bc:	d8000515 	stw	zero,20(sp)
  1830c0:	d8000415 	stw	zero,16(sp)
  1830c4:	d8800615 	stw	r2,24(sp)
  1830c8:	d8800b17 	ldw	r2,44(sp)
  alt_u16               length_or_eop,
  int                   generate_eop,
  int                   read_fixed,
  int                   write_fixed_or_sop,
  alt_u8                atlantic_channel)
{
  1830cc:	dfc00715 	stw	ra,28(sp)
  alt_avalon_sgdma_construct_descriptor_burst(desc, next, read_addr, 
  1830d0:	d8800315 	stw	r2,12(sp)
  1830d4:	d8800a17 	ldw	r2,40(sp)
  1830d8:	d8800215 	stw	r2,8(sp)
  1830dc:	d8800917 	ldw	r2,36(sp)
  1830e0:	d8800115 	stw	r2,4(sp)
  1830e4:	d880080b 	ldhu	r2,32(sp)
  1830e8:	d8800015 	stw	r2,0(sp)
  1830ec:	0182e200 	call	182e20 <alt_avalon_sgdma_construct_descriptor_burst>
    write_addr, length_or_eop, generate_eop, read_fixed, write_fixed_or_sop, 
    0, 0, atlantic_channel);
}
  1830f0:	dfc00717 	ldw	ra,28(sp)
  1830f4:	dec00804 	addi	sp,sp,32
  1830f8:	f800283a 	ret

001830fc <alt_avalon_sgdma_init>:

  /* 
   * Halt any current transactions (reset the device)
   * SW reset is written twice per SGDMA documentation 
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
  1830fc:	20c00317 	ldw	r3,12(r4)
 * This routine disables interrupts, future descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_avalon_sgdma_init (alt_sgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
  183100:	defffb04 	addi	sp,sp,-20
  183104:	dc800315 	stw	r18,12(sp)
  183108:	dc400215 	stw	r17,8(sp)
  18310c:	dc000115 	stw	r16,4(sp)
  183110:	dfc00415 	stw	ra,16(sp)
  183114:	2021883a 	mov	r16,r4
  183118:	2823883a 	mov	r17,r5
  18311c:	3025883a 	mov	r18,r6

  /* 
   * Halt any current transactions (reset the device)
   * SW reset is written twice per SGDMA documentation 
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
  183120:	00800074 	movhi	r2,1
  183124:	18800435 	stwio	r2,16(r3)
    ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
  183128:	20c00317 	ldw	r3,12(r4)
  18312c:	18800435 	stwio	r2,16(r3)

  /*
   * Disable interrupts, halt future descriptor processing,
   * and clear status register content
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 0x0);
  183130:	20800317 	ldw	r2,12(r4)
  183134:	10000435 	stwio	zero,16(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
  183138:	20800317 	ldw	r2,12(r4)
  18313c:	00c03fc4 	movi	r3,255
  183140:	10c00035 	stwio	r3,0(r2)

  /* Register this instance of the SGDMA controller with HAL */
  alt_dev_llist_insert((alt_dev_llist*) dev, &alt_sgdma_list);
  183144:	d1600304 	addi	r5,gp,-32756
  183148:	01832100 	call	183210 <alt_dev_llist_insert>

  /* Install IRQ handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(ic_id, irq, alt_avalon_sgdma_irq, dev, 0x0);
  18314c:	01800634 	movhi	r6,24
  183150:	d8000015 	stw	zero,0(sp)
  183154:	800f883a 	mov	r7,r16
  183158:	318aef04 	addi	r6,r6,11196
  18315c:	900b883a 	mov	r5,r18
  183160:	8809883a 	mov	r4,r17
  183164:	01832f40 	call	1832f4 <alt_ic_isr_register>
#else
  alt_irq_register(irq, dev, alt_avalon_sgdma_irq);
#endif  
}
  183168:	dfc00417 	ldw	ra,16(sp)
  18316c:	dc800317 	ldw	r18,12(sp)
  183170:	dc400217 	ldw	r17,8(sp)
  183174:	dc000117 	ldw	r16,4(sp)
  183178:	dec00504 	addi	sp,sp,20
  18317c:	f800283a 	ret

00183180 <alt_busy_sleep>:
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
  183180:	014666b4 	movhi	r5,6554
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
  183184:	defffe04 	addi	sp,sp,-8
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
  183188:	29666644 	addi	r5,r5,-26215
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
  18318c:	dc000015 	stw	r16,0(sp)
  183190:	dfc00115 	stw	ra,4(sp)
  183194:	2021883a 	mov	r16,r4
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
  183198:	018274c0 	call	18274c <__udivsi3>
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  18319c:	10001026 	beq	r2,zero,1831e0 <alt_busy_sleep+0x60>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
  1831a0:	01600034 	movhi	r5,32768
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
  1831a4:	013999b4 	movhi	r4,58982
  1831a8:	0007883a 	mov	r3,zero
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
  1831ac:	297fffc4 	addi	r5,r5,-1
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
  1831b0:	211999c4 	addi	r4,r4,26215
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
  1831b4:	297fffc4 	addi	r5,r5,-1
  1831b8:	283ffe1e 	bne	r5,zero,1831b4 <alt_busy_sleep+0x34>
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
  1831bc:	18c00044 	addi	r3,r3,1
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
  1831c0:	8121883a 	add	r16,r16,r4
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
  1831c4:	18bffb16 	blt	r3,r2,1831b4 <alt_busy_sleep+0x34>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
  1831c8:	01400144 	movi	r5,5
  1831cc:	8009883a 	mov	r4,r16
  1831d0:	0181dcc0 	call	181dcc <__mulsi3>
  1831d4:	10bfffc4 	addi	r2,r2,-1
  1831d8:	103ffe1e 	bne	r2,zero,1831d4 <alt_busy_sleep+0x54>
  1831dc:	00000506 	br	1831f4 <alt_busy_sleep+0x74>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
  1831e0:	01400144 	movi	r5,5
  1831e4:	8009883a 	mov	r4,r16
  1831e8:	0181dcc0 	call	181dcc <__mulsi3>
  1831ec:	10bfffc4 	addi	r2,r2,-1
  1831f0:	00bffe16 	blt	zero,r2,1831ec <alt_busy_sleep+0x6c>
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
}
  1831f4:	0005883a 	mov	r2,zero
  1831f8:	dfc00117 	ldw	ra,4(sp)
  1831fc:	dc000017 	ldw	r16,0(sp)
  183200:	dec00204 	addi	sp,sp,8
  183204:	f800283a 	ret

00183208 <alt_dcache_flush>:
 *
 * Any dirty lines in the data cache are written back to memory.
 */

void alt_dcache_flush (void* start, alt_u32 len)
{
  183208:	f800283a 	ret

0018320c <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
  18320c:	f800283a 	ret

00183210 <alt_dev_llist_insert>:
{
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  183210:	20000226 	beq	r4,zero,18321c <alt_dev_llist_insert+0xc>
  183214:	20800217 	ldw	r2,8(r4)
  183218:	1000101e 	bne	r2,zero,18325c <alt_dev_llist_insert+0x4c>
  18321c:	d0a00517 	ldw	r2,-32748(gp)
  183220:	10000926 	beq	r2,zero,183248 <alt_dev_llist_insert+0x38>
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
  183224:	deffff04 	addi	sp,sp,-4
  183228:	dfc00015 	stw	ra,0(sp)
  18322c:	103ee83a 	callr	r2
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  {
    ALT_ERRNO = EINVAL;
  183230:	00c00584 	movi	r3,22
  183234:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
  183238:	00bffa84 	movi	r2,-22
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
}
  18323c:	dfc00017 	ldw	ra,0(sp)
  183240:	dec00104 	addi	sp,sp,4
  183244:	f800283a 	ret
  183248:	d0a23b04 	addi	r2,gp,-30484
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  {
    ALT_ERRNO = EINVAL;
  18324c:	00c00584 	movi	r3,22
  183250:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
  183254:	00bffa84 	movi	r2,-22
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
}
  183258:	f800283a 	ret

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  entry->next     = list->next;
  18325c:	28800017 	ldw	r2,0(r5)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  183260:	21400115 	stw	r5,4(r4)
  entry->next     = list->next;
  183264:	20800015 	stw	r2,0(r4)

  list->next->previous = entry;
  183268:	28800017 	ldw	r2,0(r5)
  18326c:	11000115 	stw	r4,4(r2)
  list->next           = entry;
  183270:	29000015 	stw	r4,0(r5)
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
  183274:	0005883a 	mov	r2,zero
  183278:	f800283a 	ret

0018327c <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
  18327c:	defffb04 	addi	sp,sp,-20
  183280:	dcc00315 	stw	r19,12(sp)
  183284:	dc800215 	stw	r18,8(sp)
  183288:	dc400115 	stw	r17,4(sp)
  18328c:	dc000015 	stw	r16,0(sp)
  183290:	dfc00415 	stw	ra,16(sp)
  183294:	2027883a 	mov	r19,r4
  183298:	2823883a 	mov	r17,r5
  alt_dev* next = (alt_dev*) llist->next;
  18329c:	2c000017 	ldw	r16,0(r5)
  alt_32 len;

  len  = strlen(name) + 1;
  1832a0:	0181ec80 	call	181ec8 <strlen>
  1832a4:	14800044 	addi	r18,r2,1
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
  1832a8:	84400726 	beq	r16,r17,1832c8 <alt_find_dev+0x4c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
  1832ac:	81000217 	ldw	r4,8(r16)
  1832b0:	900d883a 	mov	r6,r18
  1832b4:	980b883a 	mov	r5,r19
  1832b8:	01833f00 	call	1833f0 <memcmp>
  1832bc:	10000426 	beq	r2,zero,1832d0 <alt_find_dev+0x54>
    {
      /* match found */

      return next;
    }
    next = (alt_dev*) next->llist.next;
  1832c0:	84000017 	ldw	r16,0(r16)
  1832c4:	003ff806 	br	1832a8 <alt_find_dev+0x2c>
  }
  
  /* No match found */
  
  return NULL;
  1832c8:	0005883a 	mov	r2,zero
  1832cc:	00000106 	br	1832d4 <alt_find_dev+0x58>
  1832d0:	8005883a 	mov	r2,r16
}
  1832d4:	dfc00417 	ldw	ra,16(sp)
  1832d8:	dcc00317 	ldw	r19,12(sp)
  1832dc:	dc800217 	ldw	r18,8(sp)
  1832e0:	dc400117 	ldw	r17,4(sp)
  1832e4:	dc000017 	ldw	r16,0(sp)
  1832e8:	dec00504 	addi	sp,sp,20
  1832ec:	f800283a 	ret

001832f0 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
  1832f0:	f800283a 	ret

001832f4 <alt_ic_isr_register>:
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
  1832f4:	01833801 	jmpi	183380 <alt_iic_isr_register>

001832f8 <alt_ic_irq_enable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  1832f8:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  1832fc:	00bfff84 	movi	r2,-2
  183300:	2084703a 	and	r2,r4,r2
  183304:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active |= (1 << id);
  183308:	00c00044 	movi	r3,1
  18330c:	d0a23f17 	ldw	r2,-30468(gp)
  183310:	194a983a 	sll	r5,r3,r5
  183314:	288ab03a 	or	r5,r5,r2
  183318:	d1623f15 	stw	r5,-30468(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  18331c:	d0a23f17 	ldw	r2,-30468(gp)
  183320:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  183324:	2001703a 	wrctl	status,r4
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_enable(irq);
}
  183328:	0005883a 	mov	r2,zero
  18332c:	f800283a 	ret

00183330 <alt_ic_irq_disable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  183330:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  183334:	00bfff84 	movi	r2,-2
  183338:	2084703a 	and	r2,r4,r2
  18333c:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active &= ~(1 << id);
  183340:	00ffff84 	movi	r3,-2
  183344:	d0a23f17 	ldw	r2,-30468(gp)
  183348:	194a183a 	rol	r5,r3,r5
  18334c:	288a703a 	and	r5,r5,r2
  183350:	d1623f15 	stw	r5,-30468(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  183354:	d0a23f17 	ldw	r2,-30468(gp)
  183358:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  18335c:	2001703a 	wrctl	status,r4
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_disable(irq);
}
  183360:	0005883a 	mov	r2,zero
  183364:	f800283a 	ret

00183368 <alt_ic_irq_enabled>:
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
  183368:	000730fa 	rdctl	r3,ienable

    return (irq_enabled & (1 << irq)) ? 1: 0;
  18336c:	00800044 	movi	r2,1
  183370:	1144983a 	sll	r2,r2,r5
  183374:	10c4703a 	and	r2,r2,r3
}
  183378:	1004c03a 	cmpne	r2,r2,zero
  18337c:	f800283a 	ret

00183380 <alt_iic_isr_register>:
{
  int rc = -EINVAL;  
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  alt_irq_context status;

  if (id < ALT_NIRQ)
  183380:	00c007c4 	movi	r3,31
  183384:	19401616 	blt	r3,r5,1833e0 <alt_iic_isr_register+0x60>
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  183388:	defffe04 	addi	sp,sp,-8
  18338c:	dfc00115 	stw	ra,4(sp)
  183390:	dc000015 	stw	r16,0(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  183394:	0021303a 	rdctl	r16,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  183398:	00ffff84 	movi	r3,-2
  18339c:	80c6703a 	and	r3,r16,r3
  1833a0:	1801703a 	wrctl	status,r3
     * state.
     */

    status = alt_irq_disable_all();

    alt_irq[id].handler = isr;
  1833a4:	280490fa 	slli	r2,r5,3
  1833a8:	00c00634 	movhi	r3,24
  1833ac:	18d33b04 	addi	r3,r3,19692
  1833b0:	1885883a 	add	r2,r3,r2
  1833b4:	11800015 	stw	r6,0(r2)
    alt_irq[id].context = isr_context;
  1833b8:	11c00115 	stw	r7,4(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
  1833bc:	30000226 	beq	r6,zero,1833c8 <alt_iic_isr_register+0x48>
  1833c0:	01832f80 	call	1832f8 <alt_ic_irq_enable>
  1833c4:	00000106 	br	1833cc <alt_iic_isr_register+0x4c>
  1833c8:	01833300 	call	183330 <alt_ic_irq_disable>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  1833cc:	8001703a 	wrctl	status,r16

    alt_irq_enable_all(status);
  }

  return rc; 
}
  1833d0:	dfc00117 	ldw	ra,4(sp)
  1833d4:	dc000017 	ldw	r16,0(sp)
  1833d8:	dec00204 	addi	sp,sp,8
  1833dc:	f800283a 	ret
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  int rc = -EINVAL;  
  1833e0:	00bffa84 	movi	r2,-22
  1833e4:	f800283a 	ret

001833e8 <altera_nios2_gen2_irq_init>:
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
  1833e8:	000170fa 	wrctl	ienable,zero
  1833ec:	f800283a 	ret

001833f0 <memcmp>:
  1833f0:	218d883a 	add	r6,r4,r6
  1833f4:	21800826 	beq	r4,r6,183418 <memcmp+0x28>
  1833f8:	20800003 	ldbu	r2,0(r4)
  1833fc:	28c00003 	ldbu	r3,0(r5)
  183400:	10c00226 	beq	r2,r3,18340c <memcmp+0x1c>
  183404:	10c5c83a 	sub	r2,r2,r3
  183408:	f800283a 	ret
  18340c:	21000044 	addi	r4,r4,1
  183410:	29400044 	addi	r5,r5,1
  183414:	003ff706 	br	1833f4 <memcmp+0x4>
  183418:	0005883a 	mov	r2,zero
  18341c:	f800283a 	ret
