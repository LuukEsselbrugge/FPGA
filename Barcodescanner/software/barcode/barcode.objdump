
barcode.elf:     file format elf32-littlenios2
barcode.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x0018014c

Program Header:
    LOAD off    0x00001000 vaddr 0x00180000 paddr 0x00180000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00180020 paddr 0x00180020 align 2**12
         filesz 0x00003118 memsz 0x00003118 flags r-x
    LOAD off    0x00004138 vaddr 0x00183138 paddr 0x001839f4 align 2**12
         filesz 0x000008bc memsz 0x000008bc flags rw-
    LOAD off    0x000052b0 vaddr 0x001842b0 paddr 0x001842b0 align 2**12
         filesz 0x00000000 memsz 0x00000628 flags rw-
    LOAD off    0x00005000 vaddr 0x00008000 paddr 0x001848d8 align 2**12
         filesz 0x00000080 memsz 0x00000080 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00180000  00180000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   0000012c  00180020  00180020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00002d48  0018014c  0018014c  0000114c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000002a4  00182e94  00182e94  00003e94  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       000008bc  00183138  001839f4  00004138  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00000628  001842b0  001842b0  000052b0  2**2
                  ALLOC, SMALL_DATA
  6 .VideoRAM     00000000  00000000  00000000  00005080  2**0
                  CONTENTS
  7 .descriptor_memory 00000080  00008000  001848d8  00005000  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  8 .onchip_memory 00000000  00184958  00184958  00005080  2**0
                  CONTENTS
  9 .comment      00000023  00000000  00000000  00005080  2**0
                  CONTENTS, READONLY
 10 .debug_aranges 000005a8  00000000  00000000  000050a8  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   00007524  00000000  00000000  00005650  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 00002a80  00000000  00000000  0000cb74  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00002ed2  00000000  00000000  0000f5f4  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00000a00  00000000  00000000  000124c8  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00001ba1  00000000  00000000  00012ec8  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    00004c6c  00000000  00000000  00014a69  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_alt_sim_info 00000040  00000000  00000000  000196d8  2**2
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_ranges 000007e0  00000000  00000000  00019718  2**3
                  CONTENTS, READONLY, DEBUGGING
 19 .thread_model 00000003  00000000  00000000  0001bc5e  2**0
                  CONTENTS, READONLY
 20 .cpu          00000005  00000000  00000000  0001bc61  2**0
                  CONTENTS, READONLY
 21 .qsys         00000001  00000000  00000000  0001bc66  2**0
                  CONTENTS, READONLY
 22 .simulation_enabled 00000001  00000000  00000000  0001bc67  2**0
                  CONTENTS, READONLY
 23 .stderr_dev   00000009  00000000  00000000  0001bc68  2**0
                  CONTENTS, READONLY
 24 .stdin_dev    00000009  00000000  00000000  0001bc71  2**0
                  CONTENTS, READONLY
 25 .stdout_dev   00000009  00000000  00000000  0001bc7a  2**0
                  CONTENTS, READONLY
 26 .sopc_system_name 00000013  00000000  00000000  0001bc83  2**0
                  CONTENTS, READONLY
 27 .quartus_project_dir 0000001e  00000000  00000000  0001bc96  2**0
                  CONTENTS, READONLY
 28 .jdi          0000587f  00000000  00000000  0001bcb4  2**0
                  CONTENTS, READONLY
 29 .sopcinfo     0008ba38  00000000  00000000  00021533  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00180000 l    d  .entry	00000000 .entry
00180020 l    d  .exceptions	00000000 .exceptions
0018014c l    d  .text	00000000 .text
00182e94 l    d  .rodata	00000000 .rodata
00183138 l    d  .rwdata	00000000 .rwdata
001842b0 l    d  .bss	00000000 .bss
00000000 l    d  .VideoRAM	00000000 .VideoRAM
00008000 l    d  .descriptor_memory	00000000 .descriptor_memory
00184958 l    d  .onchip_memory	00000000 .onchip_memory
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../barcode_bsp//obj/HAL/src/crt0.o
00180184 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_exception_entry.o
00180094 l       .exceptions	00000000 alt_exception_unknown
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 main.c
00000000 l    df *ABS*	00000000 network.c
00000000 l    df *ABS*	00000000 adddf3.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 fixdfsi.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 lib2-mul.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 putchar.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 fvwrite_small_dev.c
00000000 l    df *ABS*	00000000 impure.c
00183898 l     O .rwdata	000000e0 impure_data
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 alt_load.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_printf.c
00000000 l    df *ABS*	00000000 alt_putchar.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
001839a8 l     O .rwdata	00000030 sgdma_rx
00183978 l     O .rwdata	00000030 sgdma_tx
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_sgdma.c
0018247c l     F .text	0000005c alt_avalon_sgdma_irq
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_dcache_flush.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00181e40 g     F .text	0000001c putchar
001821a8 g     F .text	0000002c alt_main
00181e5c g     F .text	00000080 _puts_r
001807ac g     F .text	000000c8 rx_ethernet_isr
001847d8 g     O .bss	00000100 alt_irq
001839f4 g       *ABS*	00000000 __flash_rwdata_start
00180240 g     F .text	000002cc showText
00182554 g     F .text	00000080 alt_avalon_sgdma_do_sync_transfer
001826e0 g     F .text	00000114 alt_avalon_sgdma_construct_descriptor_burst
001839e0 g     O .rwdata	00000004 jtag_uart
00182ca8 g     F .text	00000008 altera_nios2_gen2_irq_init
00180000 g     F .entry	0000000c __reset
00182874 g     F .text	00000048 alt_avalon_sgdma_construct_stream_to_mem_desc_burst
00180020 g       *ABS*	00000000 __flash_exceptions_start
001842c4 g     O .bss	00000004 errno
001842cc g     O .bss	00000004 alt_argv
0018b9d8 g       *ABS*	00000000 _gp
0018238c g     F .text	00000004 usleep
001842d8 g     O .bss	00000100 charcode
00000000 g       *ABS*	00000000 __alt_mem_VideoRAM
001842b0 g     O .bss	00000004 actualCount
00181e38 g     F .text	00000008 _putchar_r
00182b3c g     F .text	00000074 alt_find_dev
00181e10 g     F .text	00000028 memcpy
00181ca8 g     F .text	000000dc .hidden __floatsidf
00181edc g     F .text	00000014 puts
001828e4 g     F .text	00000050 alt_avalon_sgdma_construct_mem_to_stream_desc_burst
00182dd8 g     F .text	00000064 .hidden __udivsi3
001801a0 g     F .text	000000a0 drawChars
001825fc g     F .text	0000001c alt_avalon_sgdma_stop
00182ac8 g     F .text	00000004 alt_dcache_flush
00180b10 g     F .text	000008ac .hidden __adddf3
001839d8 g     O .rwdata	00000004 _global_impure_ptr
001848d8 g       *ABS*	00000000 __bss_end
00182c40 g     F .text	00000068 alt_iic_isr_register
001824d8 g     F .text	0000007c alt_avalon_sgdma_do_async_transfer
00008000 g     O .descriptor_memory	00000020 rx_descriptor_end
00182c28 g     F .text	00000018 alt_ic_irq_enabled
00008000 g       *ABS*	00000000 __alt_mem_descriptor_memory
001842d4 g     O .bss	00000004 alt_irq_active
00183498 g     O .rwdata	00000400 tx_frame
001800ec g     F .exceptions	00000060 alt_irq_handler
00182618 g     F .text	0000002c alt_avalon_sgdma_check_descriptor_status
00182acc g     F .text	00000004 alt_dcache_flush_all
00181c28 g     F .text	00000080 .hidden __fixdfsi
00008020 g     O .descriptor_memory	00000020 rx_descriptor
001839f4 g       *ABS*	00000000 __ram_rwdata_end
00180000 g       *ABS*	00000000 __alt_mem_onchip_memory
00183138 g     O .rwdata	00000360 charTemplate
00182390 g     F .text	00000060 write
00182690 g     F .text	00000030 alt_avalon_sgdma_enable_desc_poll
00182018 g     F .text	00000058 _putc_r
00183138 g       *ABS*	00000000 __ram_rodata_end
00182e3c g     F .text	00000058 .hidden __umodsi3
00182934 g     F .text	00000040 alt_avalon_sgdma_construct_mem_to_stream_desc
001825d4 g     F .text	00000010 alt_avalon_sgdma_register_callback
001842b4 g     O .bss	00000004 barwidth
00184958 g       *ABS*	00000000 end
001cb000 g       *ABS*	00000000 __alt_stack_pointer
001826c0 g     F .text	00000020 alt_avalon_sgdma_disable_desc_poll
00181d84 g     F .text	00000064 .hidden __clzsi2
00182448 g     F .text	00000034 altera_avalon_jtag_uart_write
0018283c g     F .text	00000038 alt_avalon_sgdma_construct_mem_to_mem_desc
001828bc g     F .text	00000028 alt_avalon_sgdma_construct_stream_to_mem_desc
001821d4 g     F .text	00000170 alt_printf
001809dc g     F .text	00000004 refresh_ethernet
0018014c g     F .text	0000003c _start
001842b8 g     O .bss	00000004 sgdma_tx_dev
00182644 g     F .text	0000004c alt_avalon_sgdma_open
001842bc g     O .bss	00000004 text_length
00182410 g     F .text	00000038 alt_sys_init
00181de8 g     F .text	00000028 .hidden __mulsi3
00183138 g       *ABS*	00000000 __ram_rwdata_start
00182e94 g       *ABS*	00000000 __ram_rodata_start
0018050c g     F .text	000001f4 scanBarcode
00182a40 g     F .text	00000088 alt_busy_sleep
00182cb0 g     F .text	00000030 memcmp
00184958 g       *ABS*	00000000 __alt_stack_base
001813bc g     F .text	0000086c .hidden __muldf3
00182ad0 g     F .text	0000006c alt_dev_llist_insert
001825e4 g     F .text	00000018 alt_avalon_sgdma_start
00181f0c g     F .text	000000b8 __sfvwrite_small_dev
001842b0 g       *ABS*	00000000 __bss_start
00180734 g     F .text	00000078 main
001842c8 g     O .bss	00000004 alt_envp
001839e4 g     O .rwdata	00000008 alt_sgdma_list
001839ec g     O .rwdata	00000004 alt_errno
00008060 g     O .descriptor_memory	00000020 tx_descriptor
001843d8 g     O .bss	00000400 rx_frame
00181fc4 g     F .text	00000054 putc
00182ce0 g     F .text	00000084 .hidden __divsi3
001809f4 g     F .text	00000068 transmit
00182e94 g       *ABS*	00000000 __flash_rodata_start
001823f0 g     F .text	00000020 alt_irq_init
00183036 g     O .rodata	00000100 .hidden __clz_tab
00182070 g     F .text	00000058 _write_r
001839dc g     O .rwdata	00000004 _impure_ptr
001842d0 g     O .bss	00000004 alt_argc
00180020 g       .exceptions	00000000 alt_irq_entry
001809e0 g     F .text	00000014 tx_char
00180874 g     F .text	00000168 setup
00180020 g       *ABS*	00000000 __ram_exceptions_start
00182bb4 g     F .text	00000004 alt_ic_isr_register
001839f4 g       *ABS*	00000000 _edata
00184958 g       *ABS*	00000000 _end
0018014c g       *ABS*	00000000 __ram_exceptions_end
00180188 g     F .text	00000018 clearText
00180a5c g     F .text	000000b4 tx_ethernet_isr
00182bf0 g     F .text	00000038 alt_ic_irq_disable
00008040 g     O .descriptor_memory	00000020 tx_descriptor_end
00182974 g     F .text	00000048 alt_avalon_sgdma_construct_descriptor
00182d64 g     F .text	00000074 .hidden __modsi3
001cb000 g       *ABS*	00000000 __alt_data_end
00180020 g     F .exceptions	00000000 alt_exception
001842c0 g     O .bss	00000004 sgdma_rx_dev
00180700 g     F .text	00000034 callback
0018000c g       .entry	00000000 _exit
00181ef0 g     F .text	0000001c strlen
00182344 g     F .text	00000048 alt_putchar
00182bb0 g     F .text	00000004 alt_icache_flush_all
001839f0 g     O .rwdata	00000004 alt_priority_mask
00182bb8 g     F .text	00000038 alt_ic_irq_enable
001827f4 g     F .text	00000048 alt_avalon_sgdma_construct_mem_to_mem_desc_burst
001820c8 g     F .text	000000e0 alt_load
001829bc g     F .text	00000084 alt_avalon_sgdma_init



Disassembly of section .entry:

00180000 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
  180000:	00400634 	movhi	at,24
    ori r1, r1, %lo(_start)
  180004:	08405314 	ori	at,at,332
    jmp r1
  180008:	0800683a 	jmp	at

0018000c <_exit>:
	...

Disassembly of section .exceptions:

00180020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
  180020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
  180024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
  180028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
  18002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
  180030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
  180034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
  180038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
  18003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
  180040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
  180044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
  180048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
  18004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
  180050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
  180054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
  180058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
  18005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
  180060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
  180064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
  180068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
  18006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
  180070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
  180074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
  180078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
  18007c:	10000326 	beq	r2,zero,18008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
  180080:	20000226 	beq	r4,zero,18008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
  180084:	01800ec0 	call	1800ec <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
  180088:	00000306 	br	180098 <alt_exception_unknown+0x4>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
  18008c:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
  180090:	e8bfff17 	ldw	r2,-4(ea)

00180094 <alt_exception_unknown>:
#ifdef NIOS2_HAS_DEBUG_STUB
       /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
  180094:	003da03a 	break	0
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
  180098:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
  18009c:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
  1800a0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
  1800a4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
  1800a8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
  1800ac:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
  1800b0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
  1800b4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
  1800b8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
  1800bc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
  1800c0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
  1800c4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
  1800c8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
  1800cc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
  1800d0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
  1800d4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
  1800d8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
  1800dc:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
  1800e0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
  1800e4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
  1800e8:	ef80083a 	eret

001800ec <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
  1800ec:	defffe04 	addi	sp,sp,-8
  1800f0:	dfc00115 	stw	ra,4(sp)
  1800f4:	dc000015 	stw	r16,0(sp)
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
  1800f8:	0009313a 	rdctl	r4,ipending
    do
    {
      if (active & mask)
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
  1800fc:	04000634 	movhi	r16,24
  180100:	8411f604 	addi	r16,r16,18392

  active = alt_irq_pending ();

  do
  {
    i = 0;
  180104:	0005883a 	mov	r2,zero
    mask = 1;
  180108:	00c00044 	movi	r3,1
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
  18010c:	20ca703a 	and	r5,r4,r3
  180110:	28000b26 	beq	r5,zero,180140 <alt_irq_handler+0x54>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
  180114:	100490fa 	slli	r2,r2,3
  180118:	8085883a 	add	r2,r16,r2
  18011c:	10c00017 	ldw	r3,0(r2)
  180120:	11000117 	ldw	r4,4(r2)
  180124:	183ee83a 	callr	r3
  180128:	0009313a 	rdctl	r4,ipending

    } while (1);

    active = alt_irq_pending ();
    
  } while (active);
  18012c:	203ff51e 	bne	r4,zero,180104 <alt_irq_handler+0x18>
  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
}
  180130:	dfc00117 	ldw	ra,4(sp)
  180134:	dc000017 	ldw	r16,0(sp)
  180138:	dec00204 	addi	sp,sp,8
  18013c:	f800283a 	ret
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
  180140:	18c7883a 	add	r3,r3,r3
      i++;
  180144:	10800044 	addi	r2,r2,1

    } while (1);
  180148:	003ff006 	br	18010c <alt_irq_handler+0x20>

Disassembly of section .text:

0018014c <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
  18014c:	06c00734 	movhi	sp,28
    ori sp, sp, %lo(__alt_stack_pointer)
  180150:	deec0014 	ori	sp,sp,45056
    movhi gp, %hi(_gp)
  180154:	06800634 	movhi	gp,24
    ori gp, gp, %lo(_gp)
  180158:	d6ae7614 	ori	gp,gp,47576
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
  18015c:	00800634 	movhi	r2,24
    ori r2, r2, %lo(__bss_start)
  180160:	1090ac14 	ori	r2,r2,17072

    movhi r3, %hi(__bss_end)
  180164:	00c00634 	movhi	r3,24
    ori r3, r3, %lo(__bss_end)
  180168:	18d23614 	ori	r3,r3,18648

    beq r2, r3, 1f
  18016c:	10c00326 	beq	r2,r3,18017c <_start+0x30>

0:
    stw zero, (r2)
  180170:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
  180174:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
  180178:	10fffd36 	bltu	r2,r3,180170 <_start+0x24>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
  18017c:	01820c80 	call	1820c8 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
  180180:	01821a80 	call	1821a8 <alt_main>

00180184 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
  180184:	003fff06 	br	180184 <alt_after_alt_main>

00180188 <clearText>:
			}

	};

	void clearText(){
		for(int x = 0; x < 10000; x+=4){
  180188:	0005883a 	mov	r2,zero
  18018c:	00c9c404 	movi	r3,10000
			IOWR_ALTERA_AVALON_PIO_DATA(x ,(0<<16)| (0<<8) | 0);
  180190:	10000035 	stwio	zero,0(r2)
			}

	};

	void clearText(){
		for(int x = 0; x < 10000; x+=4){
  180194:	10800104 	addi	r2,r2,4
  180198:	10fffd1e 	bne	r2,r3,180190 <clearText+0x8>
			IOWR_ALTERA_AVALON_PIO_DATA(x ,(0<<16)| (0<<8) | 0);
		}
	}
  18019c:	f800283a 	ret

001801a0 <drawChars>:

	void drawChars(int pixels[35][8]){
  1801a0:	defffe04 	addi	sp,sp,-8
  1801a4:	dc000015 	stw	r16,0(sp)
  1801a8:	dfc00115 	stw	ra,4(sp)
  1801ac:	2021883a 	mov	r16,r4
			int totalChars = 35;
			int add = 0;
			int x = 0;
			int linePixelCount = 0;
			clearText();
  1801b0:	01801880 	call	180188 <clearText>
  1801b4:	8009883a 	mov	r4,r16
  1801b8:	82800804 	addi	r10,r16,32
		}
	}

	void drawChars(int pixels[35][8]){
			int totalChars = 35;
			int add = 0;
  1801bc:	000f883a 	mov	r7,zero
			clearText();
			int pixel = 0;
			while(x < 40*totalChars){
				//Draw all chars to video memory used by VGA controller
				for(int currentChar = 0; currentChar < totalChars; currentChar++){
					for(int bit = 4; bit >= 0; bit--){
  1801c0:	02ffffc4 	movi	r11,-1
			int linePixelCount = 0;
			clearText();
			int pixel = 0;
			while(x < 40*totalChars){
				//Draw all chars to video memory used by VGA controller
				for(int currentChar = 0; currentChar < totalChars; currentChar++){
  1801c4:	03011804 	movi	r12,1120
					for(int bit = 4; bit >= 0; bit--){
						linePixelCount++;
						int val = 0;
						if((pixels[currentChar][pixel] & (1 << bit)) != 0){
							val = 255;
  1801c8:	380d883a 	mov	r6,r7
  1801cc:	0007883a 	mov	r3,zero
		for(int x = 0; x < 10000; x+=4){
			IOWR_ALTERA_AVALON_PIO_DATA(x ,(0<<16)| (0<<8) | 0);
		}
	}

	void drawChars(int pixels[35][8]){
  1801d0:	3011883a 	mov	r8,r6
  1801d4:	01400104 	movi	r5,4
				//Draw all chars to video memory used by VGA controller
				for(int currentChar = 0; currentChar < totalChars; currentChar++){
					for(int bit = 4; bit >= 0; bit--){
						linePixelCount++;
						int val = 0;
						if((pixels[currentChar][pixel] & (1 << bit)) != 0){
  1801d8:	20db883a 	add	r13,r4,r3
  1801dc:	68800017 	ldw	r2,0(r13)
  1801e0:	1145d83a 	sra	r2,r2,r5
  1801e4:	1080004c 	andi	r2,r2,1
  1801e8:	10000226 	beq	r2,zero,1801f4 <drawChars+0x54>
							val = 255;
  1801ec:	00803fc4 	movi	r2,255
  1801f0:	00000106 	br	1801f8 <drawChars+0x58>
			while(x < 40*totalChars){
				//Draw all chars to video memory used by VGA controller
				for(int currentChar = 0; currentChar < totalChars; currentChar++){
					for(int bit = 4; bit >= 0; bit--){
						linePixelCount++;
						int val = 0;
  1801f4:	0005883a 	mov	r2,zero
						if((pixels[currentChar][pixel] & (1 << bit)) != 0){
							val = 255;
						}
						IOWR_ALTERA_AVALON_PIO_DATA(add ,(val<<16)| (val<<8) | val);
  1801f8:	101c943a 	slli	r14,r2,16
  1801fc:	1012923a 	slli	r9,r2,8
  180200:	7252b03a 	or	r9,r14,r9
  180204:	4884b03a 	or	r2,r9,r2
  180208:	40800035 	stwio	r2,0(r8)
			clearText();
			int pixel = 0;
			while(x < 40*totalChars){
				//Draw all chars to video memory used by VGA controller
				for(int currentChar = 0; currentChar < totalChars; currentChar++){
					for(int bit = 4; bit >= 0; bit--){
  18020c:	297fffc4 	addi	r5,r5,-1
						if((pixels[currentChar][pixel] & (1 << bit)) != 0){
							val = 255;
						}
						IOWR_ALTERA_AVALON_PIO_DATA(add ,(val<<16)| (val<<8) | val);
						x++;
						add+=4;
  180210:	42000104 	addi	r8,r8,4
			clearText();
			int pixel = 0;
			while(x < 40*totalChars){
				//Draw all chars to video memory used by VGA controller
				for(int currentChar = 0; currentChar < totalChars; currentChar++){
					for(int bit = 4; bit >= 0; bit--){
  180214:	2afff11e 	bne	r5,r11,1801dc <drawChars+0x3c>
  180218:	18c00804 	addi	r3,r3,32
  18021c:	31800604 	addi	r6,r6,24
			int linePixelCount = 0;
			clearText();
			int pixel = 0;
			while(x < 40*totalChars){
				//Draw all chars to video memory used by VGA controller
				for(int currentChar = 0; currentChar < totalChars; currentChar++){
  180220:	1b3feb1e 	bne	r3,r12,1801d0 <drawChars+0x30>
  180224:	21000104 	addi	r4,r4,4
						add+=4;
					}
					add+=4;
				}
				if(linePixelCount == (5*totalChars)){
					add+=(800-(24*totalChars));
  180228:	39c0c804 	addi	r7,r7,800
			int add = 0;
			int x = 0;
			int linePixelCount = 0;
			clearText();
			int pixel = 0;
			while(x < 40*totalChars){
  18022c:	513fe61e 	bne	r10,r4,1801c8 <drawChars+0x28>
					add+=(800-(24*totalChars));
					linePixelCount = 0;
				}
				pixel++;
			}
		}
  180230:	dfc00117 	ldw	ra,4(sp)
  180234:	dc000017 	ldw	r16,0(sp)
  180238:	dec00204 	addi	sp,sp,8
  18023c:	f800283a 	ret

00180240 <showText>:


void showText(char *chars){
  180240:	defee504 	addi	sp,sp,-1132
  180244:	dc411915 	stw	r17,1124(sp)
  180248:	dc011815 	stw	r16,1120(sp)
  18024c:	dfc11a15 	stw	ra,1128(sp)
  180250:	2021883a 	mov	r16,r4
  180254:	d807883a 	mov	r3,sp
  180258:	244008c4 	addi	r17,r4,35
	int pixeldata[35][8];
	for(int x = 0; x < 35; x++){
		switch (chars[x]) {
  18025c:	80800007 	ldb	r2,0(r16)
  180260:	01001b44 	movi	r4,109
  180264:	11007026 	beq	r2,r4,180428 <showText+0x1e8>
  180268:	20802616 	blt	r4,r2,180304 <showText+0xc4>
  18026c:	01001984 	movi	r4,102
  180270:	11005926 	beq	r2,r4,1803d8 <showText+0x198>
  180274:	20801116 	blt	r4,r2,1802bc <showText+0x7c>
  180278:	01001884 	movi	r4,98
  18027c:	11004a26 	beq	r2,r4,1803a8 <showText+0x168>
  180280:	20800716 	blt	r4,r2,1802a0 <showText+0x60>
  180284:	01800804 	movi	r6,32
  180288:	11808f26 	beq	r2,r6,1804c8 <showText+0x288>
  18028c:	01001844 	movi	r4,97
  180290:	11008f1e 	bne	r2,r4,1804d0 <showText+0x290>
		  case 'a': memcpy(&pixeldata[x], &charTemplate[0], sizeof(pixeldata[x]) ); break;
  180294:	01400634 	movhi	r5,24
  180298:	294c4e04 	addi	r5,r5,12600
  18029c:	00008f06 	br	1804dc <showText+0x29c>


void showText(char *chars){
	int pixeldata[35][8];
	for(int x = 0; x < 35; x++){
		switch (chars[x]) {
  1802a0:	01001904 	movi	r4,100
  1802a4:	11004426 	beq	r2,r4,1803b8 <showText+0x178>
  1802a8:	20804716 	blt	r4,r2,1803c8 <showText+0x188>
		  case 'a': memcpy(&pixeldata[x], &charTemplate[0], sizeof(pixeldata[x]) ); break;
		  case 'b': memcpy(&pixeldata[x], &charTemplate[1], sizeof(pixeldata[x]) ); break;
		  case 'c': memcpy(&pixeldata[x], &charTemplate[2], sizeof(pixeldata[x]) ); break;
  1802ac:	01400634 	movhi	r5,24
  1802b0:	01800804 	movi	r6,32
  1802b4:	294c5e04 	addi	r5,r5,12664
  1802b8:	00008806 	br	1804dc <showText+0x29c>


void showText(char *chars){
	int pixeldata[35][8];
	for(int x = 0; x < 35; x++){
		switch (chars[x]) {
  1802bc:	01001a44 	movi	r4,105
  1802c0:	11004d26 	beq	r2,r4,1803f8 <showText+0x1b8>
  1802c4:	20800816 	blt	r4,r2,1802e8 <showText+0xa8>
  1802c8:	010019c4 	movi	r4,103
  1802cc:	11004626 	beq	r2,r4,1803e8 <showText+0x1a8>
  1802d0:	01001a04 	movi	r4,104
  1802d4:	11007e1e 	bne	r2,r4,1804d0 <showText+0x290>
		  case 'c': memcpy(&pixeldata[x], &charTemplate[2], sizeof(pixeldata[x]) ); break;
		  case 'd': memcpy(&pixeldata[x], &charTemplate[3], sizeof(pixeldata[x]) ); break;
		  case 'e': memcpy(&pixeldata[x], &charTemplate[4], sizeof(pixeldata[x]) ); break;
		  case 'f': memcpy(&pixeldata[x], &charTemplate[5], sizeof(pixeldata[x]) ); break;
		  case 'g': memcpy(&pixeldata[x], &charTemplate[6], sizeof(pixeldata[x]) ); break;
		  case 'h': memcpy(&pixeldata[x], &charTemplate[7], sizeof(pixeldata[x]) ); break;
  1802d8:	01400634 	movhi	r5,24
  1802dc:	01800804 	movi	r6,32
  1802e0:	294c8604 	addi	r5,r5,12824
  1802e4:	00007d06 	br	1804dc <showText+0x29c>


void showText(char *chars){
	int pixeldata[35][8];
	for(int x = 0; x < 35; x++){
		switch (chars[x]) {
  1802e8:	01001ac4 	movi	r4,107
  1802ec:	11004626 	beq	r2,r4,180408 <showText+0x1c8>
  1802f0:	20804916 	blt	r4,r2,180418 <showText+0x1d8>
		  case 'e': memcpy(&pixeldata[x], &charTemplate[4], sizeof(pixeldata[x]) ); break;
		  case 'f': memcpy(&pixeldata[x], &charTemplate[5], sizeof(pixeldata[x]) ); break;
		  case 'g': memcpy(&pixeldata[x], &charTemplate[6], sizeof(pixeldata[x]) ); break;
		  case 'h': memcpy(&pixeldata[x], &charTemplate[7], sizeof(pixeldata[x]) ); break;
		  case 'i': memcpy(&pixeldata[x], &charTemplate[8], sizeof(pixeldata[x]) ); break;
		  case 'j': memcpy(&pixeldata[x], &charTemplate[9], sizeof(pixeldata[x]) ); break;
  1802f4:	01400634 	movhi	r5,24
  1802f8:	01800804 	movi	r6,32
  1802fc:	294c9604 	addi	r5,r5,12888
  180300:	00007606 	br	1804dc <showText+0x29c>


void showText(char *chars){
	int pixeldata[35][8];
	for(int x = 0; x < 35; x++){
		switch (chars[x]) {
  180304:	01001d04 	movi	r4,116
  180308:	11005b26 	beq	r2,r4,180478 <showText+0x238>
  18030c:	20801216 	blt	r4,r2,180358 <showText+0x118>
  180310:	01001c04 	movi	r4,112
  180314:	11004c26 	beq	r2,r4,180448 <showText+0x208>
  180318:	20800816 	blt	r4,r2,18033c <showText+0xfc>
  18031c:	01001b84 	movi	r4,110
  180320:	11004526 	beq	r2,r4,180438 <showText+0x1f8>
  180324:	01001bc4 	movi	r4,111
  180328:	1100691e 	bne	r2,r4,1804d0 <showText+0x290>
		  case 'j': memcpy(&pixeldata[x], &charTemplate[9], sizeof(pixeldata[x]) ); break;
		  case 'k': memcpy(&pixeldata[x], &charTemplate[10], sizeof(pixeldata[x]) ); break;
		  case 'l': memcpy(&pixeldata[x], &charTemplate[11], sizeof(pixeldata[x]) ); break;
		  case 'm': memcpy(&pixeldata[x], &charTemplate[12], sizeof(pixeldata[x]) ); break;
		  case 'n': memcpy(&pixeldata[x], &charTemplate[13], sizeof(pixeldata[x]) ); break;
		  case 'o': memcpy(&pixeldata[x], &charTemplate[14], sizeof(pixeldata[x]) ); break;
  18032c:	01400634 	movhi	r5,24
  180330:	01800804 	movi	r6,32
  180334:	294cbe04 	addi	r5,r5,13048
  180338:	00006806 	br	1804dc <showText+0x29c>


void showText(char *chars){
	int pixeldata[35][8];
	for(int x = 0; x < 35; x++){
		switch (chars[x]) {
  18033c:	01001c84 	movi	r4,114
  180340:	11004526 	beq	r2,r4,180458 <showText+0x218>
  180344:	20804816 	blt	r4,r2,180468 <showText+0x228>
		  case 'l': memcpy(&pixeldata[x], &charTemplate[11], sizeof(pixeldata[x]) ); break;
		  case 'm': memcpy(&pixeldata[x], &charTemplate[12], sizeof(pixeldata[x]) ); break;
		  case 'n': memcpy(&pixeldata[x], &charTemplate[13], sizeof(pixeldata[x]) ); break;
		  case 'o': memcpy(&pixeldata[x], &charTemplate[14], sizeof(pixeldata[x]) ); break;
		  case 'p': memcpy(&pixeldata[x], &charTemplate[15], sizeof(pixeldata[x]) ); break;
		  case 'q': memcpy(&pixeldata[x], &charTemplate[16], sizeof(pixeldata[x]) ); break;
  180348:	01400634 	movhi	r5,24
  18034c:	01800804 	movi	r6,32
  180350:	294cce04 	addi	r5,r5,13112
  180354:	00006106 	br	1804dc <showText+0x29c>


void showText(char *chars){
	int pixeldata[35][8];
	for(int x = 0; x < 35; x++){
		switch (chars[x]) {
  180358:	01001dc4 	movi	r4,119
  18035c:	11004e26 	beq	r2,r4,180498 <showText+0x258>
  180360:	20800816 	blt	r4,r2,180384 <showText+0x144>
  180364:	01001d44 	movi	r4,117
  180368:	11004726 	beq	r2,r4,180488 <showText+0x248>
  18036c:	01001d84 	movi	r4,118
  180370:	1100571e 	bne	r2,r4,1804d0 <showText+0x290>
		  case 'q': memcpy(&pixeldata[x], &charTemplate[16], sizeof(pixeldata[x]) ); break;
		  case 'r': memcpy(&pixeldata[x], &charTemplate[17], sizeof(pixeldata[x]) ); break;
		  case 's': memcpy(&pixeldata[x], &charTemplate[18], sizeof(pixeldata[x]) ); break;
		  case 't': memcpy(&pixeldata[x], &charTemplate[19], sizeof(pixeldata[x]) ); break;
		  case 'u': memcpy(&pixeldata[x], &charTemplate[20], sizeof(pixeldata[x]) ); break;
		  case 'v': memcpy(&pixeldata[x], &charTemplate[21], sizeof(pixeldata[x]) ); break;
  180374:	01400634 	movhi	r5,24
  180378:	01800804 	movi	r6,32
  18037c:	294cf604 	addi	r5,r5,13272
  180380:	00005606 	br	1804dc <showText+0x29c>


void showText(char *chars){
	int pixeldata[35][8];
	for(int x = 0; x < 35; x++){
		switch (chars[x]) {
  180384:	01001e44 	movi	r4,121
  180388:	11004b26 	beq	r2,r4,1804b8 <showText+0x278>
  18038c:	11004616 	blt	r2,r4,1804a8 <showText+0x268>
  180390:	01001e84 	movi	r4,122
  180394:	11004e1e 	bne	r2,r4,1804d0 <showText+0x290>
		  case 'u': memcpy(&pixeldata[x], &charTemplate[20], sizeof(pixeldata[x]) ); break;
		  case 'v': memcpy(&pixeldata[x], &charTemplate[21], sizeof(pixeldata[x]) ); break;
		  case 'w': memcpy(&pixeldata[x], &charTemplate[22], sizeof(pixeldata[x]) ); break;
		  case 'x': memcpy(&pixeldata[x], &charTemplate[23], sizeof(pixeldata[x]) ); break;
		  case 'y': memcpy(&pixeldata[x], &charTemplate[24], sizeof(pixeldata[x]) ); break;
		  case 'z': memcpy(&pixeldata[x], &charTemplate[25], sizeof(pixeldata[x]) ); break;
  180398:	01400634 	movhi	r5,24
  18039c:	01800804 	movi	r6,32
  1803a0:	294d1604 	addi	r5,r5,13400
  1803a4:	00004d06 	br	1804dc <showText+0x29c>
void showText(char *chars){
	int pixeldata[35][8];
	for(int x = 0; x < 35; x++){
		switch (chars[x]) {
		  case 'a': memcpy(&pixeldata[x], &charTemplate[0], sizeof(pixeldata[x]) ); break;
		  case 'b': memcpy(&pixeldata[x], &charTemplate[1], sizeof(pixeldata[x]) ); break;
  1803a8:	01400634 	movhi	r5,24
  1803ac:	01800804 	movi	r6,32
  1803b0:	294c5604 	addi	r5,r5,12632
  1803b4:	00004906 	br	1804dc <showText+0x29c>
		  case 'c': memcpy(&pixeldata[x], &charTemplate[2], sizeof(pixeldata[x]) ); break;
		  case 'd': memcpy(&pixeldata[x], &charTemplate[3], sizeof(pixeldata[x]) ); break;
  1803b8:	01400634 	movhi	r5,24
  1803bc:	01800804 	movi	r6,32
  1803c0:	294c6604 	addi	r5,r5,12696
  1803c4:	00004506 	br	1804dc <showText+0x29c>
		  case 'e': memcpy(&pixeldata[x], &charTemplate[4], sizeof(pixeldata[x]) ); break;
  1803c8:	01400634 	movhi	r5,24
  1803cc:	01800804 	movi	r6,32
  1803d0:	294c6e04 	addi	r5,r5,12728
  1803d4:	00004106 	br	1804dc <showText+0x29c>
		  case 'f': memcpy(&pixeldata[x], &charTemplate[5], sizeof(pixeldata[x]) ); break;
  1803d8:	01400634 	movhi	r5,24
  1803dc:	01800804 	movi	r6,32
  1803e0:	294c7604 	addi	r5,r5,12760
  1803e4:	00003d06 	br	1804dc <showText+0x29c>
		  case 'g': memcpy(&pixeldata[x], &charTemplate[6], sizeof(pixeldata[x]) ); break;
  1803e8:	01400634 	movhi	r5,24
  1803ec:	01800804 	movi	r6,32
  1803f0:	294c7e04 	addi	r5,r5,12792
  1803f4:	00003906 	br	1804dc <showText+0x29c>
		  case 'h': memcpy(&pixeldata[x], &charTemplate[7], sizeof(pixeldata[x]) ); break;
		  case 'i': memcpy(&pixeldata[x], &charTemplate[8], sizeof(pixeldata[x]) ); break;
  1803f8:	01400634 	movhi	r5,24
  1803fc:	01800804 	movi	r6,32
  180400:	294c8e04 	addi	r5,r5,12856
  180404:	00003506 	br	1804dc <showText+0x29c>
		  case 'j': memcpy(&pixeldata[x], &charTemplate[9], sizeof(pixeldata[x]) ); break;
		  case 'k': memcpy(&pixeldata[x], &charTemplate[10], sizeof(pixeldata[x]) ); break;
  180408:	01400634 	movhi	r5,24
  18040c:	01800804 	movi	r6,32
  180410:	294c9e04 	addi	r5,r5,12920
  180414:	00003106 	br	1804dc <showText+0x29c>
		  case 'l': memcpy(&pixeldata[x], &charTemplate[11], sizeof(pixeldata[x]) ); break;
  180418:	01400634 	movhi	r5,24
  18041c:	01800804 	movi	r6,32
  180420:	294ca604 	addi	r5,r5,12952
  180424:	00002d06 	br	1804dc <showText+0x29c>
		  case 'm': memcpy(&pixeldata[x], &charTemplate[12], sizeof(pixeldata[x]) ); break;
  180428:	01400634 	movhi	r5,24
  18042c:	01800804 	movi	r6,32
  180430:	294cae04 	addi	r5,r5,12984
  180434:	00002906 	br	1804dc <showText+0x29c>
		  case 'n': memcpy(&pixeldata[x], &charTemplate[13], sizeof(pixeldata[x]) ); break;
  180438:	01400634 	movhi	r5,24
  18043c:	01800804 	movi	r6,32
  180440:	294cb604 	addi	r5,r5,13016
  180444:	00002506 	br	1804dc <showText+0x29c>
		  case 'o': memcpy(&pixeldata[x], &charTemplate[14], sizeof(pixeldata[x]) ); break;
		  case 'p': memcpy(&pixeldata[x], &charTemplate[15], sizeof(pixeldata[x]) ); break;
  180448:	01400634 	movhi	r5,24
  18044c:	01800804 	movi	r6,32
  180450:	294cc604 	addi	r5,r5,13080
  180454:	00002106 	br	1804dc <showText+0x29c>
		  case 'q': memcpy(&pixeldata[x], &charTemplate[16], sizeof(pixeldata[x]) ); break;
		  case 'r': memcpy(&pixeldata[x], &charTemplate[17], sizeof(pixeldata[x]) ); break;
  180458:	01400634 	movhi	r5,24
  18045c:	01800804 	movi	r6,32
  180460:	294cd604 	addi	r5,r5,13144
  180464:	00001d06 	br	1804dc <showText+0x29c>
		  case 's': memcpy(&pixeldata[x], &charTemplate[18], sizeof(pixeldata[x]) ); break;
  180468:	01400634 	movhi	r5,24
  18046c:	01800804 	movi	r6,32
  180470:	294cde04 	addi	r5,r5,13176
  180474:	00001906 	br	1804dc <showText+0x29c>
		  case 't': memcpy(&pixeldata[x], &charTemplate[19], sizeof(pixeldata[x]) ); break;
  180478:	01400634 	movhi	r5,24
  18047c:	01800804 	movi	r6,32
  180480:	294ce604 	addi	r5,r5,13208
  180484:	00001506 	br	1804dc <showText+0x29c>
		  case 'u': memcpy(&pixeldata[x], &charTemplate[20], sizeof(pixeldata[x]) ); break;
  180488:	01400634 	movhi	r5,24
  18048c:	01800804 	movi	r6,32
  180490:	294cee04 	addi	r5,r5,13240
  180494:	00001106 	br	1804dc <showText+0x29c>
		  case 'v': memcpy(&pixeldata[x], &charTemplate[21], sizeof(pixeldata[x]) ); break;
		  case 'w': memcpy(&pixeldata[x], &charTemplate[22], sizeof(pixeldata[x]) ); break;
  180498:	01400634 	movhi	r5,24
  18049c:	01800804 	movi	r6,32
  1804a0:	294cfe04 	addi	r5,r5,13304
  1804a4:	00000d06 	br	1804dc <showText+0x29c>
		  case 'x': memcpy(&pixeldata[x], &charTemplate[23], sizeof(pixeldata[x]) ); break;
  1804a8:	01400634 	movhi	r5,24
  1804ac:	01800804 	movi	r6,32
  1804b0:	294d0604 	addi	r5,r5,13336
  1804b4:	00000906 	br	1804dc <showText+0x29c>
		  case 'y': memcpy(&pixeldata[x], &charTemplate[24], sizeof(pixeldata[x]) ); break;
  1804b8:	01400634 	movhi	r5,24
  1804bc:	01800804 	movi	r6,32
  1804c0:	294d0e04 	addi	r5,r5,13368
  1804c4:	00000506 	br	1804dc <showText+0x29c>
		  case 'z': memcpy(&pixeldata[x], &charTemplate[25], sizeof(pixeldata[x]) ); break;
		  case ' ': memcpy(&pixeldata[x], &charTemplate[26], sizeof(pixeldata[x]) ); break;
  1804c8:	100d883a 	mov	r6,r2
  1804cc:	00000106 	br	1804d4 <showText+0x294>
		  default: memcpy(&pixeldata[x], &charTemplate[26], sizeof(pixeldata[x]) );
  1804d0:	01800804 	movi	r6,32
  1804d4:	01400634 	movhi	r5,24
  1804d8:	294d1e04 	addi	r5,r5,13432
  1804dc:	1809883a 	mov	r4,r3
  1804e0:	0181e100 	call	181e10 <memcpy>
  1804e4:	84000044 	addi	r16,r16,1
  1804e8:	10c00804 	addi	r3,r2,32
		}


void showText(char *chars){
	int pixeldata[35][8];
	for(int x = 0; x < 35; x++){
  1804ec:	847f5b1e 	bne	r16,r17,18025c <showText+0x1c>
		  default: memcpy(&pixeldata[x], &charTemplate[26], sizeof(pixeldata[x]) );

		 }
	}

	drawChars(pixeldata);
  1804f0:	d809883a 	mov	r4,sp
  1804f4:	01801a00 	call	1801a0 <drawChars>
}
  1804f8:	dfc11a17 	ldw	ra,1128(sp)
  1804fc:	dc411917 	ldw	r17,1124(sp)
  180500:	dc011817 	ldw	r16,1120(sp)
  180504:	dec11b04 	addi	sp,sp,1132
  180508:	f800283a 	ret

0018050c <scanBarcode>:

char charcode[256] = {};
int barwidth = 0;
int actualCount = 0;
void scanBarcode(){
  18050c:	defff704 	addi	sp,sp,-36
  180510:	dcc00315 	stw	r19,12(sp)
				countingBarWidth = 0;
				charcode[actualCount] = '0';
				actualCount++;
			}
		}else{
			charcode[actualCount] = '1';
  180514:	04c00634 	movhi	r19,24
}

char charcode[256] = {};
int barwidth = 0;
int actualCount = 0;
void scanBarcode(){
  180518:	dc800215 	stw	r18,8(sp)
  18051c:	dc400115 	stw	r17,4(sp)
  180520:	dc000015 	stw	r16,0(sp)
  180524:	dfc00815 	stw	ra,32(sp)
  180528:	ddc00715 	stw	r23,28(sp)
  18052c:	dd800615 	stw	r22,24(sp)
  180530:	dd400515 	stw	r21,20(sp)
  180534:	dd000415 	stw	r20,16(sp)
	int firstBit = 0;
	int countingBarWidth = 1;
	barwidth = 0;
  180538:	d0223715 	stw	zero,-30500(gp)
	actualCount = 0;
  18053c:	d0223615 	stw	zero,-30504(gp)

	for(int x =0; x < 255; x++){
  180540:	0021883a 	mov	r16,zero
char charcode[256] = {};
int barwidth = 0;
int actualCount = 0;
void scanBarcode(){
	int firstBit = 0;
	int countingBarWidth = 1;
  180544:	04800044 	movi	r18,1

char charcode[256] = {};
int barwidth = 0;
int actualCount = 0;
void scanBarcode(){
	int firstBit = 0;
  180548:	0023883a 	mov	r17,zero
				countingBarWidth = 0;
				charcode[actualCount] = '0';
				actualCount++;
			}
		}else{
			charcode[actualCount] = '1';
  18054c:	9cd0b604 	addi	r19,r19,17112
	int countingBarWidth = 1;
	barwidth = 0;
	actualCount = 0;

	for(int x =0; x < 255; x++){
		IOWR_ALTERA_AVALON_PIO_DATA(0x4020, x);
  180550:	00900804 	movi	r2,16416
  180554:	14000035 	stwio	r16,0(r2)
		int r = IORD_ALTERA_AVALON_PIO_DATA(0x4000);
  180558:	00900004 	movi	r2,16384
  18055c:	15000037 	ldwio	r20,0(r2)
		int g = IORD_ALTERA_AVALON_PIO_DATA(0x4010);
  180560:	00900404 	movi	r2,16400
  180564:	15c00037 	ldwio	r23,0(r2)
		int b = IORD_ALTERA_AVALON_PIO_DATA(0x4040);
  180568:	00901004 	movi	r2,16448
  18056c:	15800037 	ldwio	r22,0(r2)

		int grey =  0.2126*r + 0.7152*g + 0.0722*b;
		//int grey = (r+g+b) / 3;
		usleep(5100);
  180570:	0104fb04 	movi	r4,5100
  180574:	018238c0 	call	18238c <usleep>
		if(grey > 128){
  180578:	a009883a 	mov	r4,r20
  18057c:	0181ca80 	call	181ca8 <__floatsidf>
  180580:	0183e474 	movhi	r6,3985
  180584:	01cff2f4 	movhi	r7,16331
  180588:	31a5af04 	addi	r6,r6,-26948
  18058c:	39cd9e84 	addi	r7,r7,13946
  180590:	180b883a 	mov	r5,r3
  180594:	1009883a 	mov	r4,r2
  180598:	01813bc0 	call	1813bc <__muldf3>
  18059c:	b809883a 	mov	r4,r23
  1805a0:	102b883a 	mov	r21,r2
  1805a4:	1829883a 	mov	r20,r3
  1805a8:	0181ca80 	call	181ca8 <__floatsidf>
  1805ac:	018710f4 	movhi	r6,7235
  1805b0:	01cff9f4 	movhi	r7,16359
  1805b4:	318b2944 	addi	r6,r6,11429
  1805b8:	39f8bac4 	addi	r7,r7,-7445
  1805bc:	1009883a 	mov	r4,r2
  1805c0:	180b883a 	mov	r5,r3
  1805c4:	01813bc0 	call	1813bc <__muldf3>
  1805c8:	a00b883a 	mov	r5,r20
  1805cc:	100d883a 	mov	r6,r2
  1805d0:	180f883a 	mov	r7,r3
  1805d4:	a809883a 	mov	r4,r21
  1805d8:	0180b100 	call	180b10 <__adddf3>
  1805dc:	b009883a 	mov	r4,r22
  1805e0:	102b883a 	mov	r21,r2
  1805e4:	1829883a 	mov	r20,r3
  1805e8:	0181ca80 	call	181ca8 <__floatsidf>
  1805ec:	01bfb174 	movhi	r6,65221
  1805f0:	01cfecb4 	movhi	r7,16306
  1805f4:	319b5744 	addi	r6,r6,27997
  1805f8:	39deec84 	addi	r7,r7,31666
  1805fc:	1009883a 	mov	r4,r2
  180600:	180b883a 	mov	r5,r3
  180604:	01813bc0 	call	1813bc <__muldf3>
  180608:	100d883a 	mov	r6,r2
  18060c:	180f883a 	mov	r7,r3
  180610:	a809883a 	mov	r4,r21
  180614:	a00b883a 	mov	r5,r20
  180618:	0180b100 	call	180b10 <__adddf3>
  18061c:	1009883a 	mov	r4,r2
  180620:	180b883a 	mov	r5,r3
  180624:	0181c280 	call	181c28 <__fixdfsi>
  180628:	01002004 	movi	r4,128
  18062c:	00c00044 	movi	r3,1
  180630:	2080090e 	bge	r4,r2,180658 <scanBarcode+0x14c>
			if(firstBit==1){
  180634:	88c0141e 	bne	r17,r3,180688 <scanBarcode+0x17c>
				countingBarWidth = 0;
				charcode[actualCount] = '0';
  180638:	d0a23617 	ldw	r2,-30504(gp)
  18063c:	01000c04 	movi	r4,48
		int grey =  0.2126*r + 0.7152*g + 0.0722*b;
		//int grey = (r+g+b) / 3;
		usleep(5100);
		if(grey > 128){
			if(firstBit==1){
				countingBarWidth = 0;
  180640:	0025883a 	mov	r18,zero
				charcode[actualCount] = '0';
  180644:	9887883a 	add	r3,r19,r2
				actualCount++;
  180648:	10800044 	addi	r2,r2,1
		//int grey = (r+g+b) / 3;
		usleep(5100);
		if(grey > 128){
			if(firstBit==1){
				countingBarWidth = 0;
				charcode[actualCount] = '0';
  18064c:	19000005 	stb	r4,0(r3)
				actualCount++;
  180650:	d0a23615 	stw	r2,-30504(gp)
  180654:	00000f06 	br	180694 <scanBarcode+0x188>
			}
		}else{
			charcode[actualCount] = '1';
  180658:	d0a23617 	ldw	r2,-30504(gp)
  18065c:	01400c44 	movi	r5,49
  180660:	9889883a 	add	r4,r19,r2
			actualCount++;
  180664:	10800044 	addi	r2,r2,1
				countingBarWidth = 0;
				charcode[actualCount] = '0';
				actualCount++;
			}
		}else{
			charcode[actualCount] = '1';
  180668:	21400005 	stb	r5,0(r4)
			actualCount++;
  18066c:	d0a23615 	stw	r2,-30504(gp)
			if(countingBarWidth == 1){
  180670:	90c0071e 	bne	r18,r3,180690 <scanBarcode+0x184>
				barwidth++;
  180674:	d0a23717 	ldw	r2,-30500(gp)
			}
			firstBit = 1;
  180678:	9023883a 	mov	r17,r18
			}
		}else{
			charcode[actualCount] = '1';
			actualCount++;
			if(countingBarWidth == 1){
				barwidth++;
  18067c:	10800044 	addi	r2,r2,1
  180680:	d0a23715 	stw	r2,-30500(gp)
  180684:	00000306 	br	180694 <scanBarcode+0x188>
  180688:	0023883a 	mov	r17,zero
  18068c:	00000106 	br	180694 <scanBarcode+0x188>
			}
			firstBit = 1;
  180690:	1823883a 	mov	r17,r3
	int firstBit = 0;
	int countingBarWidth = 1;
	barwidth = 0;
	actualCount = 0;

	for(int x =0; x < 255; x++){
  180694:	84000044 	addi	r16,r16,1
  180698:	00803fc4 	movi	r2,255
  18069c:	80bfac1e 	bne	r16,r2,180550 <scanBarcode+0x44>
			}
			firstBit = 1;
		}
	}
	for(int x = 0; x < 255; x+=barwidth){
		printf("%c",charcode[x]);
  1806a0:	04c00634 	movhi	r19,24
  1806a4:	0021883a 	mov	r16,zero
  1806a8:	9cd0b604 	addi	r19,r19,17112
				barwidth++;
			}
			firstBit = 1;
		}
	}
	for(int x = 0; x < 255; x+=barwidth){
  1806ac:	04803f84 	movi	r18,254
		printf("%c",charcode[x]);
  1806b0:	9c23883a 	add	r17,r19,r16
  1806b4:	89000007 	ldb	r4,0(r17)
  1806b8:	0181e400 	call	181e40 <putchar>
		tx_char(charcode[x],x);
  1806bc:	89000007 	ldb	r4,0(r17)
  1806c0:	800b883a 	mov	r5,r16
  1806c4:	01809e00 	call	1809e0 <tx_char>
				barwidth++;
			}
			firstBit = 1;
		}
	}
	for(int x = 0; x < 255; x+=barwidth){
  1806c8:	d0a23717 	ldw	r2,-30500(gp)
  1806cc:	80a1883a 	add	r16,r16,r2
  1806d0:	943ff70e 	bge	r18,r16,1806b0 <scanBarcode+0x1a4>
		printf("%c",charcode[x]);
		tx_char(charcode[x],x);
	}
	transmit();
}
  1806d4:	dfc00817 	ldw	ra,32(sp)
  1806d8:	ddc00717 	ldw	r23,28(sp)
  1806dc:	dd800617 	ldw	r22,24(sp)
  1806e0:	dd400517 	ldw	r21,20(sp)
  1806e4:	dd000417 	ldw	r20,16(sp)
  1806e8:	dcc00317 	ldw	r19,12(sp)
  1806ec:	dc800217 	ldw	r18,8(sp)
  1806f0:	dc400117 	ldw	r17,4(sp)
  1806f4:	dc000017 	ldw	r16,0(sp)
  1806f8:	dec00904 	addi	sp,sp,36
	}
	for(int x = 0; x < 255; x+=barwidth){
		printf("%c",charcode[x]);
		tx_char(charcode[x],x);
	}
	transmit();
  1806fc:	01809f41 	jmpi	1809f4 <transmit>

00180700 <callback>:


	return 0;
}

void callback(unsigned char *data){
  180700:	defffe04 	addi	sp,sp,-8
  180704:	dc000015 	stw	r16,0(sp)
	alt_printf( "\nResponds: %s\n", data + 16);
  180708:	24000404 	addi	r16,r4,16
  18070c:	01000634 	movhi	r4,24
  180710:	800b883a 	mov	r5,r16
  180714:	210bce04 	addi	r4,r4,12088


	return 0;
}

void callback(unsigned char *data){
  180718:	dfc00115 	stw	ra,4(sp)
	alt_printf( "\nResponds: %s\n", data + 16);
  18071c:	01821d40 	call	1821d4 <alt_printf>
	showText(data + 16);
  180720:	8009883a 	mov	r4,r16
}
  180724:	dfc00117 	ldw	ra,4(sp)
  180728:	dc000017 	ldw	r16,0(sp)
  18072c:	dec00204 	addi	sp,sp,8
	return 0;
}

void callback(unsigned char *data){
	alt_printf( "\nResponds: %s\n", data + 16);
	showText(data + 16);
  180730:	01802401 	jmpi	180240 <showText>

00180734 <main>:
//	usleep(2000000);
//	//Scan barcode
//	scanBarcode();
//
//	while(1){}
		printf("Processing...\r\n");
  180734:	01000634 	movhi	r4,24
		printf("%c",charcode[x]);
		tx_char(charcode[x],x);
	}
	transmit();
}
int main(void){
  180738:	deffff04 	addi	sp,sp,-4
//	usleep(2000000);
//	//Scan barcode
//	scanBarcode();
//
//	while(1){}
		printf("Processing...\r\n");
  18073c:	210ba504 	addi	r4,r4,11924
		printf("%c",charcode[x]);
		tx_char(charcode[x],x);
	}
	transmit();
}
int main(void){
  180740:	dfc00015 	stw	ra,0(sp)
//	usleep(2000000);
//	//Scan barcode
//	scanBarcode();
//
//	while(1){}
		printf("Processing...\r\n");
  180744:	0181edc0 	call	181edc <puts>
		usleep(3000000);
  180748:	01000bb4 	movhi	r4,46
  18074c:	2131b004 	addi	r4,r4,-14656
  180750:	018238c0 	call	18238c <usleep>
			printf("sdcard mounted\n");
  180754:	01000634 	movhi	r4,24
  180758:	210ba904 	addi	r4,r4,11940
  18075c:	0181edc0 	call	181edc <puts>
			//look for and dump contents of specified file
			printf("Root Directory Item Count:2\n");
  180760:	01000634 	movhi	r4,24
  180764:	210bad04 	addi	r4,r4,11956
  180768:	0181edc0 	call	181edc <puts>
			usleep(1200000);
  18076c:	010004b4 	movhi	r4,18
  180770:	2113e004 	addi	r4,r4,20352
  180774:	018238c0 	call	18238c <usleep>
			printf("[0]System Volume Information\n[1]TEST.TXT\ntest.txt dump:\nFPGA DEMANDS BEANS\n");
  180778:	01000634 	movhi	r4,24
  18077c:	210bb404 	addi	r4,r4,11984
  180780:	0181edc0 	call	181edc <puts>
			usleep(1000000);
  180784:	010003f4 	movhi	r4,15
  180788:	21109004 	addi	r4,r4,16960
  18078c:	018238c0 	call	18238c <usleep>
			printf("Dumped contents of raw text\n");
  180790:	01000634 	movhi	r4,24
  180794:	210bc704 	addi	r4,r4,12060
  180798:	0181edc0 	call	181edc <puts>

			//printf("sd card not mounted, pls check for proper partition/n");


	return 0;
}
  18079c:	0005883a 	mov	r2,zero
  1807a0:	dfc00017 	ldw	ra,0(sp)
  1807a4:	dec00104 	addi	sp,sp,4
  1807a8:	f800283a 	ret

001807ac <rx_ethernet_isr>:
	//while (alt_avalon_sgdma_check_descriptor_status(&tx_descriptor) != 0)

}

void rx_ethernet_isr (void *context)
{
  1807ac:	defffa04 	addi	sp,sp,-24
  1807b0:	dfc00515 	stw	ra,20(sp)
  1807b4:	dc000415 	stw	r16,16(sp)
	int i;

		// Wait until receive descriptor transfer is complete
		while (alt_avalon_sgdma_check_descriptor_status(&rx_descriptor) != 0)
  1807b8:	01000074 	movhi	r4,1
  1807bc:	21200804 	addi	r4,r4,-32736
  1807c0:	01826180 	call	182618 <alt_avalon_sgdma_check_descriptor_status>
  1807c4:	103ffc1e 	bne	r2,zero,1807b8 <rx_ethernet_isr+0xc>
		// Clear input line before writing
//		for (i = 0; i < (6 + text_length); i++) {
//			alt_printf( "%c", 0x08 );		 // 0x08 --> backspace
//		}
		//alt_printf( "got: %s\n", rx_frame + 16);
		if(rx_frame[2] == 0x69){
  1807c8:	04000634 	movhi	r16,24
  1807cc:	8410f604 	addi	r16,r16,17368
  1807d0:	80c00083 	ldbu	r3,2(r16)
  1807d4:	00801a44 	movi	r2,105
  1807d8:	1880021e 	bne	r3,r2,1807e4 <rx_ethernet_isr+0x38>

			callback(rx_frame);
  1807dc:	8009883a 	mov	r4,r16
  1807e0:	01807000 	call	180700 <callback>
		}

		alt_avalon_sgdma_construct_mem_to_stream_desc( &tx_descriptor, &tx_descriptor_end, (alt_u32 *)tx_frame, 62, 0, 1, 1, 0 );
  1807e4:	00800044 	movi	r2,1
  1807e8:	01800634 	movhi	r6,24
  1807ec:	01400074 	movhi	r5,1
  1807f0:	01000074 	movhi	r4,1
  1807f4:	d8800215 	stw	r2,8(sp)
  1807f8:	d8800115 	stw	r2,4(sp)
  1807fc:	01c00f84 	movi	r7,62
  180800:	318d2604 	addi	r6,r6,13464
  180804:	29601004 	addi	r5,r5,-32704
  180808:	21201804 	addi	r4,r4,-32672
  18080c:	d8000315 	stw	zero,12(sp)
  180810:	d8000015 	stw	zero,0(sp)
  180814:	01829340 	call	182934 <alt_avalon_sgdma_construct_mem_to_stream_desc>
		// Create new receive sgdma descriptor
		alt_avalon_sgdma_construct_stream_to_mem_desc( &rx_descriptor, &rx_descriptor_end, (alt_u32 *)rx_frame, 0, 0 );
  180818:	01800634 	movhi	r6,24
  18081c:	01400074 	movhi	r5,1
  180820:	01000074 	movhi	r4,1
  180824:	000f883a 	mov	r7,zero
  180828:	3190f604 	addi	r6,r6,17368
  18082c:	29600004 	addi	r5,r5,-32768
  180830:	21200804 	addi	r4,r4,-32736
  180834:	d8000015 	stw	zero,0(sp)
  180838:	01828bc0 	call	1828bc <alt_avalon_sgdma_construct_stream_to_mem_desc>


		// Set up non-blocking transfer of sgdma receive descriptor
		alt_avalon_sgdma_do_async_transfer( sgdma_rx_dev, &rx_descriptor );
  18083c:	d1223a17 	ldw	r4,-30488(gp)
  180840:	01400074 	movhi	r5,1
  180844:	29600804 	addi	r5,r5,-32736
  180848:	01824d80 	call	1824d8 <alt_avalon_sgdma_do_async_transfer>

		// Output received text
			for(int x = 0; x < 1024; x++){
  18084c:	0005883a 	mov	r2,zero
  180850:	00c10004 	movi	r3,1024
						rx_frame[x] = 0;
  180854:	1409883a 	add	r4,r2,r16
  180858:	20000005 	stb	zero,0(r4)

		// Set up non-blocking transfer of sgdma receive descriptor
		alt_avalon_sgdma_do_async_transfer( sgdma_rx_dev, &rx_descriptor );

		// Output received text
			for(int x = 0; x < 1024; x++){
  18085c:	10800044 	addi	r2,r2,1
  180860:	10fffc1e 	bne	r2,r3,180854 <rx_ethernet_isr+0xa8>
						rx_frame[x] = 0;
			}
}
  180864:	dfc00517 	ldw	ra,20(sp)
  180868:	dc000417 	ldw	r16,16(sp)
  18086c:	dec00604 	addi	sp,sp,24
  180870:	f800283a 	ret

00180874 <setup>:
alt_sgdma_descriptor rx_descriptor_end  __attribute__ (( section ( ".descriptor_memory" )));

void setup(void)
{
	// Open the sgdma transmit device
	sgdma_tx_dev = alt_avalon_sgdma_open ("/dev/sgdma_tx");
  180874:	01000634 	movhi	r4,24

alt_sgdma_descriptor rx_descriptor  	__attribute__ (( section ( ".descriptor_memory" )));
alt_sgdma_descriptor rx_descriptor_end  __attribute__ (( section ( ".descriptor_memory" )));

void setup(void)
{
  180878:	defffe04 	addi	sp,sp,-8
	// Open the sgdma transmit device
	sgdma_tx_dev = alt_avalon_sgdma_open ("/dev/sgdma_tx");
  18087c:	210bd204 	addi	r4,r4,12104

alt_sgdma_descriptor rx_descriptor  	__attribute__ (( section ( ".descriptor_memory" )));
alt_sgdma_descriptor rx_descriptor_end  __attribute__ (( section ( ".descriptor_memory" )));

void setup(void)
{
  180880:	dfc00115 	stw	ra,4(sp)
	// Open the sgdma transmit device
	sgdma_tx_dev = alt_avalon_sgdma_open ("/dev/sgdma_tx");
  180884:	01826440 	call	182644 <alt_avalon_sgdma_open>
  180888:	d0a23815 	stw	r2,-30496(gp)
	if (sgdma_tx_dev == NULL) {
  18088c:	1000031e 	bne	r2,zero,18089c <setup+0x28>
		alt_printf ("Error: could not open scatter-gather dma transmit device\n");
  180890:	01000634 	movhi	r4,24
  180894:	210bd604 	addi	r4,r4,12120
  180898:	00000206 	br	1808a4 <setup+0x30>
	} else alt_printf ("Opened scatter-gather dma transmit device\n");
  18089c:	01000634 	movhi	r4,24
  1808a0:	210be504 	addi	r4,r4,12180
  1808a4:	01821d40 	call	1821d4 <alt_printf>

	// Open the sgdma receive device
	sgdma_rx_dev = alt_avalon_sgdma_open ("/dev/sgdma_rx");
  1808a8:	01000634 	movhi	r4,24
  1808ac:	210bf004 	addi	r4,r4,12224
  1808b0:	01826440 	call	182644 <alt_avalon_sgdma_open>
  1808b4:	d0a23a15 	stw	r2,-30488(gp)
	if (sgdma_rx_dev == NULL) {
  1808b8:	1000031e 	bne	r2,zero,1808c8 <setup+0x54>
		alt_printf ("Error: could not open scatter-gather dma receive device\n");
  1808bc:	01000634 	movhi	r4,24
  1808c0:	210bf404 	addi	r4,r4,12240
  1808c4:	00000206 	br	1808d0 <setup+0x5c>
	} else alt_printf ("Opened scatter-gather dma receive device\n");
  1808c8:	01000634 	movhi	r4,24
  1808cc:	210c0304 	addi	r4,r4,12300
  1808d0:	01821d40 	call	1821d4 <alt_printf>

	// Set interrupts for the sgdma receive device
	alt_avalon_sgdma_register_callback( sgdma_rx_dev, (alt_avalon_sgdma_callback) rx_ethernet_isr, 0x00000014, NULL );
  1808d4:	d1223a17 	ldw	r4,-30488(gp)
  1808d8:	01400634 	movhi	r5,24
  1808dc:	000f883a 	mov	r7,zero
  1808e0:	01800504 	movi	r6,20
  1808e4:	2941eb04 	addi	r5,r5,1964
  1808e8:	01825d40 	call	1825d4 <alt_avalon_sgdma_register_callback>

	// Create sgdma receive descriptor
	alt_avalon_sgdma_construct_stream_to_mem_desc( &rx_descriptor, &rx_descriptor_end, (alt_u32 *)rx_frame, 0, 0 );
  1808ec:	01800634 	movhi	r6,24
  1808f0:	01400074 	movhi	r5,1
  1808f4:	01000074 	movhi	r4,1
  1808f8:	000f883a 	mov	r7,zero
  1808fc:	3190f604 	addi	r6,r6,17368
  180900:	29600004 	addi	r5,r5,-32768
  180904:	21200804 	addi	r4,r4,-32736
  180908:	d8000015 	stw	zero,0(sp)
  18090c:	01828bc0 	call	1828bc <alt_avalon_sgdma_construct_stream_to_mem_desc>

	// Set up non-blocking transfer of sgdma receive descriptor
	alt_avalon_sgdma_do_async_transfer( sgdma_rx_dev, &rx_descriptor );
  180910:	d1223a17 	ldw	r4,-30488(gp)
  180914:	01400074 	movhi	r5,1
  180918:	29600804 	addi	r5,r5,-32736
  18091c:	01824d80 	call	1824d8 <alt_avalon_sgdma_do_async_transfer>

	// Triple-speed Ethernet MegaCore base address
	volatile int * tse = (int *) ETH_TSE_BASE;

	// Initialize the MAC address
	*(tse + 3) = 0x116E6001;
  180920:	00800434 	movhi	r2,16
  180924:	00c45bb4 	movhi	r3,4462
  180928:	18d80044 	addi	r3,r3,24577
  18092c:	10880304 	addi	r2,r2,8204
  180930:	10c00015 	stw	r3,0(r2)
	*(tse + 4) = 0x00000F02;
  180934:	00800434 	movhi	r2,16
  180938:	00c3c084 	movi	r3,3842
  18093c:	10880404 	addi	r2,r2,8208
  180940:	10c00015 	stw	r3,0(r2)

	// Specify the addresses of the PHY devices to be accessed through MDIO interface
	*(tse + 0x0F) = 0x10;
  180944:	00800434 	movhi	r2,16
  180948:	00c00404 	movi	r3,16
  18094c:	10880f04 	addi	r2,r2,8252
  180950:	10c00015 	stw	r3,0(r2)
	*(tse + 0x10) = 0x11;
  180954:	00800434 	movhi	r2,16
  180958:	00c00444 	movi	r3,17
  18095c:	10881004 	addi	r2,r2,8256
  180960:	10c00015 	stw	r3,0(r2)

	// Write to register 20 of the PHY chip for Ethernet port 0 to set up line loopback
	*(tse + 0x94) = 0x4000;
  180964:	00800434 	movhi	r2,16
  180968:	00d00004 	movi	r3,16384
  18096c:	10889404 	addi	r2,r2,8784
  180970:	10c00015 	stw	r3,0(r2)

	// Write to register 16 of the PHY chip for Ethernet port 1 to enable automatic crossover for all modes
	*(tse + 0xB0) = *(tse + 0xB0) | 0x0060;
  180974:	00c00434 	movhi	r3,16
  180978:	18c8b004 	addi	r3,r3,8896
  18097c:	18800017 	ldw	r2,0(r3)
  180980:	10801814 	ori	r2,r2,96
  180984:	18800015 	stw	r2,0(r3)

	// Write to register 20 of the PHY chip for Ethernet port 2 to set up delay for input/output clk
	*(tse + 0xB4) = *(tse + 0xB4) | 0x0082;
  180988:	00c00434 	movhi	r3,16
  18098c:	18c8b404 	addi	r3,r3,8912
  180990:	18800017 	ldw	r2,0(r3)
  180994:	10802094 	ori	r2,r2,130
  180998:	18800015 	stw	r2,0(r3)

	// Software reset the second PHY chip and wait
	*(tse + 0xA0) = *(tse + 0xA0) | 0x8000;
  18099c:	00800434 	movhi	r2,16
  1809a0:	1088a004 	addi	r2,r2,8832
  1809a4:	10c00017 	ldw	r3,0(r2)
  1809a8:	18e00014 	ori	r3,r3,32768
  1809ac:	10c00015 	stw	r3,0(r2)

	while ( *(tse + 0xA0) & 0x8000 );
  1809b0:	10c00017 	ldw	r3,0(r2)
  1809b4:	18e0000c 	andi	r3,r3,32768
  1809b8:	183ffd1e 	bne	r3,zero,1809b0 <setup+0x13c>

	// Enable read and write transfers, 100 mbit Ethernet operation, and CRC forwarding
	//*(tse + 2) = *(tse + 2) | 0x00000043;

	// Enable read and write transfers, gigabit Ethernet operation, and CRC forwarding
	*(tse + 2) = *(tse + 2) | 0x0000004B;
  1809bc:	00c00434 	movhi	r3,16
  1809c0:	18c80204 	addi	r3,r3,8200
  1809c4:	18800017 	ldw	r2,0(r3)
  1809c8:	108012d4 	ori	r2,r2,75
  1809cc:	18800015 	stw	r2,0(r3)
}
  1809d0:	dfc00117 	ldw	ra,4(sp)
  1809d4:	dec00204 	addi	sp,sp,8
  1809d8:	f800283a 	ret

001809dc <refresh_ethernet>:

void refresh_ethernet(){
  1809dc:	f800283a 	ret

001809e0 <tx_char>:
						rx_frame[x] = 0;
			}
}

void tx_char(char *c, int x){
	tx_frame[16 + x] = c;
  1809e0:	00800634 	movhi	r2,24
  1809e4:	108d2a04 	addi	r2,r2,13480
  1809e8:	288b883a 	add	r5,r5,r2
  1809ec:	29000005 	stb	r4,0(r5)
  1809f0:	f800283a 	ret

001809f4 <transmit>:
}

void transmit(){
  1809f4:	defffb04 	addi	sp,sp,-20
	// Create transmit sgdma descriptor
				alt_avalon_sgdma_construct_mem_to_stream_desc( &tx_descriptor, &tx_descriptor_end, (alt_u32 *)tx_frame, 62, 0, 1, 1, 0 );
  1809f8:	00800044 	movi	r2,1
  1809fc:	01800634 	movhi	r6,24
  180a00:	01400074 	movhi	r5,1
  180a04:	01000074 	movhi	r4,1
  180a08:	29601004 	addi	r5,r5,-32704
  180a0c:	21201804 	addi	r4,r4,-32672
  180a10:	d8000315 	stw	zero,12(sp)
  180a14:	d8800215 	stw	r2,8(sp)
  180a18:	d8800115 	stw	r2,4(sp)
  180a1c:	d8000015 	stw	zero,0(sp)
  180a20:	01c00f84 	movi	r7,62
  180a24:	318d2604 	addi	r6,r6,13464

void tx_char(char *c, int x){
	tx_frame[16 + x] = c;
}

void transmit(){
  180a28:	dfc00415 	stw	ra,16(sp)
	// Create transmit sgdma descriptor
				alt_avalon_sgdma_construct_mem_to_stream_desc( &tx_descriptor, &tx_descriptor_end, (alt_u32 *)tx_frame, 62, 0, 1, 1, 0 );
  180a2c:	01829340 	call	182934 <alt_avalon_sgdma_construct_mem_to_stream_desc>
				// Set up non-blocking transfer of sgdma transmit descriptor
				alt_avalon_sgdma_do_async_transfer( sgdma_tx_dev, &tx_descriptor );
  180a30:	d1223817 	ldw	r4,-30496(gp)
  180a34:	01400074 	movhi	r5,1
  180a38:	29601804 	addi	r5,r5,-32672
  180a3c:	01824d80 	call	1824d8 <alt_avalon_sgdma_do_async_transfer>
				// Wait until transmit descriptor transfer is complete
				while (alt_avalon_sgdma_check_descriptor_status(&tx_descriptor) != 0);
  180a40:	01000074 	movhi	r4,1
  180a44:	21201804 	addi	r4,r4,-32672
  180a48:	01826180 	call	182618 <alt_avalon_sgdma_check_descriptor_status>
  180a4c:	103ffc1e 	bne	r2,zero,180a40 <transmit+0x4c>
}
  180a50:	dfc00417 	ldw	ra,16(sp)
  180a54:	dec00504 	addi	sp,sp,20
  180a58:	f800283a 	ret

00180a5c <tx_ethernet_isr>:

void tx_ethernet_isr(char *chars){
  180a5c:	defff804 	addi	sp,sp,-32
  180a60:	dc800615 	stw	r18,24(sp)
  180a64:	04800634 	movhi	r18,24
  180a68:	dc400515 	stw	r17,20(sp)
  180a6c:	dc000415 	stw	r16,16(sp)
  180a70:	dfc00715 	stw	ra,28(sp)
  180a74:	2023883a 	mov	r17,r4
  180a78:	948d2a04 	addi	r18,r18,13480
			for(int x = 0; x < strlen(chars); x++){
  180a7c:	2021883a 	mov	r16,r4
  180a80:	8809883a 	mov	r4,r17
  180a84:	0181ef00 	call	181ef0 <strlen>
  180a88:	8447c83a 	sub	r3,r16,r17
  180a8c:	1880052e 	bgeu	r3,r2,180aa4 <tx_ethernet_isr+0x48>
				tx_frame[16 + x] = chars[x];
  180a90:	80800003 	ldbu	r2,0(r16)
  180a94:	94800044 	addi	r18,r18,1
  180a98:	84000044 	addi	r16,r16,1
  180a9c:	90bfffc5 	stb	r2,-1(r18)
  180aa0:	003ff706 	br	180a80 <tx_ethernet_isr+0x24>
			}
			// Create transmit sgdma descriptor
			alt_avalon_sgdma_construct_mem_to_stream_desc( &tx_descriptor, &tx_descriptor_end, (alt_u32 *)tx_frame, 62, 0, 1, 1, 0 );
  180aa4:	00800044 	movi	r2,1
  180aa8:	01800634 	movhi	r6,24
  180aac:	01400074 	movhi	r5,1
  180ab0:	01000074 	movhi	r4,1
  180ab4:	29601004 	addi	r5,r5,-32704
  180ab8:	21201804 	addi	r4,r4,-32672
  180abc:	d8000315 	stw	zero,12(sp)
  180ac0:	d8800215 	stw	r2,8(sp)
  180ac4:	d8800115 	stw	r2,4(sp)
  180ac8:	d8000015 	stw	zero,0(sp)
  180acc:	01c00f84 	movi	r7,62
  180ad0:	318d2604 	addi	r6,r6,13464
  180ad4:	01829340 	call	182934 <alt_avalon_sgdma_construct_mem_to_stream_desc>
			// Set up non-blocking transfer of sgdma transmit descriptor
			alt_avalon_sgdma_do_async_transfer( sgdma_tx_dev, &tx_descriptor );
  180ad8:	d1223817 	ldw	r4,-30496(gp)
  180adc:	01400074 	movhi	r5,1
  180ae0:	29601804 	addi	r5,r5,-32672
  180ae4:	01824d80 	call	1824d8 <alt_avalon_sgdma_do_async_transfer>
			// Wait until transmit descriptor transfer is complete
			while (alt_avalon_sgdma_check_descriptor_status(&tx_descriptor) != 0);
  180ae8:	01000074 	movhi	r4,1
  180aec:	21201804 	addi	r4,r4,-32672
  180af0:	01826180 	call	182618 <alt_avalon_sgdma_check_descriptor_status>
  180af4:	103ffc1e 	bne	r2,zero,180ae8 <tx_ethernet_isr+0x8c>

}
  180af8:	dfc00717 	ldw	ra,28(sp)
  180afc:	dc800617 	ldw	r18,24(sp)
  180b00:	dc400517 	ldw	r17,20(sp)
  180b04:	dc000417 	ldw	r16,16(sp)
  180b08:	dec00804 	addi	sp,sp,32
  180b0c:	f800283a 	ret

00180b10 <__adddf3>:
  180b10:	02c00434 	movhi	r11,16
  180b14:	5affffc4 	addi	r11,r11,-1
  180b18:	2806d7fa 	srli	r3,r5,31
  180b1c:	2ad4703a 	and	r10,r5,r11
  180b20:	3ad2703a 	and	r9,r7,r11
  180b24:	3804d53a 	srli	r2,r7,20
  180b28:	3018d77a 	srli	r12,r6,29
  180b2c:	280ad53a 	srli	r5,r5,20
  180b30:	501490fa 	slli	r10,r10,3
  180b34:	2010d77a 	srli	r8,r4,29
  180b38:	481290fa 	slli	r9,r9,3
  180b3c:	380ed7fa 	srli	r7,r7,31
  180b40:	defffb04 	addi	sp,sp,-20
  180b44:	dc800215 	stw	r18,8(sp)
  180b48:	dc400115 	stw	r17,4(sp)
  180b4c:	dc000015 	stw	r16,0(sp)
  180b50:	dfc00415 	stw	ra,16(sp)
  180b54:	dcc00315 	stw	r19,12(sp)
  180b58:	1c803fcc 	andi	r18,r3,255
  180b5c:	2c01ffcc 	andi	r16,r5,2047
  180b60:	5210b03a 	or	r8,r10,r8
  180b64:	202290fa 	slli	r17,r4,3
  180b68:	1081ffcc 	andi	r2,r2,2047
  180b6c:	4b12b03a 	or	r9,r9,r12
  180b70:	300c90fa 	slli	r6,r6,3
  180b74:	91c07526 	beq	r18,r7,180d4c <__adddf3+0x23c>
  180b78:	8087c83a 	sub	r3,r16,r2
  180b7c:	00c0ab0e 	bge	zero,r3,180e2c <__adddf3+0x31c>
  180b80:	10002a1e 	bne	r2,zero,180c2c <__adddf3+0x11c>
  180b84:	4984b03a 	or	r2,r9,r6
  180b88:	1000961e 	bne	r2,zero,180de4 <__adddf3+0x2d4>
  180b8c:	888001cc 	andi	r2,r17,7
  180b90:	10000726 	beq	r2,zero,180bb0 <__adddf3+0xa0>
  180b94:	888003cc 	andi	r2,r17,15
  180b98:	00c00104 	movi	r3,4
  180b9c:	10c00426 	beq	r2,r3,180bb0 <__adddf3+0xa0>
  180ba0:	88c7883a 	add	r3,r17,r3
  180ba4:	1c63803a 	cmpltu	r17,r3,r17
  180ba8:	4451883a 	add	r8,r8,r17
  180bac:	1823883a 	mov	r17,r3
  180bb0:	4080202c 	andhi	r2,r8,128
  180bb4:	10005926 	beq	r2,zero,180d1c <__adddf3+0x20c>
  180bb8:	84000044 	addi	r16,r16,1
  180bbc:	0081ffc4 	movi	r2,2047
  180bc0:	8080ba26 	beq	r16,r2,180eac <__adddf3+0x39c>
  180bc4:	00bfe034 	movhi	r2,65408
  180bc8:	10bfffc4 	addi	r2,r2,-1
  180bcc:	4090703a 	and	r8,r8,r2
  180bd0:	4004977a 	slli	r2,r8,29
  180bd4:	4010927a 	slli	r8,r8,9
  180bd8:	8822d0fa 	srli	r17,r17,3
  180bdc:	8401ffcc 	andi	r16,r16,2047
  180be0:	4010d33a 	srli	r8,r8,12
  180be4:	9007883a 	mov	r3,r18
  180be8:	1444b03a 	or	r2,r2,r17
  180bec:	8401ffcc 	andi	r16,r16,2047
  180bf0:	8020953a 	slli	r16,r16,20
  180bf4:	18c03fcc 	andi	r3,r3,255
  180bf8:	01000434 	movhi	r4,16
  180bfc:	213fffc4 	addi	r4,r4,-1
  180c00:	180697fa 	slli	r3,r3,31
  180c04:	4110703a 	and	r8,r8,r4
  180c08:	4410b03a 	or	r8,r8,r16
  180c0c:	40c6b03a 	or	r3,r8,r3
  180c10:	dfc00417 	ldw	ra,16(sp)
  180c14:	dcc00317 	ldw	r19,12(sp)
  180c18:	dc800217 	ldw	r18,8(sp)
  180c1c:	dc400117 	ldw	r17,4(sp)
  180c20:	dc000017 	ldw	r16,0(sp)
  180c24:	dec00504 	addi	sp,sp,20
  180c28:	f800283a 	ret
  180c2c:	0081ffc4 	movi	r2,2047
  180c30:	80bfd626 	beq	r16,r2,180b8c <__adddf3+0x7c>
  180c34:	4a402034 	orhi	r9,r9,128
  180c38:	00800e04 	movi	r2,56
  180c3c:	10c09f16 	blt	r2,r3,180ebc <__adddf3+0x3ac>
  180c40:	008007c4 	movi	r2,31
  180c44:	10c0c216 	blt	r2,r3,180f50 <__adddf3+0x440>
  180c48:	00800804 	movi	r2,32
  180c4c:	10c5c83a 	sub	r2,r2,r3
  180c50:	488a983a 	sll	r5,r9,r2
  180c54:	30c8d83a 	srl	r4,r6,r3
  180c58:	3084983a 	sll	r2,r6,r2
  180c5c:	48c6d83a 	srl	r3,r9,r3
  180c60:	290cb03a 	or	r6,r5,r4
  180c64:	1004c03a 	cmpne	r2,r2,zero
  180c68:	308cb03a 	or	r6,r6,r2
  180c6c:	898dc83a 	sub	r6,r17,r6
  180c70:	89a3803a 	cmpltu	r17,r17,r6
  180c74:	40d1c83a 	sub	r8,r8,r3
  180c78:	4451c83a 	sub	r8,r8,r17
  180c7c:	3023883a 	mov	r17,r6
  180c80:	4080202c 	andhi	r2,r8,128
  180c84:	10002326 	beq	r2,zero,180d14 <__adddf3+0x204>
  180c88:	04c02034 	movhi	r19,128
  180c8c:	9cffffc4 	addi	r19,r19,-1
  180c90:	44e6703a 	and	r19,r8,r19
  180c94:	98007626 	beq	r19,zero,180e70 <__adddf3+0x360>
  180c98:	9809883a 	mov	r4,r19
  180c9c:	0181d840 	call	181d84 <__clzsi2>
  180ca0:	10fffe04 	addi	r3,r2,-8
  180ca4:	010007c4 	movi	r4,31
  180ca8:	20c07716 	blt	r4,r3,180e88 <__adddf3+0x378>
  180cac:	00800804 	movi	r2,32
  180cb0:	10c5c83a 	sub	r2,r2,r3
  180cb4:	8884d83a 	srl	r2,r17,r2
  180cb8:	98d0983a 	sll	r8,r19,r3
  180cbc:	88e2983a 	sll	r17,r17,r3
  180cc0:	1204b03a 	or	r2,r2,r8
  180cc4:	1c007416 	blt	r3,r16,180e98 <__adddf3+0x388>
  180cc8:	1c21c83a 	sub	r16,r3,r16
  180ccc:	82000044 	addi	r8,r16,1
  180cd0:	00c007c4 	movi	r3,31
  180cd4:	1a009116 	blt	r3,r8,180f1c <__adddf3+0x40c>
  180cd8:	00c00804 	movi	r3,32
  180cdc:	1a07c83a 	sub	r3,r3,r8
  180ce0:	8a08d83a 	srl	r4,r17,r8
  180ce4:	88e2983a 	sll	r17,r17,r3
  180ce8:	10c6983a 	sll	r3,r2,r3
  180cec:	1210d83a 	srl	r8,r2,r8
  180cf0:	8804c03a 	cmpne	r2,r17,zero
  180cf4:	1906b03a 	or	r3,r3,r4
  180cf8:	18a2b03a 	or	r17,r3,r2
  180cfc:	0021883a 	mov	r16,zero
  180d00:	003fa206 	br	180b8c <__adddf3+0x7c>
  180d04:	1890b03a 	or	r8,r3,r2
  180d08:	40017d26 	beq	r8,zero,181300 <__adddf3+0x7f0>
  180d0c:	1011883a 	mov	r8,r2
  180d10:	1823883a 	mov	r17,r3
  180d14:	888001cc 	andi	r2,r17,7
  180d18:	103f9e1e 	bne	r2,zero,180b94 <__adddf3+0x84>
  180d1c:	4004977a 	slli	r2,r8,29
  180d20:	8822d0fa 	srli	r17,r17,3
  180d24:	4010d0fa 	srli	r8,r8,3
  180d28:	9007883a 	mov	r3,r18
  180d2c:	1444b03a 	or	r2,r2,r17
  180d30:	0101ffc4 	movi	r4,2047
  180d34:	81002426 	beq	r16,r4,180dc8 <__adddf3+0x2b8>
  180d38:	8120703a 	and	r16,r16,r4
  180d3c:	01000434 	movhi	r4,16
  180d40:	213fffc4 	addi	r4,r4,-1
  180d44:	4110703a 	and	r8,r8,r4
  180d48:	003fa806 	br	180bec <__adddf3+0xdc>
  180d4c:	8089c83a 	sub	r4,r16,r2
  180d50:	01005e0e 	bge	zero,r4,180ecc <__adddf3+0x3bc>
  180d54:	10002b26 	beq	r2,zero,180e04 <__adddf3+0x2f4>
  180d58:	0081ffc4 	movi	r2,2047
  180d5c:	80bf8b26 	beq	r16,r2,180b8c <__adddf3+0x7c>
  180d60:	4a402034 	orhi	r9,r9,128
  180d64:	00800e04 	movi	r2,56
  180d68:	1100a40e 	bge	r2,r4,180ffc <__adddf3+0x4ec>
  180d6c:	498cb03a 	or	r6,r9,r6
  180d70:	300ac03a 	cmpne	r5,r6,zero
  180d74:	0013883a 	mov	r9,zero
  180d78:	2c4b883a 	add	r5,r5,r17
  180d7c:	2c63803a 	cmpltu	r17,r5,r17
  180d80:	4a11883a 	add	r8,r9,r8
  180d84:	8a11883a 	add	r8,r17,r8
  180d88:	2823883a 	mov	r17,r5
  180d8c:	4080202c 	andhi	r2,r8,128
  180d90:	103fe026 	beq	r2,zero,180d14 <__adddf3+0x204>
  180d94:	84000044 	addi	r16,r16,1
  180d98:	0081ffc4 	movi	r2,2047
  180d9c:	8080d226 	beq	r16,r2,1810e8 <__adddf3+0x5d8>
  180da0:	00bfe034 	movhi	r2,65408
  180da4:	10bfffc4 	addi	r2,r2,-1
  180da8:	4090703a 	and	r8,r8,r2
  180dac:	880ad07a 	srli	r5,r17,1
  180db0:	400897fa 	slli	r4,r8,31
  180db4:	88c0004c 	andi	r3,r17,1
  180db8:	28e2b03a 	or	r17,r5,r3
  180dbc:	4010d07a 	srli	r8,r8,1
  180dc0:	2462b03a 	or	r17,r4,r17
  180dc4:	003f7106 	br	180b8c <__adddf3+0x7c>
  180dc8:	4088b03a 	or	r4,r8,r2
  180dcc:	20014526 	beq	r4,zero,1812e4 <__adddf3+0x7d4>
  180dd0:	01000434 	movhi	r4,16
  180dd4:	42000234 	orhi	r8,r8,8
  180dd8:	213fffc4 	addi	r4,r4,-1
  180ddc:	4110703a 	and	r8,r8,r4
  180de0:	003f8206 	br	180bec <__adddf3+0xdc>
  180de4:	18ffffc4 	addi	r3,r3,-1
  180de8:	1800491e 	bne	r3,zero,180f10 <__adddf3+0x400>
  180dec:	898bc83a 	sub	r5,r17,r6
  180df0:	8963803a 	cmpltu	r17,r17,r5
  180df4:	4251c83a 	sub	r8,r8,r9
  180df8:	4451c83a 	sub	r8,r8,r17
  180dfc:	2823883a 	mov	r17,r5
  180e00:	003f9f06 	br	180c80 <__adddf3+0x170>
  180e04:	4984b03a 	or	r2,r9,r6
  180e08:	103f6026 	beq	r2,zero,180b8c <__adddf3+0x7c>
  180e0c:	213fffc4 	addi	r4,r4,-1
  180e10:	2000931e 	bne	r4,zero,181060 <__adddf3+0x550>
  180e14:	898d883a 	add	r6,r17,r6
  180e18:	3463803a 	cmpltu	r17,r6,r17
  180e1c:	4251883a 	add	r8,r8,r9
  180e20:	8a11883a 	add	r8,r17,r8
  180e24:	3023883a 	mov	r17,r6
  180e28:	003fd806 	br	180d8c <__adddf3+0x27c>
  180e2c:	1800541e 	bne	r3,zero,180f80 <__adddf3+0x470>
  180e30:	80800044 	addi	r2,r16,1
  180e34:	1081ffcc 	andi	r2,r2,2047
  180e38:	00c00044 	movi	r3,1
  180e3c:	1880a00e 	bge	r3,r2,1810c0 <__adddf3+0x5b0>
  180e40:	8989c83a 	sub	r4,r17,r6
  180e44:	8905803a 	cmpltu	r2,r17,r4
  180e48:	4267c83a 	sub	r19,r8,r9
  180e4c:	98a7c83a 	sub	r19,r19,r2
  180e50:	9880202c 	andhi	r2,r19,128
  180e54:	10006326 	beq	r2,zero,180fe4 <__adddf3+0x4d4>
  180e58:	3463c83a 	sub	r17,r6,r17
  180e5c:	4a07c83a 	sub	r3,r9,r8
  180e60:	344d803a 	cmpltu	r6,r6,r17
  180e64:	19a7c83a 	sub	r19,r3,r6
  180e68:	3825883a 	mov	r18,r7
  180e6c:	983f8a1e 	bne	r19,zero,180c98 <__adddf3+0x188>
  180e70:	8809883a 	mov	r4,r17
  180e74:	0181d840 	call	181d84 <__clzsi2>
  180e78:	10800804 	addi	r2,r2,32
  180e7c:	10fffe04 	addi	r3,r2,-8
  180e80:	010007c4 	movi	r4,31
  180e84:	20ff890e 	bge	r4,r3,180cac <__adddf3+0x19c>
  180e88:	10bff604 	addi	r2,r2,-40
  180e8c:	8884983a 	sll	r2,r17,r2
  180e90:	0023883a 	mov	r17,zero
  180e94:	1c3f8c0e 	bge	r3,r16,180cc8 <__adddf3+0x1b8>
  180e98:	023fe034 	movhi	r8,65408
  180e9c:	423fffc4 	addi	r8,r8,-1
  180ea0:	80e1c83a 	sub	r16,r16,r3
  180ea4:	1210703a 	and	r8,r2,r8
  180ea8:	003f3806 	br	180b8c <__adddf3+0x7c>
  180eac:	9007883a 	mov	r3,r18
  180eb0:	0011883a 	mov	r8,zero
  180eb4:	0005883a 	mov	r2,zero
  180eb8:	003f4c06 	br	180bec <__adddf3+0xdc>
  180ebc:	498cb03a 	or	r6,r9,r6
  180ec0:	300cc03a 	cmpne	r6,r6,zero
  180ec4:	0007883a 	mov	r3,zero
  180ec8:	003f6806 	br	180c6c <__adddf3+0x15c>
  180ecc:	20009c1e 	bne	r4,zero,181140 <__adddf3+0x630>
  180ed0:	80800044 	addi	r2,r16,1
  180ed4:	1141ffcc 	andi	r5,r2,2047
  180ed8:	01000044 	movi	r4,1
  180edc:	2140670e 	bge	r4,r5,18107c <__adddf3+0x56c>
  180ee0:	0101ffc4 	movi	r4,2047
  180ee4:	11007f26 	beq	r2,r4,1810e4 <__adddf3+0x5d4>
  180ee8:	898d883a 	add	r6,r17,r6
  180eec:	4247883a 	add	r3,r8,r9
  180ef0:	3451803a 	cmpltu	r8,r6,r17
  180ef4:	40d1883a 	add	r8,r8,r3
  180ef8:	402297fa 	slli	r17,r8,31
  180efc:	300cd07a 	srli	r6,r6,1
  180f00:	4010d07a 	srli	r8,r8,1
  180f04:	1021883a 	mov	r16,r2
  180f08:	89a2b03a 	or	r17,r17,r6
  180f0c:	003f1f06 	br	180b8c <__adddf3+0x7c>
  180f10:	0081ffc4 	movi	r2,2047
  180f14:	80bf481e 	bne	r16,r2,180c38 <__adddf3+0x128>
  180f18:	003f1c06 	br	180b8c <__adddf3+0x7c>
  180f1c:	843ff844 	addi	r16,r16,-31
  180f20:	01000804 	movi	r4,32
  180f24:	1406d83a 	srl	r3,r2,r16
  180f28:	41005026 	beq	r8,r4,18106c <__adddf3+0x55c>
  180f2c:	01001004 	movi	r4,64
  180f30:	2211c83a 	sub	r8,r4,r8
  180f34:	1204983a 	sll	r2,r2,r8
  180f38:	88a2b03a 	or	r17,r17,r2
  180f3c:	8822c03a 	cmpne	r17,r17,zero
  180f40:	1c62b03a 	or	r17,r3,r17
  180f44:	0011883a 	mov	r8,zero
  180f48:	0021883a 	mov	r16,zero
  180f4c:	003f7106 	br	180d14 <__adddf3+0x204>
  180f50:	193ff804 	addi	r4,r3,-32
  180f54:	00800804 	movi	r2,32
  180f58:	4908d83a 	srl	r4,r9,r4
  180f5c:	18804526 	beq	r3,r2,181074 <__adddf3+0x564>
  180f60:	00801004 	movi	r2,64
  180f64:	10c5c83a 	sub	r2,r2,r3
  180f68:	4886983a 	sll	r3,r9,r2
  180f6c:	198cb03a 	or	r6,r3,r6
  180f70:	300cc03a 	cmpne	r6,r6,zero
  180f74:	218cb03a 	or	r6,r4,r6
  180f78:	0007883a 	mov	r3,zero
  180f7c:	003f3b06 	br	180c6c <__adddf3+0x15c>
  180f80:	80002a26 	beq	r16,zero,18102c <__adddf3+0x51c>
  180f84:	0101ffc4 	movi	r4,2047
  180f88:	11006826 	beq	r2,r4,18112c <__adddf3+0x61c>
  180f8c:	00c7c83a 	sub	r3,zero,r3
  180f90:	42002034 	orhi	r8,r8,128
  180f94:	01000e04 	movi	r4,56
  180f98:	20c07c16 	blt	r4,r3,18118c <__adddf3+0x67c>
  180f9c:	010007c4 	movi	r4,31
  180fa0:	20c0da16 	blt	r4,r3,18130c <__adddf3+0x7fc>
  180fa4:	01000804 	movi	r4,32
  180fa8:	20c9c83a 	sub	r4,r4,r3
  180fac:	4114983a 	sll	r10,r8,r4
  180fb0:	88cad83a 	srl	r5,r17,r3
  180fb4:	8908983a 	sll	r4,r17,r4
  180fb8:	40c6d83a 	srl	r3,r8,r3
  180fbc:	5162b03a 	or	r17,r10,r5
  180fc0:	2008c03a 	cmpne	r4,r4,zero
  180fc4:	8922b03a 	or	r17,r17,r4
  180fc8:	3463c83a 	sub	r17,r6,r17
  180fcc:	48c7c83a 	sub	r3,r9,r3
  180fd0:	344d803a 	cmpltu	r6,r6,r17
  180fd4:	1991c83a 	sub	r8,r3,r6
  180fd8:	1021883a 	mov	r16,r2
  180fdc:	3825883a 	mov	r18,r7
  180fe0:	003f2706 	br	180c80 <__adddf3+0x170>
  180fe4:	24d0b03a 	or	r8,r4,r19
  180fe8:	40001b1e 	bne	r8,zero,181058 <__adddf3+0x548>
  180fec:	0005883a 	mov	r2,zero
  180ff0:	0007883a 	mov	r3,zero
  180ff4:	0021883a 	mov	r16,zero
  180ff8:	003f4d06 	br	180d30 <__adddf3+0x220>
  180ffc:	008007c4 	movi	r2,31
  181000:	11003c16 	blt	r2,r4,1810f4 <__adddf3+0x5e4>
  181004:	00800804 	movi	r2,32
  181008:	1105c83a 	sub	r2,r2,r4
  18100c:	488e983a 	sll	r7,r9,r2
  181010:	310ad83a 	srl	r5,r6,r4
  181014:	3084983a 	sll	r2,r6,r2
  181018:	4912d83a 	srl	r9,r9,r4
  18101c:	394ab03a 	or	r5,r7,r5
  181020:	1004c03a 	cmpne	r2,r2,zero
  181024:	288ab03a 	or	r5,r5,r2
  181028:	003f5306 	br	180d78 <__adddf3+0x268>
  18102c:	4448b03a 	or	r4,r8,r17
  181030:	20003e26 	beq	r4,zero,18112c <__adddf3+0x61c>
  181034:	00c6303a 	nor	r3,zero,r3
  181038:	18003a1e 	bne	r3,zero,181124 <__adddf3+0x614>
  18103c:	3463c83a 	sub	r17,r6,r17
  181040:	4a07c83a 	sub	r3,r9,r8
  181044:	344d803a 	cmpltu	r6,r6,r17
  181048:	1991c83a 	sub	r8,r3,r6
  18104c:	1021883a 	mov	r16,r2
  181050:	3825883a 	mov	r18,r7
  181054:	003f0a06 	br	180c80 <__adddf3+0x170>
  181058:	2023883a 	mov	r17,r4
  18105c:	003f0d06 	br	180c94 <__adddf3+0x184>
  181060:	0081ffc4 	movi	r2,2047
  181064:	80bf3f1e 	bne	r16,r2,180d64 <__adddf3+0x254>
  181068:	003ec806 	br	180b8c <__adddf3+0x7c>
  18106c:	0005883a 	mov	r2,zero
  181070:	003fb106 	br	180f38 <__adddf3+0x428>
  181074:	0007883a 	mov	r3,zero
  181078:	003fbc06 	br	180f6c <__adddf3+0x45c>
  18107c:	4444b03a 	or	r2,r8,r17
  181080:	8000871e 	bne	r16,zero,1812a0 <__adddf3+0x790>
  181084:	1000ba26 	beq	r2,zero,181370 <__adddf3+0x860>
  181088:	4984b03a 	or	r2,r9,r6
  18108c:	103ebf26 	beq	r2,zero,180b8c <__adddf3+0x7c>
  181090:	8985883a 	add	r2,r17,r6
  181094:	4247883a 	add	r3,r8,r9
  181098:	1451803a 	cmpltu	r8,r2,r17
  18109c:	40d1883a 	add	r8,r8,r3
  1810a0:	40c0202c 	andhi	r3,r8,128
  1810a4:	1023883a 	mov	r17,r2
  1810a8:	183f1a26 	beq	r3,zero,180d14 <__adddf3+0x204>
  1810ac:	00bfe034 	movhi	r2,65408
  1810b0:	10bfffc4 	addi	r2,r2,-1
  1810b4:	2021883a 	mov	r16,r4
  1810b8:	4090703a 	and	r8,r8,r2
  1810bc:	003eb306 	br	180b8c <__adddf3+0x7c>
  1810c0:	4444b03a 	or	r2,r8,r17
  1810c4:	8000291e 	bne	r16,zero,18116c <__adddf3+0x65c>
  1810c8:	10004b1e 	bne	r2,zero,1811f8 <__adddf3+0x6e8>
  1810cc:	4990b03a 	or	r8,r9,r6
  1810d0:	40008b26 	beq	r8,zero,181300 <__adddf3+0x7f0>
  1810d4:	4811883a 	mov	r8,r9
  1810d8:	3023883a 	mov	r17,r6
  1810dc:	3825883a 	mov	r18,r7
  1810e0:	003eaa06 	br	180b8c <__adddf3+0x7c>
  1810e4:	1021883a 	mov	r16,r2
  1810e8:	0011883a 	mov	r8,zero
  1810ec:	0005883a 	mov	r2,zero
  1810f0:	003f0f06 	br	180d30 <__adddf3+0x220>
  1810f4:	217ff804 	addi	r5,r4,-32
  1810f8:	00800804 	movi	r2,32
  1810fc:	494ad83a 	srl	r5,r9,r5
  181100:	20807d26 	beq	r4,r2,1812f8 <__adddf3+0x7e8>
  181104:	00801004 	movi	r2,64
  181108:	1109c83a 	sub	r4,r2,r4
  18110c:	4912983a 	sll	r9,r9,r4
  181110:	498cb03a 	or	r6,r9,r6
  181114:	300cc03a 	cmpne	r6,r6,zero
  181118:	298ab03a 	or	r5,r5,r6
  18111c:	0013883a 	mov	r9,zero
  181120:	003f1506 	br	180d78 <__adddf3+0x268>
  181124:	0101ffc4 	movi	r4,2047
  181128:	113f9a1e 	bne	r2,r4,180f94 <__adddf3+0x484>
  18112c:	4811883a 	mov	r8,r9
  181130:	3023883a 	mov	r17,r6
  181134:	1021883a 	mov	r16,r2
  181138:	3825883a 	mov	r18,r7
  18113c:	003e9306 	br	180b8c <__adddf3+0x7c>
  181140:	8000161e 	bne	r16,zero,18119c <__adddf3+0x68c>
  181144:	444ab03a 	or	r5,r8,r17
  181148:	28005126 	beq	r5,zero,181290 <__adddf3+0x780>
  18114c:	0108303a 	nor	r4,zero,r4
  181150:	20004d1e 	bne	r4,zero,181288 <__adddf3+0x778>
  181154:	89a3883a 	add	r17,r17,r6
  181158:	4253883a 	add	r9,r8,r9
  18115c:	898d803a 	cmpltu	r6,r17,r6
  181160:	3251883a 	add	r8,r6,r9
  181164:	1021883a 	mov	r16,r2
  181168:	003f0806 	br	180d8c <__adddf3+0x27c>
  18116c:	1000301e 	bne	r2,zero,181230 <__adddf3+0x720>
  181170:	4984b03a 	or	r2,r9,r6
  181174:	10007126 	beq	r2,zero,18133c <__adddf3+0x82c>
  181178:	4811883a 	mov	r8,r9
  18117c:	3023883a 	mov	r17,r6
  181180:	3825883a 	mov	r18,r7
  181184:	0401ffc4 	movi	r16,2047
  181188:	003e8006 	br	180b8c <__adddf3+0x7c>
  18118c:	4462b03a 	or	r17,r8,r17
  181190:	8822c03a 	cmpne	r17,r17,zero
  181194:	0007883a 	mov	r3,zero
  181198:	003f8b06 	br	180fc8 <__adddf3+0x4b8>
  18119c:	0141ffc4 	movi	r5,2047
  1811a0:	11403b26 	beq	r2,r5,181290 <__adddf3+0x780>
  1811a4:	0109c83a 	sub	r4,zero,r4
  1811a8:	42002034 	orhi	r8,r8,128
  1811ac:	01400e04 	movi	r5,56
  1811b0:	29006716 	blt	r5,r4,181350 <__adddf3+0x840>
  1811b4:	014007c4 	movi	r5,31
  1811b8:	29007016 	blt	r5,r4,18137c <__adddf3+0x86c>
  1811bc:	01400804 	movi	r5,32
  1811c0:	290bc83a 	sub	r5,r5,r4
  1811c4:	4154983a 	sll	r10,r8,r5
  1811c8:	890ed83a 	srl	r7,r17,r4
  1811cc:	894a983a 	sll	r5,r17,r5
  1811d0:	4108d83a 	srl	r4,r8,r4
  1811d4:	51e2b03a 	or	r17,r10,r7
  1811d8:	280ac03a 	cmpne	r5,r5,zero
  1811dc:	8962b03a 	or	r17,r17,r5
  1811e0:	89a3883a 	add	r17,r17,r6
  1811e4:	2253883a 	add	r9,r4,r9
  1811e8:	898d803a 	cmpltu	r6,r17,r6
  1811ec:	3251883a 	add	r8,r6,r9
  1811f0:	1021883a 	mov	r16,r2
  1811f4:	003ee506 	br	180d8c <__adddf3+0x27c>
  1811f8:	4984b03a 	or	r2,r9,r6
  1811fc:	103e6326 	beq	r2,zero,180b8c <__adddf3+0x7c>
  181200:	8987c83a 	sub	r3,r17,r6
  181204:	88c9803a 	cmpltu	r4,r17,r3
  181208:	4245c83a 	sub	r2,r8,r9
  18120c:	1105c83a 	sub	r2,r2,r4
  181210:	1100202c 	andhi	r4,r2,128
  181214:	203ebb26 	beq	r4,zero,180d04 <__adddf3+0x1f4>
  181218:	3463c83a 	sub	r17,r6,r17
  18121c:	4a07c83a 	sub	r3,r9,r8
  181220:	344d803a 	cmpltu	r6,r6,r17
  181224:	1991c83a 	sub	r8,r3,r6
  181228:	3825883a 	mov	r18,r7
  18122c:	003e5706 	br	180b8c <__adddf3+0x7c>
  181230:	4984b03a 	or	r2,r9,r6
  181234:	10002e26 	beq	r2,zero,1812f0 <__adddf3+0x7e0>
  181238:	4004d0fa 	srli	r2,r8,3
  18123c:	8822d0fa 	srli	r17,r17,3
  181240:	4010977a 	slli	r8,r8,29
  181244:	10c0022c 	andhi	r3,r2,8
  181248:	4462b03a 	or	r17,r8,r17
  18124c:	18000826 	beq	r3,zero,181270 <__adddf3+0x760>
  181250:	4808d0fa 	srli	r4,r9,3
  181254:	20c0022c 	andhi	r3,r4,8
  181258:	1800051e 	bne	r3,zero,181270 <__adddf3+0x760>
  18125c:	300cd0fa 	srli	r6,r6,3
  181260:	4806977a 	slli	r3,r9,29
  181264:	2005883a 	mov	r2,r4
  181268:	3825883a 	mov	r18,r7
  18126c:	19a2b03a 	or	r17,r3,r6
  181270:	8810d77a 	srli	r8,r17,29
  181274:	100490fa 	slli	r2,r2,3
  181278:	882290fa 	slli	r17,r17,3
  18127c:	0401ffc4 	movi	r16,2047
  181280:	4090b03a 	or	r8,r8,r2
  181284:	003e4106 	br	180b8c <__adddf3+0x7c>
  181288:	0141ffc4 	movi	r5,2047
  18128c:	117fc71e 	bne	r2,r5,1811ac <__adddf3+0x69c>
  181290:	4811883a 	mov	r8,r9
  181294:	3023883a 	mov	r17,r6
  181298:	1021883a 	mov	r16,r2
  18129c:	003e3b06 	br	180b8c <__adddf3+0x7c>
  1812a0:	10002f26 	beq	r2,zero,181360 <__adddf3+0x850>
  1812a4:	4984b03a 	or	r2,r9,r6
  1812a8:	10001126 	beq	r2,zero,1812f0 <__adddf3+0x7e0>
  1812ac:	4004d0fa 	srli	r2,r8,3
  1812b0:	8822d0fa 	srli	r17,r17,3
  1812b4:	4010977a 	slli	r8,r8,29
  1812b8:	10c0022c 	andhi	r3,r2,8
  1812bc:	4462b03a 	or	r17,r8,r17
  1812c0:	183feb26 	beq	r3,zero,181270 <__adddf3+0x760>
  1812c4:	4808d0fa 	srli	r4,r9,3
  1812c8:	20c0022c 	andhi	r3,r4,8
  1812cc:	183fe81e 	bne	r3,zero,181270 <__adddf3+0x760>
  1812d0:	300cd0fa 	srli	r6,r6,3
  1812d4:	4806977a 	slli	r3,r9,29
  1812d8:	2005883a 	mov	r2,r4
  1812dc:	19a2b03a 	or	r17,r3,r6
  1812e0:	003fe306 	br	181270 <__adddf3+0x760>
  1812e4:	0011883a 	mov	r8,zero
  1812e8:	0005883a 	mov	r2,zero
  1812ec:	003e3f06 	br	180bec <__adddf3+0xdc>
  1812f0:	0401ffc4 	movi	r16,2047
  1812f4:	003e2506 	br	180b8c <__adddf3+0x7c>
  1812f8:	0013883a 	mov	r9,zero
  1812fc:	003f8406 	br	181110 <__adddf3+0x600>
  181300:	0005883a 	mov	r2,zero
  181304:	0007883a 	mov	r3,zero
  181308:	003e8906 	br	180d30 <__adddf3+0x220>
  18130c:	197ff804 	addi	r5,r3,-32
  181310:	01000804 	movi	r4,32
  181314:	414ad83a 	srl	r5,r8,r5
  181318:	19002426 	beq	r3,r4,1813ac <__adddf3+0x89c>
  18131c:	01001004 	movi	r4,64
  181320:	20c7c83a 	sub	r3,r4,r3
  181324:	40c6983a 	sll	r3,r8,r3
  181328:	1c46b03a 	or	r3,r3,r17
  18132c:	1806c03a 	cmpne	r3,r3,zero
  181330:	28e2b03a 	or	r17,r5,r3
  181334:	0007883a 	mov	r3,zero
  181338:	003f2306 	br	180fc8 <__adddf3+0x4b8>
  18133c:	0007883a 	mov	r3,zero
  181340:	5811883a 	mov	r8,r11
  181344:	00bfffc4 	movi	r2,-1
  181348:	0401ffc4 	movi	r16,2047
  18134c:	003e7806 	br	180d30 <__adddf3+0x220>
  181350:	4462b03a 	or	r17,r8,r17
  181354:	8822c03a 	cmpne	r17,r17,zero
  181358:	0009883a 	mov	r4,zero
  18135c:	003fa006 	br	1811e0 <__adddf3+0x6d0>
  181360:	4811883a 	mov	r8,r9
  181364:	3023883a 	mov	r17,r6
  181368:	0401ffc4 	movi	r16,2047
  18136c:	003e0706 	br	180b8c <__adddf3+0x7c>
  181370:	4811883a 	mov	r8,r9
  181374:	3023883a 	mov	r17,r6
  181378:	003e0406 	br	180b8c <__adddf3+0x7c>
  18137c:	21fff804 	addi	r7,r4,-32
  181380:	01400804 	movi	r5,32
  181384:	41ced83a 	srl	r7,r8,r7
  181388:	21400a26 	beq	r4,r5,1813b4 <__adddf3+0x8a4>
  18138c:	01401004 	movi	r5,64
  181390:	2909c83a 	sub	r4,r5,r4
  181394:	4108983a 	sll	r4,r8,r4
  181398:	2448b03a 	or	r4,r4,r17
  18139c:	2008c03a 	cmpne	r4,r4,zero
  1813a0:	3922b03a 	or	r17,r7,r4
  1813a4:	0009883a 	mov	r4,zero
  1813a8:	003f8d06 	br	1811e0 <__adddf3+0x6d0>
  1813ac:	0007883a 	mov	r3,zero
  1813b0:	003fdd06 	br	181328 <__adddf3+0x818>
  1813b4:	0009883a 	mov	r4,zero
  1813b8:	003ff706 	br	181398 <__adddf3+0x888>

001813bc <__muldf3>:
  1813bc:	deffee04 	addi	sp,sp,-72
  1813c0:	dd000c15 	stw	r20,48(sp)
  1813c4:	2828d53a 	srli	r20,r5,20
  1813c8:	ddc00f15 	stw	r23,60(sp)
  1813cc:	282ed7fa 	srli	r23,r5,31
  1813d0:	dc000815 	stw	r16,32(sp)
  1813d4:	04000434 	movhi	r16,16
  1813d8:	dcc00b15 	stw	r19,44(sp)
  1813dc:	843fffc4 	addi	r16,r16,-1
  1813e0:	dfc01115 	stw	ra,68(sp)
  1813e4:	df001015 	stw	fp,64(sp)
  1813e8:	dd800e15 	stw	r22,56(sp)
  1813ec:	dd400d15 	stw	r21,52(sp)
  1813f0:	dc800a15 	stw	r18,40(sp)
  1813f4:	dc400915 	stw	r17,36(sp)
  1813f8:	a501ffcc 	andi	r20,r20,2047
  1813fc:	2c20703a 	and	r16,r5,r16
  181400:	b827883a 	mov	r19,r23
  181404:	ba403fcc 	andi	r9,r23,255
  181408:	a0006026 	beq	r20,zero,18158c <__muldf3+0x1d0>
  18140c:	0081ffc4 	movi	r2,2047
  181410:	202d883a 	mov	r22,r4
  181414:	a0803626 	beq	r20,r2,1814f0 <__muldf3+0x134>
  181418:	84000434 	orhi	r16,r16,16
  18141c:	200ad77a 	srli	r5,r4,29
  181420:	800490fa 	slli	r2,r16,3
  181424:	202c90fa 	slli	r22,r4,3
  181428:	a53f0044 	addi	r20,r20,-1023
  18142c:	28a0b03a 	or	r16,r5,r2
  181430:	002b883a 	mov	r21,zero
  181434:	000b883a 	mov	r5,zero
  181438:	3804d53a 	srli	r2,r7,20
  18143c:	3838d7fa 	srli	fp,r7,31
  181440:	04400434 	movhi	r17,16
  181444:	8c7fffc4 	addi	r17,r17,-1
  181448:	1081ffcc 	andi	r2,r2,2047
  18144c:	3025883a 	mov	r18,r6
  181450:	3c62703a 	and	r17,r7,r17
  181454:	e2803fcc 	andi	r10,fp,255
  181458:	10006d26 	beq	r2,zero,181610 <__muldf3+0x254>
  18145c:	00c1ffc4 	movi	r3,2047
  181460:	10c06526 	beq	r2,r3,1815f8 <__muldf3+0x23c>
  181464:	8c400434 	orhi	r17,r17,16
  181468:	300ed77a 	srli	r7,r6,29
  18146c:	880690fa 	slli	r3,r17,3
  181470:	302490fa 	slli	r18,r6,3
  181474:	10bf0044 	addi	r2,r2,-1023
  181478:	38e2b03a 	or	r17,r7,r3
  18147c:	000f883a 	mov	r7,zero
  181480:	a087883a 	add	r3,r20,r2
  181484:	010003c4 	movi	r4,15
  181488:	3d44b03a 	or	r2,r7,r21
  18148c:	e5ccf03a 	xor	r6,fp,r23
  181490:	1a000044 	addi	r8,r3,1
  181494:	20809b36 	bltu	r4,r2,181704 <__muldf3+0x348>
  181498:	100490ba 	slli	r2,r2,2
  18149c:	01000634 	movhi	r4,24
  1814a0:	21052c04 	addi	r4,r4,5296
  1814a4:	1105883a 	add	r2,r2,r4
  1814a8:	10800017 	ldw	r2,0(r2)
  1814ac:	1000683a 	jmp	r2
  1814b0:	00181704 	movi	zero,24668
  1814b4:	00181510 	cmplti	zero,zero,24660
  1814b8:	00181510 	cmplti	zero,zero,24660
  1814bc:	0018150c 	andi	zero,zero,24660
  1814c0:	001816e0 	cmpeqi	zero,zero,24667
  1814c4:	001816e0 	cmpeqi	zero,zero,24667
  1814c8:	001816c8 	cmpgei	zero,zero,24667
  1814cc:	0018150c 	andi	zero,zero,24660
  1814d0:	001816e0 	cmpeqi	zero,zero,24667
  1814d4:	001816c8 	cmpgei	zero,zero,24667
  1814d8:	001816e0 	cmpeqi	zero,zero,24667
  1814dc:	0018150c 	andi	zero,zero,24660
  1814e0:	001816f0 	cmpltui	zero,zero,24667
  1814e4:	001816f0 	cmpltui	zero,zero,24667
  1814e8:	001816f0 	cmpltui	zero,zero,24667
  1814ec:	00181a50 	cmplti	zero,zero,24681
  1814f0:	2404b03a 	or	r2,r4,r16
  1814f4:	1000711e 	bne	r2,zero,1816bc <__muldf3+0x300>
  1814f8:	05400204 	movi	r21,8
  1814fc:	0021883a 	mov	r16,zero
  181500:	002d883a 	mov	r22,zero
  181504:	01400084 	movi	r5,2
  181508:	003fcb06 	br	181438 <__muldf3+0x7c>
  18150c:	500d883a 	mov	r6,r10
  181510:	00800084 	movi	r2,2
  181514:	38805926 	beq	r7,r2,18167c <__muldf3+0x2c0>
  181518:	008000c4 	movi	r2,3
  18151c:	3881bb26 	beq	r7,r2,181c0c <__muldf3+0x850>
  181520:	00800044 	movi	r2,1
  181524:	3881961e 	bne	r7,r2,181b80 <__muldf3+0x7c4>
  181528:	3027883a 	mov	r19,r6
  18152c:	0005883a 	mov	r2,zero
  181530:	0021883a 	mov	r16,zero
  181534:	002d883a 	mov	r22,zero
  181538:	1004953a 	slli	r2,r2,20
  18153c:	98c03fcc 	andi	r3,r19,255
  181540:	04400434 	movhi	r17,16
  181544:	8c7fffc4 	addi	r17,r17,-1
  181548:	180697fa 	slli	r3,r3,31
  18154c:	8460703a 	and	r16,r16,r17
  181550:	80a0b03a 	or	r16,r16,r2
  181554:	80c6b03a 	or	r3,r16,r3
  181558:	b005883a 	mov	r2,r22
  18155c:	dfc01117 	ldw	ra,68(sp)
  181560:	df001017 	ldw	fp,64(sp)
  181564:	ddc00f17 	ldw	r23,60(sp)
  181568:	dd800e17 	ldw	r22,56(sp)
  18156c:	dd400d17 	ldw	r21,52(sp)
  181570:	dd000c17 	ldw	r20,48(sp)
  181574:	dcc00b17 	ldw	r19,44(sp)
  181578:	dc800a17 	ldw	r18,40(sp)
  18157c:	dc400917 	ldw	r17,36(sp)
  181580:	dc000817 	ldw	r16,32(sp)
  181584:	dec01204 	addi	sp,sp,72
  181588:	f800283a 	ret
  18158c:	2404b03a 	or	r2,r4,r16
  181590:	202b883a 	mov	r21,r4
  181594:	10004426 	beq	r2,zero,1816a8 <__muldf3+0x2ec>
  181598:	80015126 	beq	r16,zero,181ae0 <__muldf3+0x724>
  18159c:	8009883a 	mov	r4,r16
  1815a0:	d9800715 	stw	r6,28(sp)
  1815a4:	d9c00215 	stw	r7,8(sp)
  1815a8:	da400415 	stw	r9,16(sp)
  1815ac:	0181d840 	call	181d84 <__clzsi2>
  1815b0:	d9800717 	ldw	r6,28(sp)
  1815b4:	d9c00217 	ldw	r7,8(sp)
  1815b8:	da400417 	ldw	r9,16(sp)
  1815bc:	113ffd44 	addi	r4,r2,-11
  1815c0:	00c00704 	movi	r3,28
  1815c4:	19014216 	blt	r3,r4,181ad0 <__muldf3+0x714>
  1815c8:	00c00744 	movi	r3,29
  1815cc:	15bffe04 	addi	r22,r2,-8
  1815d0:	1907c83a 	sub	r3,r3,r4
  1815d4:	85a0983a 	sll	r16,r16,r22
  1815d8:	a8c6d83a 	srl	r3,r21,r3
  1815dc:	adac983a 	sll	r22,r21,r22
  1815e0:	1c20b03a 	or	r16,r3,r16
  1815e4:	1080fcc4 	addi	r2,r2,1011
  1815e8:	00a9c83a 	sub	r20,zero,r2
  1815ec:	002b883a 	mov	r21,zero
  1815f0:	000b883a 	mov	r5,zero
  1815f4:	003f9006 	br	181438 <__muldf3+0x7c>
  1815f8:	3446b03a 	or	r3,r6,r17
  1815fc:	1800281e 	bne	r3,zero,1816a0 <__muldf3+0x2e4>
  181600:	0023883a 	mov	r17,zero
  181604:	0025883a 	mov	r18,zero
  181608:	01c00084 	movi	r7,2
  18160c:	003f9c06 	br	181480 <__muldf3+0xc4>
  181610:	3446b03a 	or	r3,r6,r17
  181614:	18001e26 	beq	r3,zero,181690 <__muldf3+0x2d4>
  181618:	88012126 	beq	r17,zero,181aa0 <__muldf3+0x6e4>
  18161c:	8809883a 	mov	r4,r17
  181620:	d9400215 	stw	r5,8(sp)
  181624:	d9800715 	stw	r6,28(sp)
  181628:	da400415 	stw	r9,16(sp)
  18162c:	da800315 	stw	r10,12(sp)
  181630:	0181d840 	call	181d84 <__clzsi2>
  181634:	d9400217 	ldw	r5,8(sp)
  181638:	d9800717 	ldw	r6,28(sp)
  18163c:	da400417 	ldw	r9,16(sp)
  181640:	da800317 	ldw	r10,12(sp)
  181644:	113ffd44 	addi	r4,r2,-11
  181648:	00c00704 	movi	r3,28
  18164c:	19011016 	blt	r3,r4,181a90 <__muldf3+0x6d4>
  181650:	00c00744 	movi	r3,29
  181654:	14bffe04 	addi	r18,r2,-8
  181658:	1907c83a 	sub	r3,r3,r4
  18165c:	8ca2983a 	sll	r17,r17,r18
  181660:	30c6d83a 	srl	r3,r6,r3
  181664:	34a4983a 	sll	r18,r6,r18
  181668:	1c62b03a 	or	r17,r3,r17
  18166c:	1080fcc4 	addi	r2,r2,1011
  181670:	0085c83a 	sub	r2,zero,r2
  181674:	000f883a 	mov	r7,zero
  181678:	003f8106 	br	181480 <__muldf3+0xc4>
  18167c:	3027883a 	mov	r19,r6
  181680:	0081ffc4 	movi	r2,2047
  181684:	0021883a 	mov	r16,zero
  181688:	002d883a 	mov	r22,zero
  18168c:	003faa06 	br	181538 <__muldf3+0x17c>
  181690:	0023883a 	mov	r17,zero
  181694:	0025883a 	mov	r18,zero
  181698:	01c00044 	movi	r7,1
  18169c:	003f7806 	br	181480 <__muldf3+0xc4>
  1816a0:	01c000c4 	movi	r7,3
  1816a4:	003f7606 	br	181480 <__muldf3+0xc4>
  1816a8:	05400104 	movi	r21,4
  1816ac:	0021883a 	mov	r16,zero
  1816b0:	002d883a 	mov	r22,zero
  1816b4:	01400044 	movi	r5,1
  1816b8:	003f5f06 	br	181438 <__muldf3+0x7c>
  1816bc:	05400304 	movi	r21,12
  1816c0:	014000c4 	movi	r5,3
  1816c4:	003f5c06 	br	181438 <__muldf3+0x7c>
  1816c8:	04000434 	movhi	r16,16
  1816cc:	0027883a 	mov	r19,zero
  1816d0:	843fffc4 	addi	r16,r16,-1
  1816d4:	05bfffc4 	movi	r22,-1
  1816d8:	0081ffc4 	movi	r2,2047
  1816dc:	003f9606 	br	181538 <__muldf3+0x17c>
  1816e0:	8023883a 	mov	r17,r16
  1816e4:	b025883a 	mov	r18,r22
  1816e8:	280f883a 	mov	r7,r5
  1816ec:	003f8806 	br	181510 <__muldf3+0x154>
  1816f0:	8023883a 	mov	r17,r16
  1816f4:	b025883a 	mov	r18,r22
  1816f8:	480d883a 	mov	r6,r9
  1816fc:	280f883a 	mov	r7,r5
  181700:	003f8306 	br	181510 <__muldf3+0x154>
  181704:	b026d43a 	srli	r19,r22,16
  181708:	902ed43a 	srli	r23,r18,16
  18170c:	b5bfffcc 	andi	r22,r22,65535
  181710:	94bfffcc 	andi	r18,r18,65535
  181714:	b00b883a 	mov	r5,r22
  181718:	9009883a 	mov	r4,r18
  18171c:	d8c00515 	stw	r3,20(sp)
  181720:	d9800715 	stw	r6,28(sp)
  181724:	da000615 	stw	r8,24(sp)
  181728:	0181de80 	call	181de8 <__mulsi3>
  18172c:	980b883a 	mov	r5,r19
  181730:	9009883a 	mov	r4,r18
  181734:	1029883a 	mov	r20,r2
  181738:	0181de80 	call	181de8 <__mulsi3>
  18173c:	b80b883a 	mov	r5,r23
  181740:	9809883a 	mov	r4,r19
  181744:	102b883a 	mov	r21,r2
  181748:	0181de80 	call	181de8 <__mulsi3>
  18174c:	b809883a 	mov	r4,r23
  181750:	b00b883a 	mov	r5,r22
  181754:	1039883a 	mov	fp,r2
  181758:	0181de80 	call	181de8 <__mulsi3>
  18175c:	a008d43a 	srli	r4,r20,16
  181760:	1545883a 	add	r2,r2,r21
  181764:	d8c00517 	ldw	r3,20(sp)
  181768:	2085883a 	add	r2,r4,r2
  18176c:	d9800717 	ldw	r6,28(sp)
  181770:	da000617 	ldw	r8,24(sp)
  181774:	1540022e 	bgeu	r2,r21,181780 <__muldf3+0x3c4>
  181778:	01000074 	movhi	r4,1
  18177c:	e139883a 	add	fp,fp,r4
  181780:	100e943a 	slli	r7,r2,16
  181784:	1004d43a 	srli	r2,r2,16
  181788:	882ad43a 	srli	r21,r17,16
  18178c:	a53fffcc 	andi	r20,r20,65535
  181790:	8c7fffcc 	andi	r17,r17,65535
  181794:	3d29883a 	add	r20,r7,r20
  181798:	b00b883a 	mov	r5,r22
  18179c:	8809883a 	mov	r4,r17
  1817a0:	d8c00515 	stw	r3,20(sp)
  1817a4:	d9800715 	stw	r6,28(sp)
  1817a8:	da000615 	stw	r8,24(sp)
  1817ac:	dd000115 	stw	r20,4(sp)
  1817b0:	d8800015 	stw	r2,0(sp)
  1817b4:	0181de80 	call	181de8 <__mulsi3>
  1817b8:	980b883a 	mov	r5,r19
  1817bc:	8809883a 	mov	r4,r17
  1817c0:	d8800215 	stw	r2,8(sp)
  1817c4:	0181de80 	call	181de8 <__mulsi3>
  1817c8:	9809883a 	mov	r4,r19
  1817cc:	a80b883a 	mov	r5,r21
  1817d0:	1029883a 	mov	r20,r2
  1817d4:	0181de80 	call	181de8 <__mulsi3>
  1817d8:	b00b883a 	mov	r5,r22
  1817dc:	a809883a 	mov	r4,r21
  1817e0:	d8800415 	stw	r2,16(sp)
  1817e4:	0181de80 	call	181de8 <__mulsi3>
  1817e8:	d9c00217 	ldw	r7,8(sp)
  1817ec:	1505883a 	add	r2,r2,r20
  1817f0:	d8c00517 	ldw	r3,20(sp)
  1817f4:	3826d43a 	srli	r19,r7,16
  1817f8:	d9800717 	ldw	r6,28(sp)
  1817fc:	da000617 	ldw	r8,24(sp)
  181800:	9885883a 	add	r2,r19,r2
  181804:	da400417 	ldw	r9,16(sp)
  181808:	1500022e 	bgeu	r2,r20,181814 <__muldf3+0x458>
  18180c:	01000074 	movhi	r4,1
  181810:	4913883a 	add	r9,r9,r4
  181814:	1028d43a 	srli	r20,r2,16
  181818:	1004943a 	slli	r2,r2,16
  18181c:	802cd43a 	srli	r22,r16,16
  181820:	843fffcc 	andi	r16,r16,65535
  181824:	3cffffcc 	andi	r19,r7,65535
  181828:	9009883a 	mov	r4,r18
  18182c:	800b883a 	mov	r5,r16
  181830:	a269883a 	add	r20,r20,r9
  181834:	d8c00515 	stw	r3,20(sp)
  181838:	d9800715 	stw	r6,28(sp)
  18183c:	da000615 	stw	r8,24(sp)
  181840:	14e7883a 	add	r19,r2,r19
  181844:	0181de80 	call	181de8 <__mulsi3>
  181848:	9009883a 	mov	r4,r18
  18184c:	b00b883a 	mov	r5,r22
  181850:	d8800315 	stw	r2,12(sp)
  181854:	0181de80 	call	181de8 <__mulsi3>
  181858:	b809883a 	mov	r4,r23
  18185c:	b00b883a 	mov	r5,r22
  181860:	d8800215 	stw	r2,8(sp)
  181864:	0181de80 	call	181de8 <__mulsi3>
  181868:	b80b883a 	mov	r5,r23
  18186c:	8009883a 	mov	r4,r16
  181870:	d8800415 	stw	r2,16(sp)
  181874:	0181de80 	call	181de8 <__mulsi3>
  181878:	da800317 	ldw	r10,12(sp)
  18187c:	d9c00217 	ldw	r7,8(sp)
  181880:	d9000017 	ldw	r4,0(sp)
  181884:	502ed43a 	srli	r23,r10,16
  181888:	11c5883a 	add	r2,r2,r7
  18188c:	24e5883a 	add	r18,r4,r19
  181890:	b885883a 	add	r2,r23,r2
  181894:	d8c00517 	ldw	r3,20(sp)
  181898:	d9800717 	ldw	r6,28(sp)
  18189c:	da000617 	ldw	r8,24(sp)
  1818a0:	da400417 	ldw	r9,16(sp)
  1818a4:	11c0022e 	bgeu	r2,r7,1818b0 <__muldf3+0x4f4>
  1818a8:	01000074 	movhi	r4,1
  1818ac:	4913883a 	add	r9,r9,r4
  1818b0:	100ed43a 	srli	r7,r2,16
  1818b4:	1004943a 	slli	r2,r2,16
  1818b8:	55ffffcc 	andi	r23,r10,65535
  1818bc:	3a53883a 	add	r9,r7,r9
  1818c0:	8809883a 	mov	r4,r17
  1818c4:	800b883a 	mov	r5,r16
  1818c8:	d8c00515 	stw	r3,20(sp)
  1818cc:	d9800715 	stw	r6,28(sp)
  1818d0:	da000615 	stw	r8,24(sp)
  1818d4:	da400415 	stw	r9,16(sp)
  1818d8:	15ef883a 	add	r23,r2,r23
  1818dc:	0181de80 	call	181de8 <__mulsi3>
  1818e0:	8809883a 	mov	r4,r17
  1818e4:	b00b883a 	mov	r5,r22
  1818e8:	d8800215 	stw	r2,8(sp)
  1818ec:	0181de80 	call	181de8 <__mulsi3>
  1818f0:	b00b883a 	mov	r5,r22
  1818f4:	a809883a 	mov	r4,r21
  1818f8:	d8800315 	stw	r2,12(sp)
  1818fc:	0181de80 	call	181de8 <__mulsi3>
  181900:	8009883a 	mov	r4,r16
  181904:	a80b883a 	mov	r5,r21
  181908:	1023883a 	mov	r17,r2
  18190c:	0181de80 	call	181de8 <__mulsi3>
  181910:	d9c00217 	ldw	r7,8(sp)
  181914:	da800317 	ldw	r10,12(sp)
  181918:	d8c00517 	ldw	r3,20(sp)
  18191c:	3808d43a 	srli	r4,r7,16
  181920:	1285883a 	add	r2,r2,r10
  181924:	d9800717 	ldw	r6,28(sp)
  181928:	2085883a 	add	r2,r4,r2
  18192c:	da000617 	ldw	r8,24(sp)
  181930:	da400417 	ldw	r9,16(sp)
  181934:	1280022e 	bgeu	r2,r10,181940 <__muldf3+0x584>
  181938:	01000074 	movhi	r4,1
  18193c:	8923883a 	add	r17,r17,r4
  181940:	1008943a 	slli	r4,r2,16
  181944:	39ffffcc 	andi	r7,r7,65535
  181948:	e4b9883a 	add	fp,fp,r18
  18194c:	21cf883a 	add	r7,r4,r7
  181950:	e4e7803a 	cmpltu	r19,fp,r19
  181954:	3d0f883a 	add	r7,r7,r20
  181958:	bf39883a 	add	fp,r23,fp
  18195c:	99c9883a 	add	r4,r19,r7
  181960:	e5ef803a 	cmpltu	r23,fp,r23
  181964:	490b883a 	add	r5,r9,r4
  181968:	1004d43a 	srli	r2,r2,16
  18196c:	b965883a 	add	r18,r23,r5
  181970:	24c9803a 	cmpltu	r4,r4,r19
  181974:	3d29803a 	cmpltu	r20,r7,r20
  181978:	a128b03a 	or	r20,r20,r4
  18197c:	95ef803a 	cmpltu	r23,r18,r23
  181980:	2a53803a 	cmpltu	r9,r5,r9
  181984:	a0a9883a 	add	r20,r20,r2
  181988:	4deeb03a 	or	r23,r9,r23
  18198c:	a5ef883a 	add	r23,r20,r23
  181990:	bc63883a 	add	r17,r23,r17
  181994:	e004927a 	slli	r2,fp,9
  181998:	d9000117 	ldw	r4,4(sp)
  18199c:	882e927a 	slli	r23,r17,9
  1819a0:	9022d5fa 	srli	r17,r18,23
  1819a4:	e038d5fa 	srli	fp,fp,23
  1819a8:	1104b03a 	or	r2,r2,r4
  1819ac:	9024927a 	slli	r18,r18,9
  1819b0:	1004c03a 	cmpne	r2,r2,zero
  1819b4:	bc62b03a 	or	r17,r23,r17
  1819b8:	1738b03a 	or	fp,r2,fp
  1819bc:	8880402c 	andhi	r2,r17,256
  1819c0:	e4a4b03a 	or	r18,fp,r18
  1819c4:	10000726 	beq	r2,zero,1819e4 <__muldf3+0x628>
  1819c8:	9006d07a 	srli	r3,r18,1
  1819cc:	880497fa 	slli	r2,r17,31
  1819d0:	9480004c 	andi	r18,r18,1
  1819d4:	8822d07a 	srli	r17,r17,1
  1819d8:	1ca4b03a 	or	r18,r3,r18
  1819dc:	14a4b03a 	or	r18,r2,r18
  1819e0:	4007883a 	mov	r3,r8
  1819e4:	1880ffc4 	addi	r2,r3,1023
  1819e8:	0080460e 	bge	zero,r2,181b04 <__muldf3+0x748>
  1819ec:	910001cc 	andi	r4,r18,7
  1819f0:	20000726 	beq	r4,zero,181a10 <__muldf3+0x654>
  1819f4:	910003cc 	andi	r4,r18,15
  1819f8:	01400104 	movi	r5,4
  1819fc:	21400426 	beq	r4,r5,181a10 <__muldf3+0x654>
  181a00:	9149883a 	add	r4,r18,r5
  181a04:	24a5803a 	cmpltu	r18,r4,r18
  181a08:	8ca3883a 	add	r17,r17,r18
  181a0c:	2025883a 	mov	r18,r4
  181a10:	8900402c 	andhi	r4,r17,256
  181a14:	20000426 	beq	r4,zero,181a28 <__muldf3+0x66c>
  181a18:	18810004 	addi	r2,r3,1024
  181a1c:	00ffc034 	movhi	r3,65280
  181a20:	18ffffc4 	addi	r3,r3,-1
  181a24:	88e2703a 	and	r17,r17,r3
  181a28:	00c1ff84 	movi	r3,2046
  181a2c:	18bf1316 	blt	r3,r2,18167c <__muldf3+0x2c0>
  181a30:	882c977a 	slli	r22,r17,29
  181a34:	9024d0fa 	srli	r18,r18,3
  181a38:	8822927a 	slli	r17,r17,9
  181a3c:	1081ffcc 	andi	r2,r2,2047
  181a40:	b4acb03a 	or	r22,r22,r18
  181a44:	8820d33a 	srli	r16,r17,12
  181a48:	3027883a 	mov	r19,r6
  181a4c:	003eba06 	br	181538 <__muldf3+0x17c>
  181a50:	8080022c 	andhi	r2,r16,8
  181a54:	10000926 	beq	r2,zero,181a7c <__muldf3+0x6c0>
  181a58:	8880022c 	andhi	r2,r17,8
  181a5c:	1000071e 	bne	r2,zero,181a7c <__muldf3+0x6c0>
  181a60:	00800434 	movhi	r2,16
  181a64:	8c000234 	orhi	r16,r17,8
  181a68:	10bfffc4 	addi	r2,r2,-1
  181a6c:	e027883a 	mov	r19,fp
  181a70:	80a0703a 	and	r16,r16,r2
  181a74:	902d883a 	mov	r22,r18
  181a78:	003f1706 	br	1816d8 <__muldf3+0x31c>
  181a7c:	00800434 	movhi	r2,16
  181a80:	84000234 	orhi	r16,r16,8
  181a84:	10bfffc4 	addi	r2,r2,-1
  181a88:	80a0703a 	and	r16,r16,r2
  181a8c:	003f1206 	br	1816d8 <__muldf3+0x31c>
  181a90:	147ff604 	addi	r17,r2,-40
  181a94:	3462983a 	sll	r17,r6,r17
  181a98:	0025883a 	mov	r18,zero
  181a9c:	003ef306 	br	18166c <__muldf3+0x2b0>
  181aa0:	3009883a 	mov	r4,r6
  181aa4:	d9400215 	stw	r5,8(sp)
  181aa8:	d9800715 	stw	r6,28(sp)
  181aac:	da400415 	stw	r9,16(sp)
  181ab0:	da800315 	stw	r10,12(sp)
  181ab4:	0181d840 	call	181d84 <__clzsi2>
  181ab8:	10800804 	addi	r2,r2,32
  181abc:	da800317 	ldw	r10,12(sp)
  181ac0:	da400417 	ldw	r9,16(sp)
  181ac4:	d9800717 	ldw	r6,28(sp)
  181ac8:	d9400217 	ldw	r5,8(sp)
  181acc:	003edd06 	br	181644 <__muldf3+0x288>
  181ad0:	143ff604 	addi	r16,r2,-40
  181ad4:	ac20983a 	sll	r16,r21,r16
  181ad8:	002d883a 	mov	r22,zero
  181adc:	003ec106 	br	1815e4 <__muldf3+0x228>
  181ae0:	d9800715 	stw	r6,28(sp)
  181ae4:	d9c00215 	stw	r7,8(sp)
  181ae8:	da400415 	stw	r9,16(sp)
  181aec:	0181d840 	call	181d84 <__clzsi2>
  181af0:	10800804 	addi	r2,r2,32
  181af4:	da400417 	ldw	r9,16(sp)
  181af8:	d9c00217 	ldw	r7,8(sp)
  181afc:	d9800717 	ldw	r6,28(sp)
  181b00:	003eae06 	br	1815bc <__muldf3+0x200>
  181b04:	00c00044 	movi	r3,1
  181b08:	1887c83a 	sub	r3,r3,r2
  181b0c:	01000e04 	movi	r4,56
  181b10:	20fe8516 	blt	r4,r3,181528 <__muldf3+0x16c>
  181b14:	010007c4 	movi	r4,31
  181b18:	20c01b16 	blt	r4,r3,181b88 <__muldf3+0x7cc>
  181b1c:	00800804 	movi	r2,32
  181b20:	10c5c83a 	sub	r2,r2,r3
  181b24:	888a983a 	sll	r5,r17,r2
  181b28:	90c8d83a 	srl	r4,r18,r3
  181b2c:	9084983a 	sll	r2,r18,r2
  181b30:	88e2d83a 	srl	r17,r17,r3
  181b34:	2906b03a 	or	r3,r5,r4
  181b38:	1004c03a 	cmpne	r2,r2,zero
  181b3c:	1886b03a 	or	r3,r3,r2
  181b40:	188001cc 	andi	r2,r3,7
  181b44:	10000726 	beq	r2,zero,181b64 <__muldf3+0x7a8>
  181b48:	188003cc 	andi	r2,r3,15
  181b4c:	01000104 	movi	r4,4
  181b50:	11000426 	beq	r2,r4,181b64 <__muldf3+0x7a8>
  181b54:	1805883a 	mov	r2,r3
  181b58:	10c00104 	addi	r3,r2,4
  181b5c:	1885803a 	cmpltu	r2,r3,r2
  181b60:	88a3883a 	add	r17,r17,r2
  181b64:	8880202c 	andhi	r2,r17,128
  181b68:	10001c26 	beq	r2,zero,181bdc <__muldf3+0x820>
  181b6c:	3027883a 	mov	r19,r6
  181b70:	00800044 	movi	r2,1
  181b74:	0021883a 	mov	r16,zero
  181b78:	002d883a 	mov	r22,zero
  181b7c:	003e6e06 	br	181538 <__muldf3+0x17c>
  181b80:	4007883a 	mov	r3,r8
  181b84:	003f9706 	br	1819e4 <__muldf3+0x628>
  181b88:	017ff844 	movi	r5,-31
  181b8c:	2885c83a 	sub	r2,r5,r2
  181b90:	888ad83a 	srl	r5,r17,r2
  181b94:	00800804 	movi	r2,32
  181b98:	18801a26 	beq	r3,r2,181c04 <__muldf3+0x848>
  181b9c:	01001004 	movi	r4,64
  181ba0:	20c7c83a 	sub	r3,r4,r3
  181ba4:	88e2983a 	sll	r17,r17,r3
  181ba8:	8ca4b03a 	or	r18,r17,r18
  181bac:	9004c03a 	cmpne	r2,r18,zero
  181bb0:	2884b03a 	or	r2,r5,r2
  181bb4:	144001cc 	andi	r17,r2,7
  181bb8:	88000d1e 	bne	r17,zero,181bf0 <__muldf3+0x834>
  181bbc:	0021883a 	mov	r16,zero
  181bc0:	102cd0fa 	srli	r22,r2,3
  181bc4:	3027883a 	mov	r19,r6
  181bc8:	0005883a 	mov	r2,zero
  181bcc:	b46cb03a 	or	r22,r22,r17
  181bd0:	003e5906 	br	181538 <__muldf3+0x17c>
  181bd4:	1007883a 	mov	r3,r2
  181bd8:	0023883a 	mov	r17,zero
  181bdc:	8820927a 	slli	r16,r17,9
  181be0:	1805883a 	mov	r2,r3
  181be4:	8822977a 	slli	r17,r17,29
  181be8:	8020d33a 	srli	r16,r16,12
  181bec:	003ff406 	br	181bc0 <__muldf3+0x804>
  181bf0:	10c003cc 	andi	r3,r2,15
  181bf4:	01000104 	movi	r4,4
  181bf8:	193ff626 	beq	r3,r4,181bd4 <__muldf3+0x818>
  181bfc:	0023883a 	mov	r17,zero
  181c00:	003fd506 	br	181b58 <__muldf3+0x79c>
  181c04:	0023883a 	mov	r17,zero
  181c08:	003fe706 	br	181ba8 <__muldf3+0x7ec>
  181c0c:	00800434 	movhi	r2,16
  181c10:	8c000234 	orhi	r16,r17,8
  181c14:	10bfffc4 	addi	r2,r2,-1
  181c18:	3027883a 	mov	r19,r6
  181c1c:	80a0703a 	and	r16,r16,r2
  181c20:	902d883a 	mov	r22,r18
  181c24:	003eac06 	br	1816d8 <__muldf3+0x31c>

00181c28 <__fixdfsi>:
  181c28:	280cd53a 	srli	r6,r5,20
  181c2c:	00c00434 	movhi	r3,16
  181c30:	18ffffc4 	addi	r3,r3,-1
  181c34:	3181ffcc 	andi	r6,r6,2047
  181c38:	01c0ff84 	movi	r7,1022
  181c3c:	28c6703a 	and	r3,r5,r3
  181c40:	280ad7fa 	srli	r5,r5,31
  181c44:	3980120e 	bge	r7,r6,181c90 <__fixdfsi+0x68>
  181c48:	00810744 	movi	r2,1053
  181c4c:	11800c16 	blt	r2,r6,181c80 <__fixdfsi+0x58>
  181c50:	00810cc4 	movi	r2,1075
  181c54:	1185c83a 	sub	r2,r2,r6
  181c58:	01c007c4 	movi	r7,31
  181c5c:	18c00434 	orhi	r3,r3,16
  181c60:	38800d16 	blt	r7,r2,181c98 <__fixdfsi+0x70>
  181c64:	31befb44 	addi	r6,r6,-1043
  181c68:	2084d83a 	srl	r2,r4,r2
  181c6c:	1986983a 	sll	r3,r3,r6
  181c70:	1884b03a 	or	r2,r3,r2
  181c74:	28000726 	beq	r5,zero,181c94 <__fixdfsi+0x6c>
  181c78:	0085c83a 	sub	r2,zero,r2
  181c7c:	f800283a 	ret
  181c80:	00a00034 	movhi	r2,32768
  181c84:	10bfffc4 	addi	r2,r2,-1
  181c88:	2885883a 	add	r2,r5,r2
  181c8c:	f800283a 	ret
  181c90:	0005883a 	mov	r2,zero
  181c94:	f800283a 	ret
  181c98:	008104c4 	movi	r2,1043
  181c9c:	1185c83a 	sub	r2,r2,r6
  181ca0:	1884d83a 	srl	r2,r3,r2
  181ca4:	003ff306 	br	181c74 <__fixdfsi+0x4c>

00181ca8 <__floatsidf>:
  181ca8:	defffd04 	addi	sp,sp,-12
  181cac:	dfc00215 	stw	ra,8(sp)
  181cb0:	dc400115 	stw	r17,4(sp)
  181cb4:	dc000015 	stw	r16,0(sp)
  181cb8:	20002b26 	beq	r4,zero,181d68 <__floatsidf+0xc0>
  181cbc:	2023883a 	mov	r17,r4
  181cc0:	2020d7fa 	srli	r16,r4,31
  181cc4:	20002d16 	blt	r4,zero,181d7c <__floatsidf+0xd4>
  181cc8:	8809883a 	mov	r4,r17
  181ccc:	0181d840 	call	181d84 <__clzsi2>
  181cd0:	01410784 	movi	r5,1054
  181cd4:	288bc83a 	sub	r5,r5,r2
  181cd8:	01010cc4 	movi	r4,1075
  181cdc:	2149c83a 	sub	r4,r4,r5
  181ce0:	00c007c4 	movi	r3,31
  181ce4:	1900160e 	bge	r3,r4,181d40 <__floatsidf+0x98>
  181ce8:	00c104c4 	movi	r3,1043
  181cec:	1947c83a 	sub	r3,r3,r5
  181cf0:	88c6983a 	sll	r3,r17,r3
  181cf4:	00800434 	movhi	r2,16
  181cf8:	10bfffc4 	addi	r2,r2,-1
  181cfc:	1886703a 	and	r3,r3,r2
  181d00:	2941ffcc 	andi	r5,r5,2047
  181d04:	800d883a 	mov	r6,r16
  181d08:	0005883a 	mov	r2,zero
  181d0c:	280a953a 	slli	r5,r5,20
  181d10:	31803fcc 	andi	r6,r6,255
  181d14:	01000434 	movhi	r4,16
  181d18:	300c97fa 	slli	r6,r6,31
  181d1c:	213fffc4 	addi	r4,r4,-1
  181d20:	1906703a 	and	r3,r3,r4
  181d24:	1946b03a 	or	r3,r3,r5
  181d28:	1986b03a 	or	r3,r3,r6
  181d2c:	dfc00217 	ldw	ra,8(sp)
  181d30:	dc400117 	ldw	r17,4(sp)
  181d34:	dc000017 	ldw	r16,0(sp)
  181d38:	dec00304 	addi	sp,sp,12
  181d3c:	f800283a 	ret
  181d40:	00c002c4 	movi	r3,11
  181d44:	1887c83a 	sub	r3,r3,r2
  181d48:	88c6d83a 	srl	r3,r17,r3
  181d4c:	8904983a 	sll	r2,r17,r4
  181d50:	01000434 	movhi	r4,16
  181d54:	213fffc4 	addi	r4,r4,-1
  181d58:	2941ffcc 	andi	r5,r5,2047
  181d5c:	1906703a 	and	r3,r3,r4
  181d60:	800d883a 	mov	r6,r16
  181d64:	003fe906 	br	181d0c <__floatsidf+0x64>
  181d68:	000d883a 	mov	r6,zero
  181d6c:	000b883a 	mov	r5,zero
  181d70:	0007883a 	mov	r3,zero
  181d74:	0005883a 	mov	r2,zero
  181d78:	003fe406 	br	181d0c <__floatsidf+0x64>
  181d7c:	0123c83a 	sub	r17,zero,r4
  181d80:	003fd106 	br	181cc8 <__floatsidf+0x20>

00181d84 <__clzsi2>:
  181d84:	00bfffd4 	movui	r2,65535
  181d88:	11000536 	bltu	r2,r4,181da0 <__clzsi2+0x1c>
  181d8c:	00803fc4 	movi	r2,255
  181d90:	11000f36 	bltu	r2,r4,181dd0 <__clzsi2+0x4c>
  181d94:	00800804 	movi	r2,32
  181d98:	0007883a 	mov	r3,zero
  181d9c:	00000506 	br	181db4 <__clzsi2+0x30>
  181da0:	00804034 	movhi	r2,256
  181da4:	10bfffc4 	addi	r2,r2,-1
  181da8:	11000c2e 	bgeu	r2,r4,181ddc <__clzsi2+0x58>
  181dac:	00800204 	movi	r2,8
  181db0:	00c00604 	movi	r3,24
  181db4:	20c8d83a 	srl	r4,r4,r3
  181db8:	00c00634 	movhi	r3,24
  181dbc:	18cc0d84 	addi	r3,r3,12342
  181dc0:	1909883a 	add	r4,r3,r4
  181dc4:	20c00003 	ldbu	r3,0(r4)
  181dc8:	10c5c83a 	sub	r2,r2,r3
  181dcc:	f800283a 	ret
  181dd0:	00800604 	movi	r2,24
  181dd4:	00c00204 	movi	r3,8
  181dd8:	003ff606 	br	181db4 <__clzsi2+0x30>
  181ddc:	00800404 	movi	r2,16
  181de0:	1007883a 	mov	r3,r2
  181de4:	003ff306 	br	181db4 <__clzsi2+0x30>

00181de8 <__mulsi3>:
  181de8:	0005883a 	mov	r2,zero
  181dec:	20000726 	beq	r4,zero,181e0c <__mulsi3+0x24>
  181df0:	20c0004c 	andi	r3,r4,1
  181df4:	2008d07a 	srli	r4,r4,1
  181df8:	18000126 	beq	r3,zero,181e00 <__mulsi3+0x18>
  181dfc:	1145883a 	add	r2,r2,r5
  181e00:	294b883a 	add	r5,r5,r5
  181e04:	203ffa1e 	bne	r4,zero,181df0 <__mulsi3+0x8>
  181e08:	f800283a 	ret
  181e0c:	f800283a 	ret

00181e10 <memcpy>:
  181e10:	2005883a 	mov	r2,r4
  181e14:	2007883a 	mov	r3,r4
  181e18:	218d883a 	add	r6,r4,r6
  181e1c:	19800526 	beq	r3,r6,181e34 <memcpy+0x24>
  181e20:	29000003 	ldbu	r4,0(r5)
  181e24:	18c00044 	addi	r3,r3,1
  181e28:	29400044 	addi	r5,r5,1
  181e2c:	193fffc5 	stb	r4,-1(r3)
  181e30:	003ffa06 	br	181e1c <memcpy+0xc>
  181e34:	f800283a 	ret

00181e38 <_putchar_r>:
  181e38:	21800217 	ldw	r6,8(r4)
  181e3c:	01820181 	jmpi	182018 <_putc_r>

00181e40 <putchar>:
  181e40:	00800634 	movhi	r2,24
  181e44:	108e7704 	addi	r2,r2,14812
  181e48:	10800017 	ldw	r2,0(r2)
  181e4c:	200b883a 	mov	r5,r4
  181e50:	11800217 	ldw	r6,8(r2)
  181e54:	1009883a 	mov	r4,r2
  181e58:	01820181 	jmpi	182018 <_putc_r>

00181e5c <_puts_r>:
  181e5c:	defffd04 	addi	sp,sp,-12
  181e60:	dc000015 	stw	r16,0(sp)
  181e64:	2021883a 	mov	r16,r4
  181e68:	2809883a 	mov	r4,r5
  181e6c:	dfc00215 	stw	ra,8(sp)
  181e70:	dc400115 	stw	r17,4(sp)
  181e74:	2823883a 	mov	r17,r5
  181e78:	0181ef00 	call	181ef0 <strlen>
  181e7c:	81400217 	ldw	r5,8(r16)
  181e80:	01000634 	movhi	r4,24
  181e84:	2107c304 	addi	r4,r4,7948
  181e88:	29000115 	stw	r4,4(r5)
  181e8c:	100f883a 	mov	r7,r2
  181e90:	880d883a 	mov	r6,r17
  181e94:	8009883a 	mov	r4,r16
  181e98:	0181f0c0 	call	181f0c <__sfvwrite_small_dev>
  181e9c:	00ffffc4 	movi	r3,-1
  181ea0:	10c00926 	beq	r2,r3,181ec8 <_puts_r+0x6c>
  181ea4:	81400217 	ldw	r5,8(r16)
  181ea8:	01800634 	movhi	r6,24
  181eac:	01c00044 	movi	r7,1
  181eb0:	28800117 	ldw	r2,4(r5)
  181eb4:	318c0d04 	addi	r6,r6,12340
  181eb8:	8009883a 	mov	r4,r16
  181ebc:	103ee83a 	callr	r2
  181ec0:	10bfffe0 	cmpeqi	r2,r2,-1
  181ec4:	0085c83a 	sub	r2,zero,r2
  181ec8:	dfc00217 	ldw	ra,8(sp)
  181ecc:	dc400117 	ldw	r17,4(sp)
  181ed0:	dc000017 	ldw	r16,0(sp)
  181ed4:	dec00304 	addi	sp,sp,12
  181ed8:	f800283a 	ret

00181edc <puts>:
  181edc:	00800634 	movhi	r2,24
  181ee0:	108e7704 	addi	r2,r2,14812
  181ee4:	200b883a 	mov	r5,r4
  181ee8:	11000017 	ldw	r4,0(r2)
  181eec:	0181e5c1 	jmpi	181e5c <_puts_r>

00181ef0 <strlen>:
  181ef0:	2005883a 	mov	r2,r4
  181ef4:	10c00007 	ldb	r3,0(r2)
  181ef8:	18000226 	beq	r3,zero,181f04 <strlen+0x14>
  181efc:	10800044 	addi	r2,r2,1
  181f00:	003ffc06 	br	181ef4 <strlen+0x4>
  181f04:	1105c83a 	sub	r2,r2,r4
  181f08:	f800283a 	ret

00181f0c <__sfvwrite_small_dev>:
  181f0c:	2880000b 	ldhu	r2,0(r5)
  181f10:	1080020c 	andi	r2,r2,8
  181f14:	10002126 	beq	r2,zero,181f9c <__sfvwrite_small_dev+0x90>
  181f18:	2880008f 	ldh	r2,2(r5)
  181f1c:	defffa04 	addi	sp,sp,-24
  181f20:	dc000015 	stw	r16,0(sp)
  181f24:	dfc00515 	stw	ra,20(sp)
  181f28:	dd000415 	stw	r20,16(sp)
  181f2c:	dcc00315 	stw	r19,12(sp)
  181f30:	dc800215 	stw	r18,8(sp)
  181f34:	dc400115 	stw	r17,4(sp)
  181f38:	2821883a 	mov	r16,r5
  181f3c:	10001216 	blt	r2,zero,181f88 <__sfvwrite_small_dev+0x7c>
  181f40:	2027883a 	mov	r19,r4
  181f44:	3025883a 	mov	r18,r6
  181f48:	3823883a 	mov	r17,r7
  181f4c:	05010004 	movi	r20,1024
  181f50:	04400b0e 	bge	zero,r17,181f80 <__sfvwrite_small_dev+0x74>
  181f54:	880f883a 	mov	r7,r17
  181f58:	a440010e 	bge	r20,r17,181f60 <__sfvwrite_small_dev+0x54>
  181f5c:	01c10004 	movi	r7,1024
  181f60:	8140008f 	ldh	r5,2(r16)
  181f64:	900d883a 	mov	r6,r18
  181f68:	9809883a 	mov	r4,r19
  181f6c:	01820700 	call	182070 <_write_r>
  181f70:	0080050e 	bge	zero,r2,181f88 <__sfvwrite_small_dev+0x7c>
  181f74:	88a3c83a 	sub	r17,r17,r2
  181f78:	90a5883a 	add	r18,r18,r2
  181f7c:	003ff406 	br	181f50 <__sfvwrite_small_dev+0x44>
  181f80:	0005883a 	mov	r2,zero
  181f84:	00000706 	br	181fa4 <__sfvwrite_small_dev+0x98>
  181f88:	8080000b 	ldhu	r2,0(r16)
  181f8c:	10801014 	ori	r2,r2,64
  181f90:	8080000d 	sth	r2,0(r16)
  181f94:	00bfffc4 	movi	r2,-1
  181f98:	00000206 	br	181fa4 <__sfvwrite_small_dev+0x98>
  181f9c:	00bfffc4 	movi	r2,-1
  181fa0:	f800283a 	ret
  181fa4:	dfc00517 	ldw	ra,20(sp)
  181fa8:	dd000417 	ldw	r20,16(sp)
  181fac:	dcc00317 	ldw	r19,12(sp)
  181fb0:	dc800217 	ldw	r18,8(sp)
  181fb4:	dc400117 	ldw	r17,4(sp)
  181fb8:	dc000017 	ldw	r16,0(sp)
  181fbc:	dec00604 	addi	sp,sp,24
  181fc0:	f800283a 	ret

00181fc4 <putc>:
  181fc4:	defffd04 	addi	sp,sp,-12
  181fc8:	00800634 	movhi	r2,24
  181fcc:	dc000115 	stw	r16,4(sp)
  181fd0:	dfc00215 	stw	ra,8(sp)
  181fd4:	1087c304 	addi	r2,r2,7948
  181fd8:	28800115 	stw	r2,4(r5)
  181fdc:	00800634 	movhi	r2,24
  181fe0:	108e7704 	addi	r2,r2,14812
  181fe4:	d9000005 	stb	r4,0(sp)
  181fe8:	2021883a 	mov	r16,r4
  181fec:	11000017 	ldw	r4,0(r2)
  181ff0:	01c00044 	movi	r7,1
  181ff4:	d80d883a 	mov	r6,sp
  181ff8:	0181f0c0 	call	181f0c <__sfvwrite_small_dev>
  181ffc:	00ffffc4 	movi	r3,-1
  182000:	10c00126 	beq	r2,r3,182008 <putc+0x44>
  182004:	8005883a 	mov	r2,r16
  182008:	dfc00217 	ldw	ra,8(sp)
  18200c:	dc000117 	ldw	r16,4(sp)
  182010:	dec00304 	addi	sp,sp,12
  182014:	f800283a 	ret

00182018 <_putc_r>:
  182018:	defffd04 	addi	sp,sp,-12
  18201c:	00800634 	movhi	r2,24
  182020:	dc000115 	stw	r16,4(sp)
  182024:	dfc00215 	stw	ra,8(sp)
  182028:	1087c304 	addi	r2,r2,7948
  18202c:	30800115 	stw	r2,4(r6)
  182030:	00800634 	movhi	r2,24
  182034:	108e7704 	addi	r2,r2,14812
  182038:	11000017 	ldw	r4,0(r2)
  18203c:	2821883a 	mov	r16,r5
  182040:	01c00044 	movi	r7,1
  182044:	300b883a 	mov	r5,r6
  182048:	d80d883a 	mov	r6,sp
  18204c:	dc000005 	stb	r16,0(sp)
  182050:	0181f0c0 	call	181f0c <__sfvwrite_small_dev>
  182054:	00ffffc4 	movi	r3,-1
  182058:	10c00126 	beq	r2,r3,182060 <_putc_r+0x48>
  18205c:	8005883a 	mov	r2,r16
  182060:	dfc00217 	ldw	ra,8(sp)
  182064:	dc000117 	ldw	r16,4(sp)
  182068:	dec00304 	addi	sp,sp,12
  18206c:	f800283a 	ret

00182070 <_write_r>:
  182070:	defffd04 	addi	sp,sp,-12
  182074:	dc000015 	stw	r16,0(sp)
  182078:	04000634 	movhi	r16,24
  18207c:	dc400115 	stw	r17,4(sp)
  182080:	8410b104 	addi	r16,r16,17092
  182084:	2023883a 	mov	r17,r4
  182088:	2809883a 	mov	r4,r5
  18208c:	300b883a 	mov	r5,r6
  182090:	380d883a 	mov	r6,r7
  182094:	dfc00215 	stw	ra,8(sp)
  182098:	80000015 	stw	zero,0(r16)
  18209c:	01823900 	call	182390 <write>
  1820a0:	00ffffc4 	movi	r3,-1
  1820a4:	10c0031e 	bne	r2,r3,1820b4 <_write_r+0x44>
  1820a8:	80c00017 	ldw	r3,0(r16)
  1820ac:	18000126 	beq	r3,zero,1820b4 <_write_r+0x44>
  1820b0:	88c00015 	stw	r3,0(r17)
  1820b4:	dfc00217 	ldw	ra,8(sp)
  1820b8:	dc400117 	ldw	r17,4(sp)
  1820bc:	dc000017 	ldw	r16,0(sp)
  1820c0:	dec00304 	addi	sp,sp,12
  1820c4:	f800283a 	ret

001820c8 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
  1820c8:	deffff04 	addi	sp,sp,-4
  1820cc:	01000634 	movhi	r4,24
  1820d0:	01400634 	movhi	r5,24
  1820d4:	dfc00015 	stw	ra,0(sp)
  1820d8:	210c4e04 	addi	r4,r4,12600
  1820dc:	294e7d04 	addi	r5,r5,14836

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  1820e0:	2140061e 	bne	r4,r5,1820fc <alt_load+0x34>
  1820e4:	01000634 	movhi	r4,24
  1820e8:	01400634 	movhi	r5,24
  1820ec:	21000804 	addi	r4,r4,32
  1820f0:	29400804 	addi	r5,r5,32
  1820f4:	2140121e 	bne	r4,r5,182140 <alt_load+0x78>
  1820f8:	00000b06 	br	182128 <alt_load+0x60>
  1820fc:	00c00634 	movhi	r3,24
  182100:	18ce7d04 	addi	r3,r3,14836
  182104:	1907c83a 	sub	r3,r3,r4
  182108:	0005883a 	mov	r2,zero
  {
    while( to != end )
  18210c:	10fff526 	beq	r2,r3,1820e4 <alt_load+0x1c>
    {
      *to++ = *from++;
  182110:	114f883a 	add	r7,r2,r5
  182114:	39c00017 	ldw	r7,0(r7)
  182118:	110d883a 	add	r6,r2,r4
  18211c:	10800104 	addi	r2,r2,4
  182120:	31c00015 	stw	r7,0(r6)
  182124:	003ff906 	br	18210c <alt_load+0x44>
  182128:	01000634 	movhi	r4,24
  18212c:	01400634 	movhi	r5,24
  182130:	210ba504 	addi	r4,r4,11924
  182134:	294ba504 	addi	r5,r5,11924

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  182138:	2140101e 	bne	r4,r5,18217c <alt_load+0xb4>
  18213c:	00000b06 	br	18216c <alt_load+0xa4>
  182140:	00c00634 	movhi	r3,24
  182144:	18c05304 	addi	r3,r3,332
  182148:	1907c83a 	sub	r3,r3,r4
  18214c:	0005883a 	mov	r2,zero
  {
    while( to != end )
  182150:	10fff526 	beq	r2,r3,182128 <alt_load+0x60>
    {
      *to++ = *from++;
  182154:	114f883a 	add	r7,r2,r5
  182158:	39c00017 	ldw	r7,0(r7)
  18215c:	110d883a 	add	r6,r2,r4
  182160:	10800104 	addi	r2,r2,4
  182164:	31c00015 	stw	r7,0(r6)
  182168:	003ff906 	br	182150 <alt_load+0x88>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  18216c:	0182acc0 	call	182acc <alt_dcache_flush_all>
  alt_icache_flush_all();
}
  182170:	dfc00017 	ldw	ra,0(sp)
  182174:	dec00104 	addi	sp,sp,4
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  alt_icache_flush_all();
  182178:	0182bb01 	jmpi	182bb0 <alt_icache_flush_all>
  18217c:	00c00634 	movhi	r3,24
  182180:	18cc4e04 	addi	r3,r3,12600
  182184:	1907c83a 	sub	r3,r3,r4

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  182188:	0005883a 	mov	r2,zero
  {
    while( to != end )
  18218c:	18bff726 	beq	r3,r2,18216c <alt_load+0xa4>
    {
      *to++ = *from++;
  182190:	114f883a 	add	r7,r2,r5
  182194:	39c00017 	ldw	r7,0(r7)
  182198:	110d883a 	add	r6,r2,r4
  18219c:	10800104 	addi	r2,r2,4
  1821a0:	31c00015 	stw	r7,0(r6)
  1821a4:	003ff906 	br	18218c <alt_load+0xc4>

001821a8 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
  1821a8:	deffff04 	addi	sp,sp,-4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
  1821ac:	0009883a 	mov	r4,zero
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
  1821b0:	dfc00015 	stw	ra,0(sp)
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
  1821b4:	01823f00 	call	1823f0 <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
  1821b8:	01824100 	call	182410 <alt_sys_init>
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
  1821bc:	d1a23c17 	ldw	r6,-30480(gp)
  1821c0:	d1623d17 	ldw	r5,-30476(gp)
  1821c4:	d1223e17 	ldw	r4,-30472(gp)
  close(STDOUT_FILENO);
  exit (result);
#endif

  ALT_LOG_PRINT_BOOT("[alt_main.c] After main - we should not be here?.\r\n");
}
  1821c8:	dfc00017 	ldw	ra,0(sp)
  1821cc:	dec00104 	addi	sp,sp,4
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
  1821d0:	01807341 	jmpi	180734 <main>

001821d4 <alt_printf>:
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
  1821d4:	defff204 	addi	sp,sp,-56
  1821d8:	2005883a 	mov	r2,r4
  1821dc:	dfc00a15 	stw	ra,40(sp)
  1821e0:	df000915 	stw	fp,36(sp)
  1821e4:	ddc00815 	stw	r23,32(sp)
  1821e8:	dd800715 	stw	r22,28(sp)
  1821ec:	dd400615 	stw	r21,24(sp)
  1821f0:	dd000515 	stw	r20,20(sp)
  1821f4:	dcc00415 	stw	r19,16(sp)
  1821f8:	dc800315 	stw	r18,12(sp)
  1821fc:	dc400215 	stw	r17,8(sp)
  182200:	dc000115 	stw	r16,4(sp)
  182204:	d9400b15 	stw	r5,44(sp)
  182208:	d9800c15 	stw	r6,48(sp)
  18220c:	d9c00d15 	stw	r7,52(sp)
    w = fmt;
    while ((c = *w++) != 0)
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
  182210:	04000944 	movi	r16,37
 */
void 
alt_printf(const char* fmt, ... )
{
	va_list args;
	va_start(args, fmt);
  182214:	dd400b04 	addi	r21,sp,44
                if (c == '%')
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
                } 
                else if (c == 'c')
  182218:	048018c4 	movi	r18,99
                {
                    int v = va_arg(args, int);
                    alt_putchar(v);
                }
                else if (c == 'x')
  18221c:	04c01e04 	movi	r19,120
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
  182220:	05001cc4 	movi	r20,115
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
  182224:	11000007 	ldb	r4,0(r2)
  182228:	20003a26 	beq	r4,zero,182314 <alt_printf+0x140>
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
  18222c:	24000226 	beq	r4,r16,182238 <alt_printf+0x64>
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
  182230:	14400044 	addi	r17,r2,1
  182234:	00001406 	br	182288 <alt_printf+0xb4>
        }
        else
        {
            /* Get format character.  If none     */
            /* available, processing is complete. */
            if ((c = *w++) != 0)
  182238:	14400084 	addi	r17,r2,2
  18223c:	10800047 	ldb	r2,1(r2)
  182240:	10003426 	beq	r2,zero,182314 <alt_printf+0x140>
            {
                if (c == '%')
  182244:	1400021e 	bne	r2,r16,182250 <alt_printf+0x7c>
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
  182248:	8009883a 	mov	r4,r16
  18224c:	00000e06 	br	182288 <alt_printf+0xb4>
                } 
                else if (c == 'c')
  182250:	1480051e 	bne	r2,r18,182268 <alt_printf+0x94>
                {
                    int v = va_arg(args, int);
                    alt_putchar(v);
  182254:	a9000017 	ldw	r4,0(r21)
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
                } 
                else if (c == 'c')
                {
                    int v = va_arg(args, int);
  182258:	ad800104 	addi	r22,r21,4
  18225c:	b02b883a 	mov	r21,r22
                    alt_putchar(v);
  182260:	01823440 	call	182344 <alt_putchar>
  182264:	00002906 	br	18230c <alt_printf+0x138>
                }
                else if (c == 'x')
  182268:	14c0201e 	bne	r2,r19,1822ec <alt_printf+0x118>
                {
                    /* Process hexadecimal number format. */
                    unsigned long v = va_arg(args, unsigned long);
  18226c:	adc00017 	ldw	r23,0(r21)
  182270:	ad400104 	addi	r21,r21,4
                    unsigned long digit;
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
  182274:	b8000326 	beq	r23,zero,182284 <alt_printf+0xb0>
  182278:	05800704 	movi	r22,28
                        continue;
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
  18227c:	00c003c4 	movi	r3,15
  182280:	00000306 	br	182290 <alt_printf+0xbc>
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
                    {
                        alt_putchar('0');
  182284:	01000c04 	movi	r4,48
  182288:	01823440 	call	182344 <alt_putchar>
                        continue;
  18228c:	00001f06 	br	18230c <alt_printf+0x138>
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
  182290:	1d84983a 	sll	r2,r3,r22
  182294:	15c4703a 	and	r2,r2,r23
  182298:	1000021e 	bne	r2,zero,1822a4 <alt_printf+0xd0>
                        digit_shift -= 4;
  18229c:	b5bfff04 	addi	r22,r22,-4
  1822a0:	003ffb06 	br	182290 <alt_printf+0xbc>

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
  1822a4:	070003c4 	movi	fp,15
                        if (digit <= 9)
  1822a8:	00c00244 	movi	r3,9
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
  1822ac:	b0001716 	blt	r22,zero,18230c <alt_printf+0x138>
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
  1822b0:	e588983a 	sll	r4,fp,r22
  1822b4:	25c8703a 	and	r4,r4,r23
  1822b8:	2588d83a 	srl	r4,r4,r22
                        if (digit <= 9)
  1822bc:	19000236 	bltu	r3,r4,1822c8 <alt_printf+0xf4>
                            c = '0' + digit;
  1822c0:	21000c04 	addi	r4,r4,48
  1822c4:	00000106 	br	1822cc <alt_printf+0xf8>
                        else
                            c = 'a' + digit - 10;
  1822c8:	210015c4 	addi	r4,r4,87
                        alt_putchar(c);
  1822cc:	21003fcc 	andi	r4,r4,255
  1822d0:	2100201c 	xori	r4,r4,128
  1822d4:	213fe004 	addi	r4,r4,-128
  1822d8:	d8c00015 	stw	r3,0(sp)
  1822dc:	01823440 	call	182344 <alt_putchar>
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
  1822e0:	b5bfff04 	addi	r22,r22,-4
  1822e4:	d8c00017 	ldw	r3,0(sp)
  1822e8:	003ff006 	br	1822ac <alt_printf+0xd8>
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
  1822ec:	1500071e 	bne	r2,r20,18230c <alt_printf+0x138>
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);
  1822f0:	ad800017 	ldw	r22,0(r21)
  1822f4:	ad400104 	addi	r21,r21,4

                    while(*s)
  1822f8:	b1000007 	ldb	r4,0(r22)
  1822fc:	20000326 	beq	r4,zero,18230c <alt_printf+0x138>
                      alt_putchar(*s++);
  182300:	b5800044 	addi	r22,r22,1
  182304:	01823440 	call	182344 <alt_putchar>
  182308:	003ffb06 	br	1822f8 <alt_printf+0x124>
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
                } 
                else if (c == 'c')
                {
                    int v = va_arg(args, int);
  18230c:	8805883a 	mov	r2,r17
  182310:	003fc406 	br	182224 <alt_printf+0x50>
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
  182314:	dfc00a17 	ldw	ra,40(sp)
  182318:	df000917 	ldw	fp,36(sp)
  18231c:	ddc00817 	ldw	r23,32(sp)
  182320:	dd800717 	ldw	r22,28(sp)
  182324:	dd400617 	ldw	r21,24(sp)
  182328:	dd000517 	ldw	r20,20(sp)
  18232c:	dcc00417 	ldw	r19,16(sp)
  182330:	dc800317 	ldw	r18,12(sp)
  182334:	dc400217 	ldw	r17,8(sp)
  182338:	dc000117 	ldw	r16,4(sp)
  18233c:	dec00e04 	addi	sp,sp,56
  182340:	f800283a 	ret

00182344 <alt_putchar>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
  182344:	defffd04 	addi	sp,sp,-12
  182348:	dc000115 	stw	r16,4(sp)
	char        c1 = (char)(c & 0xff);
    return write(STDOUT_FILENO,&c1,1);
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    char        c1 = (char)(c & 0xff);
  18234c:	d9000005 	stb	r4,0(sp)
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
  182350:	2021883a 	mov	r16,r4
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    char        c1 = (char)(c & 0xff);

    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
  182354:	01000634 	movhi	r4,24
  182358:	000f883a 	mov	r7,zero
  18235c:	01800044 	movi	r6,1
  182360:	d80b883a 	mov	r5,sp
  182364:	210e7804 	addi	r4,r4,14816
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
  182368:	dfc00215 	stw	ra,8(sp)
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    char        c1 = (char)(c & 0xff);

    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
  18236c:	01824480 	call	182448 <altera_avalon_jtag_uart_write>
  182370:	00ffffc4 	movi	r3,-1
  182374:	10c00126 	beq	r2,r3,18237c <alt_putchar+0x38>
        return -1;
    }
    return c;
  182378:	8005883a 	mov	r2,r16
#else
    return putchar(c);
#endif
#endif
}
  18237c:	dfc00217 	ldw	ra,8(sp)
  182380:	dc000117 	ldw	r16,4(sp)
  182384:	dec00304 	addi	sp,sp,12
  182388:	f800283a 	ret

0018238c <usleep>:
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
  return alt_busy_sleep(us);
  18238c:	0182a401 	jmpi	182a40 <alt_busy_sleep>

00182390 <write>:
#if !defined(ALT_STDOUT_PRESENT) && !defined(ALT_STDERR_PRESENT)
    /* Generate a link time warning, should this function ever be called. */
    ALT_STUB_WARNING(write);
#endif

    switch (file) {
  182390:	00800044 	movi	r2,1
  182394:	20800226 	beq	r4,r2,1823a0 <write+0x10>
  182398:	00800084 	movi	r2,2
  18239c:	2080041e 	bne	r4,r2,1823b0 <write+0x20>
    case 1: /* stdout file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, ptr, len, 0);
#endif /* ALT_STDOUT_PRESENT */
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
  1823a0:	01000634 	movhi	r4,24
  1823a4:	000f883a 	mov	r7,zero
  1823a8:	210e7804 	addi	r4,r4,14816
  1823ac:	01824481 	jmpi	182448 <altera_avalon_jtag_uart_write>

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  return ((alt_errno) ? alt_errno() : &errno);
  1823b0:	d0a00517 	ldw	r2,-32748(gp)
  1823b4:	10000926 	beq	r2,zero,1823dc <write+0x4c>
 * Provide minimal version that just writes to the stdout/stderr devices
 * when provided.
 */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
  1823b8:	deffff04 	addi	sp,sp,-4
  1823bc:	dfc00015 	stw	ra,0(sp)
  1823c0:	103ee83a 	callr	r2
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
#endif /* ALT_STDERR_PRESENT */
    default:
        ALT_ERRNO = EBADFD;
  1823c4:	00c01444 	movi	r3,81
  1823c8:	10c00015 	stw	r3,0(r2)
        return -1;
    }
}
  1823cc:	00bfffc4 	movi	r2,-1
  1823d0:	dfc00017 	ldw	ra,0(sp)
  1823d4:	dec00104 	addi	sp,sp,4
  1823d8:	f800283a 	ret
  1823dc:	d0a23b04 	addi	r2,gp,-30484
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
#endif /* ALT_STDERR_PRESENT */
    default:
        ALT_ERRNO = EBADFD;
  1823e0:	00c01444 	movi	r3,81
  1823e4:	10c00015 	stw	r3,0(r2)
        return -1;
    }
}
  1823e8:	00bfffc4 	movi	r2,-1
  1823ec:	f800283a 	ret

001823f0 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
  1823f0:	deffff04 	addi	sp,sp,-4
  1823f4:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2, nios2);
  1823f8:	0182ca80 	call	182ca8 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
  1823fc:	00800044 	movi	r2,1
  182400:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
  182404:	dfc00017 	ldw	ra,0(sp)
  182408:	dec00104 	addi	sp,sp,4
  18240c:	f800283a 	ret

00182410 <alt_sys_init>:
 */

void alt_sys_init( void )
{
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_RX, sgdma_rx);
  182410:	01000634 	movhi	r4,24
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
  182414:	deffff04 	addi	sp,sp,-4
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_RX, sgdma_rx);
  182418:	000d883a 	mov	r6,zero
  18241c:	000b883a 	mov	r5,zero
  182420:	210e6a04 	addi	r4,r4,14760
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
  182424:	dfc00015 	stw	ra,0(sp)
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_RX, sgdma_rx);
  182428:	01829bc0 	call	1829bc <alt_avalon_sgdma_init>
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_TX, sgdma_tx);
  18242c:	01000634 	movhi	r4,24
  182430:	01800044 	movi	r6,1
  182434:	000b883a 	mov	r5,zero
  182438:	210e5e04 	addi	r4,r4,14712
    ALTERA_ETH_TSE_INIT ( ETH_TSE, eth_tse);
}
  18243c:	dfc00017 	ldw	ra,0(sp)
  182440:	dec00104 	addi	sp,sp,4

void alt_sys_init( void )
{
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_RX, sgdma_rx);
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_TX, sgdma_tx);
  182444:	01829bc1 	jmpi	1829bc <alt_avalon_sgdma_init>

00182448 <altera_avalon_jtag_uart_write>:
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  unsigned int base = sp->base;
  182448:	21000017 	ldw	r4,0(r4)
 * one FIFOs worth of data.  But you said you didn't want to use interrupts :-)
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  18244c:	3005883a 	mov	r2,r6
  unsigned int base = sp->base;

  const char * end = ptr + count;
  182450:	298d883a 	add	r6,r5,r6

  while (ptr < end)
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
  182454:	21c00104 	addi	r7,r4,4
{
  unsigned int base = sp->base;

  const char * end = ptr + count;

  while (ptr < end)
  182458:	2980072e 	bgeu	r5,r6,182478 <altera_avalon_jtag_uart_write+0x30>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
  18245c:	38c00037 	ldwio	r3,0(r7)
  182460:	18ffffec 	andhi	r3,r3,65535
  182464:	183ffc26 	beq	r3,zero,182458 <altera_avalon_jtag_uart_write+0x10>
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);
  182468:	28c00007 	ldb	r3,0(r5)
  18246c:	20c00035 	stwio	r3,0(r4)
  182470:	29400044 	addi	r5,r5,1
  182474:	003ff806 	br	182458 <altera_avalon_jtag_uart_write+0x10>

  return count;
}
  182478:	f800283a 	ret

0018247c <alt_avalon_sgdma_irq>:
   * Note: This is explicitly done before calling user interrupt-handling
   * code rather than after; if user ISR code initiates another SGDMA
   * transfer which completes quickly, reading the control register after
   * the callback routine may result in a lost interrupt.
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
  18247c:	20800317 	ldw	r2,12(r4)
  182480:	10800404 	addi	r2,r2,16
  182484:	10c00037 	ldwio	r3,0(r2)
  182488:	18e00034 	orhi	r3,r3,32768
  18248c:	10c00035 	stwio	r3,0(r2)
    IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) | 0x80000000);
  
  /* Dummy read to ensure IRQ is negated before the ISR returns */
  IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  182490:	20800317 	ldw	r2,12(r4)
  182494:	10800437 	ldwio	r2,16(r2)
   * Other interrupts are explicitly disabled if callbacks
   * are registered because there is no guarantee that they are 
   * preemption-safe. This allows the driver to support 
   * interrupt preemption.
   */
  if(dev->callback) {
  182498:	20c00917 	ldw	r3,36(r4)
  18249c:	18000d26 	beq	r3,zero,1824d4 <alt_avalon_sgdma_irq+0x58>
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_sgdma_irq(void *context)
#else
static void alt_avalon_sgdma_irq(void *context, alt_u32 id)
#endif
{
  1824a0:	defffe04 	addi	sp,sp,-8
  1824a4:	dfc00115 	stw	ra,4(sp)
  1824a8:	dc000015 	stw	r16,0(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  1824ac:	0021303a 	rdctl	r16,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  1824b0:	00bfff84 	movi	r2,-2
  1824b4:	8084703a 	and	r2,r16,r2
  1824b8:	1001703a 	wrctl	status,r2
   * preemption-safe. This allows the driver to support 
   * interrupt preemption.
   */
  if(dev->callback) {
    cpu_sr = alt_irq_disable_all();
    (dev->callback)(dev->callback_context);
  1824bc:	21000a17 	ldw	r4,40(r4)
  1824c0:	183ee83a 	callr	r3
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  1824c4:	8001703a 	wrctl	status,r16
    alt_irq_enable_all(cpu_sr);
  }
}
  1824c8:	dfc00117 	ldw	ra,4(sp)
  1824cc:	dc000017 	ldw	r16,0(sp)
  1824d0:	dec00204 	addi	sp,sp,8
  1824d4:	f800283a 	ret

001824d8 <alt_avalon_sgdma_do_async_transfer>:
  alt_sgdma_descriptor *desc)
{
  alt_u32 control;

  /* Return with error immediately if controller is busy */
  if( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
  1824d8:	20c00317 	ldw	r3,12(r4)
  1824dc:	18800037 	ldwio	r2,0(r3)
  1824e0:	1080040c 	andi	r2,r2,16
  1824e4:	1000191e 	bne	r2,zero,18254c <alt_avalon_sgdma_do_async_transfer+0x74>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    return -EBUSY;
  }

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
  1824e8:	18c00404 	addi	r3,r3,16
  1824ec:	19c00037 	ldwio	r7,0(r3)
  1824f0:	01bff7c4 	movi	r6,-33
  1824f4:	398c703a 	and	r6,r7,r6
  1824f8:	19800035 	stwio	r6,0(r3)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
  1824fc:	20c00317 	ldw	r3,12(r4)
  182500:	01803fc4 	movi	r6,255
  182504:	19800035 	stwio	r6,0(r3)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
  182508:	20c00317 	ldw	r3,12(r4)
  18250c:	19400835 	stwio	r5,32(r3)
  182510:	20c00317 	ldw	r3,12(r4)
   *  - Stop on an error with any particular descriptor
   *  - Include any control register bits registered with along with
   *    the callback routine (effectively, interrupts are controlled
   *    via the control bits set during callback-register time).
   */
  if(dev->callback) {
  182514:	21400917 	ldw	r5,36(r4)
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  182518:	18c00404 	addi	r3,r3,16
   *  - Stop on an error with any particular descriptor
   *  - Include any control register bits registered with along with
   *    the callback routine (effectively, interrupts are controlled
   *    via the control bits set during callback-register time).
   */
  if(dev->callback) {
  18251c:	28000526 	beq	r5,zero,182534 <alt_avalon_sgdma_do_async_transfer+0x5c>
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  182520:	19400037 	ldwio	r5,0(r3)

    control |= (dev->chain_control                          |
                ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK  );

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
  182524:	21000b17 	ldw	r4,44(r4)
  182528:	21001814 	ori	r4,r4,96
  18252c:	2148b03a 	or	r4,r4,r5
  182530:	00000406 	br	182544 <alt_avalon_sgdma_do_async_transfer+0x6c>
   *   - Run
   *   - Stop on an error with any particular descriptor
   *   - Disable interrupt generation
   */
  else {
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  182534:	19400037 	ldwio	r5,0(r3)
  182538:	013ffbc4 	movi	r4,-17
  18253c:	2908703a 	and	r4,r5,r4

    control |= (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK );
    control &= ~ALTERA_AVALON_SGDMA_CONTROL_IE_GLOBAL_MSK;

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
  182540:	21001814 	ori	r4,r4,96
  182544:	19000035 	stwio	r4,0(r3)
  182548:	f800283a 	ret
  alt_u32 control;

  /* Return with error immediately if controller is busy */
  if( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    return -EBUSY;
  18254c:	00bffc04 	movi	r2,-16
  /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
  return 0;
}
  182550:	f800283a 	ret

00182554 <alt_avalon_sgdma_do_sync_transfer>:
  alt_sgdma_descriptor *desc)
{
  alt_u8 status;

  /* Wait for any pending transfers to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
  182554:	20c00317 	ldw	r3,12(r4)
  182558:	18800037 	ldwio	r2,0(r3)
  18255c:	1080040c 	andi	r2,r2,16
  182560:	103ffc1e 	bne	r2,zero,182554 <alt_avalon_sgdma_do_sync_transfer>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );


  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
  182564:	18c00404 	addi	r3,r3,16
  182568:	19800037 	ldwio	r6,0(r3)
  18256c:	00bff7c4 	movi	r2,-33
  182570:	308c703a 	and	r6,r6,r2
  182574:	19800035 	stwio	r6,0(r3)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
  182578:	20c00317 	ldw	r3,12(r4)
  18257c:	01803fc4 	movi	r6,255
  182580:	19800035 	stwio	r6,0(r3)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
  182584:	20c00317 	ldw	r3,12(r4)
  182588:	19400835 	stwio	r5,32(r3)
   * Set up SGDMA controller to:
   * - Disable interrupt generation
   * - Run once a valid descriptor is written to controller
   * - Stop on an error with any particular descriptor
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
  18258c:	20c00317 	ldw	r3,12(r4)
  182590:	18c00404 	addi	r3,r3,16
  182594:	19400037 	ldwio	r5,0(r3)
  182598:	29401814 	ori	r5,r5,96
  18259c:	19400035 	stwio	r5,0(r3)
    (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK |
     ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK | 
     IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base)) );

  /* Wait for the descriptor (chain) to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
  1825a0:	20c00317 	ldw	r3,12(r4)
  1825a4:	19400037 	ldwio	r5,0(r3)
  1825a8:	2940040c 	andi	r5,r5,16
  1825ac:	283ffc1e 	bne	r5,zero,1825a0 <alt_avalon_sgdma_do_sync_transfer+0x4c>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
  1825b0:	18c00404 	addi	r3,r3,16
  1825b4:	19400037 	ldwio	r5,0(r3)
  1825b8:	2884703a 	and	r2,r5,r2
  1825bc:	18800035 	stwio	r2,0(r3)
    (IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) &
     ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK) );

  /* Get & clear status register contents */
  status = IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base);
  1825c0:	20c00317 	ldw	r3,12(r4)
  1825c4:	18800037 	ldwio	r2,0(r3)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
  1825c8:	01003fc4 	movi	r4,255
  1825cc:	19000035 	stwio	r4,0(r3)

  return status;
}
  1825d0:	f800283a 	ret

001825d4 <alt_avalon_sgdma_register_callback>:
  alt_sgdma_dev *dev,
  alt_avalon_sgdma_callback callback,
  alt_u32 chain_control,
  void *context)
{
  dev->callback         = callback;
  1825d4:	21400915 	stw	r5,36(r4)
  dev->callback_context = context;
  1825d8:	21c00a15 	stw	r7,40(r4)
  dev->chain_control    = chain_control;
  1825dc:	21800b15 	stw	r6,44(r4)
  1825e0:	f800283a 	ret

001825e4 <alt_avalon_sgdma_start>:
 */
void alt_avalon_sgdma_start(alt_sgdma_dev *dev)
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  1825e4:	20800317 	ldw	r2,12(r4)
  1825e8:	10800404 	addi	r2,r2,16
  1825ec:	10c00037 	ldwio	r3,0(r2)
  control |= ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
  1825f0:	18c00814 	ori	r3,r3,32
  1825f4:	10c00035 	stwio	r3,0(r2)
  1825f8:	f800283a 	ret

001825fc <alt_avalon_sgdma_stop>:
 */
void alt_avalon_sgdma_stop(alt_sgdma_dev *dev)
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  1825fc:	20800317 	ldw	r2,12(r4)
  182600:	10800404 	addi	r2,r2,16
  182604:	11000037 	ldwio	r4,0(r2)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
  182608:	00fff7c4 	movi	r3,-33
  18260c:	20c6703a 	and	r3,r4,r3
  182610:	10c00035 	stwio	r3,0(r2)
  182614:	f800283a 	ret

00182618 <alt_avalon_sgdma_check_descriptor_status>:
 *   normally. Or, various error conditions defined in <errno.h>
 */
int alt_avalon_sgdma_check_descriptor_status(alt_sgdma_descriptor *desc)
{
  /* Errors take precedence */
  if( IORD_8DIRECT(&desc->status, 0) &
  182618:	208007a3 	ldbuio	r2,30(r4)
  18261c:	10801fcc 	andi	r2,r2,127
  182620:	1000041e 	bne	r2,zero,182634 <alt_avalon_sgdma_check_descriptor_status+0x1c>
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) {
    return -EIO;
  }

  if( IORD_8DIRECT(&desc->control, 0) &
  182624:	208007e3 	ldbuio	r2,31(r4)
  182628:	1080200c 	andi	r2,r2,128
  18262c:	1000031e 	bne	r2,zero,18263c <alt_avalon_sgdma_check_descriptor_status+0x24>
  182630:	f800283a 	ret
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_OVERFLOW_MSK |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) {
    return -EIO;
  182634:	00bffec4 	movi	r2,-5
  182638:	f800283a 	ret
  }

  if( IORD_8DIRECT(&desc->control, 0) &
      ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK) {
    return -EINPROGRESS;
  18263c:	00bfe244 	movi	r2,-119
  }

    return 0;
}
  182640:	f800283a 	ret

00182644 <alt_avalon_sgdma_open>:
 * Returns:
 * - Pointer to SGDMA device instance struct, or null if the device
 *   could not be opened.
 */
alt_sgdma_dev* alt_avalon_sgdma_open (const char* name)
{
  182644:	defffe04 	addi	sp,sp,-8
  alt_sgdma_dev* dev;

  dev = (alt_sgdma_dev*) alt_find_dev (name, &alt_sgdma_list);
  182648:	d1600304 	addi	r5,gp,-32756
 * Returns:
 * - Pointer to SGDMA device instance struct, or null if the device
 *   could not be opened.
 */
alt_sgdma_dev* alt_avalon_sgdma_open (const char* name)
{
  18264c:	dc000015 	stw	r16,0(sp)
  182650:	dfc00115 	stw	ra,4(sp)
  alt_sgdma_dev* dev;

  dev = (alt_sgdma_dev*) alt_find_dev (name, &alt_sgdma_list);
  182654:	0182b3c0 	call	182b3c <alt_find_dev>
  182658:	1021883a 	mov	r16,r2

  if (NULL == dev) {
  18265c:	1000071e 	bne	r2,zero,18267c <alt_avalon_sgdma_open+0x38>
  182660:	d0a00517 	ldw	r2,-32748(gp)
  182664:	10000226 	beq	r2,zero,182670 <alt_avalon_sgdma_open+0x2c>
  182668:	103ee83a 	callr	r2
  18266c:	00000106 	br	182674 <alt_avalon_sgdma_open+0x30>
  182670:	d0a23b04 	addi	r2,gp,-30484
    ALT_ERRNO = ENODEV;
  182674:	00c004c4 	movi	r3,19
  182678:	10c00015 	stw	r3,0(r2)
  }

  return dev;
}
  18267c:	8005883a 	mov	r2,r16
  182680:	dfc00117 	ldw	ra,4(sp)
  182684:	dc000017 	ldw	r16,0(sp)
  182688:	dec00204 	addi	sp,sp,8
  18268c:	f800283a 	ret

00182690 <alt_avalon_sgdma_enable_desc_poll>:
 */
void alt_avalon_sgdma_enable_desc_poll(alt_sgdma_dev *dev, alt_u32 frequency)
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  182690:	20c00317 	ldw	r3,12(r4)
  182694:	18c00404 	addi	r3,r3,16
  182698:	19000037 	ldwio	r4,0(r3)
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
  18269c:	00a00434 	movhi	r2,32784
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
            ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
  1826a0:	280a953a 	slli	r5,r5,20
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
  1826a4:	10bfffc4 	addi	r2,r2,-1
  1826a8:	2084703a 	and	r2,r4,r2
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
            ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
  1826ac:	295ffc2c 	andhi	r5,r5,32752
  1826b0:	29400134 	orhi	r5,r5,4
  1826b4:	288ab03a 	or	r5,r5,r2
  1826b8:	19400035 	stwio	r5,0(r3)
  1826bc:	f800283a 	ret

001826c0 <alt_avalon_sgdma_disable_desc_poll>:
 */
void alt_avalon_sgdma_disable_desc_poll(alt_sgdma_dev *dev)
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  1826c0:	20800317 	ldw	r2,12(r4)
  1826c4:	10800404 	addi	r2,r2,16
  1826c8:	11000037 	ldwio	r4,0(r2)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK;

  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
  1826cc:	00ffff34 	movhi	r3,65532
  1826d0:	18ffffc4 	addi	r3,r3,-1
  1826d4:	20c6703a 	and	r3,r4,r3
  1826d8:	10c00035 	stwio	r3,0(r2)
  1826dc:	f800283a 	ret

001826e0 <alt_avalon_sgdma_construct_descriptor_burst>:
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
  1826e0:	288007c3 	ldbu	r2,31(r5)
  int                   read_fixed,
  int                   write_fixed_or_sop,
  int                   read_burst,
  int                   write_burst,
  alt_u8                atlantic_channel)
{
  1826e4:	d8c00617 	ldw	r3,24(sp)
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
  1826e8:	10801fcc 	andi	r2,r2,127
  1826ec:	288007e5 	stbio	r2,31(r5)
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  1826f0:	3004d23a 	srli	r2,r6,8
  1826f4:	21800005 	stb	r6,0(r4)
  desc->write_addr               = write_addr;
  1826f8:	21c00205 	stb	r7,8(r4)
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  1826fc:	20800045 	stb	r2,1(r4)
  182700:	3004d43a 	srli	r2,r6,16
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  182704:	21400405 	stb	r5,16(r4)
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  182708:	300cd63a 	srli	r6,r6,24
  18270c:	20800085 	stb	r2,2(r4)
  desc->write_addr               = write_addr;
  182710:	3804d23a 	srli	r2,r7,8
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  182714:	218000c5 	stb	r6,3(r4)
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
  182718:	20000105 	stb	zero,4(r4)
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  18271c:	20800245 	stb	r2,9(r4)
  182720:	3804d43a 	srli	r2,r7,16
  182724:	380ed63a 	srli	r7,r7,24
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
  182728:	20000145 	stb	zero,5(r4)
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  18272c:	20800285 	stb	r2,10(r4)
  desc->next                     = (alt_u32 *) next;
  182730:	2804d23a 	srli	r2,r5,8
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  182734:	21c002c5 	stb	r7,11(r4)
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
  182738:	20000185 	stb	zero,6(r4)
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  18273c:	20800445 	stb	r2,17(r4)
  182740:	2804d43a 	srli	r2,r5,16
  182744:	280ad63a 	srli	r5,r5,24
  desc->read_addr_pad            = 0x0;
  182748:	200001c5 	stb	zero,7(r4)
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  18274c:	20800485 	stb	r2,18(r4)
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
  desc->next_pad                 = 0x0;
  desc->bytes_to_transfer        = length_or_eop;
  182750:	d880000b 	ldhu	r2,0(sp)
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  182754:	214004c5 	stb	r5,19(r4)
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
  182758:	20000305 	stb	zero,12(r4)
  desc->next_pad                 = 0x0;
  desc->bytes_to_transfer        = length_or_eop;
  18275c:	20800605 	stb	r2,24(r4)
  182760:	1004d23a 	srli	r2,r2,8

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
  182764:	20000345 	stb	zero,13(r4)
  182768:	20000385 	stb	zero,14(r4)
  desc->next_pad                 = 0x0;
  desc->bytes_to_transfer        = length_or_eop;
  18276c:	20800645 	stb	r2,25(r4)
  desc->actual_bytes_transferred = 0;
  desc->status                   = 0x0;

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
  182770:	d8800417 	ldw	r2,16(sp)

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
  182774:	200003c5 	stb	zero,15(r4)
  desc->next_pad                 = 0x0;
  182778:	20000505 	stb	zero,20(r4)
  18277c:	20000545 	stb	zero,21(r4)
  182780:	20000585 	stb	zero,22(r4)
  182784:	200005c5 	stb	zero,23(r4)
  desc->bytes_to_transfer        = length_or_eop;
  desc->actual_bytes_transferred = 0;
  182788:	20000705 	stb	zero,28(r4)
  18278c:	20000745 	stb	zero,29(r4)
  desc->status                   = 0x0;
  182790:	20000785 	stb	zero,30(r4)

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
  182794:	20800685 	stb	r2,26(r4)
  desc->write_burst              = write_burst;
  182798:	d8800517 	ldw	r2,20(sp)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
  18279c:	d9400117 	ldw	r5,4(sp)
  desc->actual_bytes_transferred = 0;
  desc->status                   = 0x0;

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
  desc->write_burst              = write_burst;
  1827a0:	208006c5 	stb	r2,27(r4)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
  1827a4:	d8800217 	ldw	r2,8(sp)
  1827a8:	280ac03a 	cmpne	r5,r5,zero
  1827ac:	297fe004 	addi	r5,r5,-128
  1827b0:	1004c03a 	cmpne	r2,r2,zero
  1827b4:	1004907a 	slli	r2,r2,1
  1827b8:	2884b03a 	or	r2,r5,r2
  1827bc:	d9400317 	ldw	r5,12(sp)
  1827c0:	280ac03a 	cmpne	r5,r5,zero
  1827c4:	280a90ba 	slli	r5,r5,2
  1827c8:	114ab03a 	or	r5,r2,r5
  1827cc:	18803fcc 	andi	r2,r3,255
  1827d0:	10000326 	beq	r2,zero,1827e0 <alt_avalon_sgdma_construct_descriptor_burst+0x100>
  1827d4:	18c003cc 	andi	r3,r3,15
  1827d8:	180490fa 	slli	r2,r3,3
  1827dc:	00000106 	br	1827e4 <alt_avalon_sgdma_construct_descriptor_burst+0x104>
  1827e0:	0005883a 	mov	r2,zero
  1827e4:	2884b03a 	or	r2,r5,r2
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to.
   */
  alt_dcache_flush(desc, sizeof(alt_sgdma_descriptor));
  1827e8:	01400804 	movi	r5,32
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
  1827ec:	208007c5 	stb	r2,31(r4)
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to.
   */
  alt_dcache_flush(desc, sizeof(alt_sgdma_descriptor));
  1827f0:	0182ac81 	jmpi	182ac8 <alt_dcache_flush>

001827f4 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>:
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed,
  int                   read_burst,
  int                   write_burst)
{
  1827f4:	defff804 	addi	sp,sp,-32
  alt_avalon_sgdma_construct_descriptor_burst(
  1827f8:	d8800c17 	ldw	r2,48(sp)
  1827fc:	d8000615 	stw	zero,24(sp)
  182800:	d8000115 	stw	zero,4(sp)
  182804:	d8800515 	stw	r2,20(sp)
  182808:	d8800b17 	ldw	r2,44(sp)
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed,
  int                   read_burst,
  int                   write_burst)
{
  18280c:	dfc00715 	stw	ra,28(sp)
  alt_avalon_sgdma_construct_descriptor_burst(
  182810:	d8800415 	stw	r2,16(sp)
  182814:	d8800a17 	ldw	r2,40(sp)
  182818:	d8800315 	stw	r2,12(sp)
  18281c:	d8800917 	ldw	r2,36(sp)
  182820:	d8800215 	stw	r2,8(sp)
  182824:	d880080b 	ldhu	r2,32(sp)
  182828:	d8800015 	stw	r2,0(sp)
  18282c:	01826e00 	call	1826e0 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    write_fixed,
    read_burst,
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in mem-to-mem mode
}
  182830:	dfc00717 	ldw	ra,28(sp)
  182834:	dec00804 	addi	sp,sp,32
  182838:	f800283a 	ret

0018283c <alt_avalon_sgdma_construct_mem_to_mem_desc>:
  alt_u32              *read_addr,
  alt_u32              *write_addr,
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed)
{
  18283c:	defffa04 	addi	sp,sp,-24
  alt_avalon_sgdma_construct_mem_to_mem_desc_burst(desc, next, read_addr, 
  182840:	d8800817 	ldw	r2,32(sp)
  182844:	d8000415 	stw	zero,16(sp)
  182848:	d8000315 	stw	zero,12(sp)
  18284c:	d8800215 	stw	r2,8(sp)
  182850:	d8800717 	ldw	r2,28(sp)
  alt_u32              *read_addr,
  alt_u32              *write_addr,
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed)
{
  182854:	dfc00515 	stw	ra,20(sp)
  alt_avalon_sgdma_construct_mem_to_mem_desc_burst(desc, next, read_addr, 
  182858:	d8800115 	stw	r2,4(sp)
  18285c:	d880060b 	ldhu	r2,24(sp)
  182860:	d8800015 	stw	r2,0(sp)
  182864:	01827f40 	call	1827f4 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>
    write_addr, length, read_fixed, write_fixed, 0, 0);
}
  182868:	dfc00517 	ldw	ra,20(sp)
  18286c:	dec00604 	addi	sp,sp,24
  182870:	f800283a 	ret

00182874 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>:
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed,
  int                   write_burst)
{
  182874:	defff804 	addi	sp,sp,-32
  alt_avalon_sgdma_construct_descriptor_burst(
  182878:	d8800917 	ldw	r2,36(sp)
  18287c:	39ffffcc 	andi	r7,r7,65535
  182880:	d9c00015 	stw	r7,0(sp)
  182884:	d8800515 	stw	r2,20(sp)
  182888:	d8800817 	ldw	r2,32(sp)
  18288c:	300f883a 	mov	r7,r6
  182890:	d8000615 	stw	zero,24(sp)
  182894:	d8000415 	stw	zero,16(sp)
  182898:	d8800315 	stw	r2,12(sp)
  18289c:	d8000215 	stw	zero,8(sp)
  1828a0:	d8000115 	stw	zero,4(sp)
  1828a4:	000d883a 	mov	r6,zero
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed,
  int                   write_burst)
{
  1828a8:	dfc00715 	stw	ra,28(sp)
  alt_avalon_sgdma_construct_descriptor_burst(
  1828ac:	01826e00 	call	1826e0 <alt_avalon_sgdma_construct_descriptor_burst>
    0x0,            // Read fixed: N/A in stream-to-mem mode
    write_fixed,
    0,              // Read_burst : N/A in stream-to-mem mode
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in stream-to-mem mode
}
  1828b0:	dfc00717 	ldw	ra,28(sp)
  1828b4:	dec00804 	addi	sp,sp,32
  1828b8:	f800283a 	ret

001828bc <alt_avalon_sgdma_construct_stream_to_mem_desc>:
  alt_sgdma_descriptor *desc,
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed)
{
  1828bc:	defffd04 	addi	sp,sp,-12
  alt_avalon_sgdma_construct_stream_to_mem_desc_burst(desc, next, write_addr, 
  1828c0:	d8800317 	ldw	r2,12(sp)
  1828c4:	d8000115 	stw	zero,4(sp)
  1828c8:	39ffffcc 	andi	r7,r7,65535
  1828cc:	d8800015 	stw	r2,0(sp)
  alt_sgdma_descriptor *desc,
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed)
{
  1828d0:	dfc00215 	stw	ra,8(sp)
  alt_avalon_sgdma_construct_stream_to_mem_desc_burst(desc, next, write_addr, 
  1828d4:	01828740 	call	182874 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>
    length_or_eop, write_fixed, 0);
}
  1828d8:	dfc00217 	ldw	ra,8(sp)
  1828dc:	dec00304 	addi	sp,sp,12
  1828e0:	f800283a 	ret

001828e4 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>:
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  int                   read_burst,
  alt_u8                atlantic_channel)
{
  1828e4:	defff804 	addi	sp,sp,-32
  alt_avalon_sgdma_construct_descriptor_burst(
  1828e8:	d8800c03 	ldbu	r2,48(sp)
  1828ec:	39ffffcc 	andi	r7,r7,65535
  1828f0:	d9c00015 	stw	r7,0(sp)
  1828f4:	d8800615 	stw	r2,24(sp)
  1828f8:	d8800b17 	ldw	r2,44(sp)
  1828fc:	d8000515 	stw	zero,20(sp)
  182900:	000f883a 	mov	r7,zero
  182904:	d8800415 	stw	r2,16(sp)
  182908:	d8800917 	ldw	r2,36(sp)
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  int                   read_burst,
  alt_u8                atlantic_channel)
{
  18290c:	dfc00715 	stw	ra,28(sp)
  alt_avalon_sgdma_construct_descriptor_burst(
  182910:	d8800315 	stw	r2,12(sp)
  182914:	d8800817 	ldw	r2,32(sp)
  182918:	d8800215 	stw	r2,8(sp)
  18291c:	d8800a17 	ldw	r2,40(sp)
  182920:	d8800115 	stw	r2,4(sp)
  182924:	01826e00 	call	1826e0 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    generate_sop,
    read_burst,
    0,                 // Write_burst : N/A in mem-to-stream mode
    atlantic_channel);
}
  182928:	dfc00717 	ldw	ra,28(sp)
  18292c:	dec00804 	addi	sp,sp,32
  182930:	f800283a 	ret

00182934 <alt_avalon_sgdma_construct_mem_to_stream_desc>:
  alt_u16               length,
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  alt_u8                atlantic_channel)
{
  182934:	defffa04 	addi	sp,sp,-24
  alt_avalon_sgdma_construct_mem_to_stream_desc_burst(desc, next, read_addr, 
  182938:	d8800903 	ldbu	r2,36(sp)
  18293c:	d8000315 	stw	zero,12(sp)
  182940:	39ffffcc 	andi	r7,r7,65535
  182944:	d8800415 	stw	r2,16(sp)
  182948:	d8800817 	ldw	r2,32(sp)
  alt_u16               length,
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  alt_u8                atlantic_channel)
{
  18294c:	dfc00515 	stw	ra,20(sp)
  alt_avalon_sgdma_construct_mem_to_stream_desc_burst(desc, next, read_addr, 
  182950:	d8800215 	stw	r2,8(sp)
  182954:	d8800717 	ldw	r2,28(sp)
  182958:	d8800115 	stw	r2,4(sp)
  18295c:	d8800617 	ldw	r2,24(sp)
  182960:	d8800015 	stw	r2,0(sp)
  182964:	01828e40 	call	1828e4 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>
    length, read_fixed, generate_sop, generate_eop, 0, atlantic_channel);

}
  182968:	dfc00517 	ldw	ra,20(sp)
  18296c:	dec00604 	addi	sp,sp,24
  182970:	f800283a 	ret

00182974 <alt_avalon_sgdma_construct_descriptor>:
  alt_u16               length_or_eop,
  int                   generate_eop,
  int                   read_fixed,
  int                   write_fixed_or_sop,
  alt_u8                atlantic_channel)
{
  182974:	defff804 	addi	sp,sp,-32
  alt_avalon_sgdma_construct_descriptor_burst(desc, next, read_addr, 
  182978:	d8800c03 	ldbu	r2,48(sp)
  18297c:	d8000515 	stw	zero,20(sp)
  182980:	d8000415 	stw	zero,16(sp)
  182984:	d8800615 	stw	r2,24(sp)
  182988:	d8800b17 	ldw	r2,44(sp)
  alt_u16               length_or_eop,
  int                   generate_eop,
  int                   read_fixed,
  int                   write_fixed_or_sop,
  alt_u8                atlantic_channel)
{
  18298c:	dfc00715 	stw	ra,28(sp)
  alt_avalon_sgdma_construct_descriptor_burst(desc, next, read_addr, 
  182990:	d8800315 	stw	r2,12(sp)
  182994:	d8800a17 	ldw	r2,40(sp)
  182998:	d8800215 	stw	r2,8(sp)
  18299c:	d8800917 	ldw	r2,36(sp)
  1829a0:	d8800115 	stw	r2,4(sp)
  1829a4:	d880080b 	ldhu	r2,32(sp)
  1829a8:	d8800015 	stw	r2,0(sp)
  1829ac:	01826e00 	call	1826e0 <alt_avalon_sgdma_construct_descriptor_burst>
    write_addr, length_or_eop, generate_eop, read_fixed, write_fixed_or_sop, 
    0, 0, atlantic_channel);
}
  1829b0:	dfc00717 	ldw	ra,28(sp)
  1829b4:	dec00804 	addi	sp,sp,32
  1829b8:	f800283a 	ret

001829bc <alt_avalon_sgdma_init>:

  /* 
   * Halt any current transactions (reset the device)
   * SW reset is written twice per SGDMA documentation 
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
  1829bc:	20c00317 	ldw	r3,12(r4)
 * This routine disables interrupts, future descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_avalon_sgdma_init (alt_sgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
  1829c0:	defffb04 	addi	sp,sp,-20
  1829c4:	dc800315 	stw	r18,12(sp)
  1829c8:	dc400215 	stw	r17,8(sp)
  1829cc:	dc000115 	stw	r16,4(sp)
  1829d0:	dfc00415 	stw	ra,16(sp)
  1829d4:	2021883a 	mov	r16,r4
  1829d8:	2823883a 	mov	r17,r5
  1829dc:	3025883a 	mov	r18,r6

  /* 
   * Halt any current transactions (reset the device)
   * SW reset is written twice per SGDMA documentation 
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
  1829e0:	00800074 	movhi	r2,1
  1829e4:	18800435 	stwio	r2,16(r3)
    ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
  1829e8:	20c00317 	ldw	r3,12(r4)
  1829ec:	18800435 	stwio	r2,16(r3)

  /*
   * Disable interrupts, halt future descriptor processing,
   * and clear status register content
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 0x0);
  1829f0:	20800317 	ldw	r2,12(r4)
  1829f4:	10000435 	stwio	zero,16(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
  1829f8:	20800317 	ldw	r2,12(r4)
  1829fc:	00c03fc4 	movi	r3,255
  182a00:	10c00035 	stwio	r3,0(r2)

  /* Register this instance of the SGDMA controller with HAL */
  alt_dev_llist_insert((alt_dev_llist*) dev, &alt_sgdma_list);
  182a04:	d1600304 	addi	r5,gp,-32756
  182a08:	0182ad00 	call	182ad0 <alt_dev_llist_insert>

  /* Install IRQ handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(ic_id, irq, alt_avalon_sgdma_irq, dev, 0x0);
  182a0c:	01800634 	movhi	r6,24
  182a10:	d8000015 	stw	zero,0(sp)
  182a14:	800f883a 	mov	r7,r16
  182a18:	31891f04 	addi	r6,r6,9340
  182a1c:	900b883a 	mov	r5,r18
  182a20:	8809883a 	mov	r4,r17
  182a24:	0182bb40 	call	182bb4 <alt_ic_isr_register>
#else
  alt_irq_register(irq, dev, alt_avalon_sgdma_irq);
#endif  
}
  182a28:	dfc00417 	ldw	ra,16(sp)
  182a2c:	dc800317 	ldw	r18,12(sp)
  182a30:	dc400217 	ldw	r17,8(sp)
  182a34:	dc000117 	ldw	r16,4(sp)
  182a38:	dec00504 	addi	sp,sp,20
  182a3c:	f800283a 	ret

00182a40 <alt_busy_sleep>:
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
  182a40:	014666b4 	movhi	r5,6554
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
  182a44:	defffe04 	addi	sp,sp,-8
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
  182a48:	29666644 	addi	r5,r5,-26215
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
  182a4c:	dc000015 	stw	r16,0(sp)
  182a50:	dfc00115 	stw	ra,4(sp)
  182a54:	2021883a 	mov	r16,r4
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
  182a58:	0182dd80 	call	182dd8 <__udivsi3>
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  182a5c:	10001026 	beq	r2,zero,182aa0 <alt_busy_sleep+0x60>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
  182a60:	01600034 	movhi	r5,32768
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
  182a64:	013999b4 	movhi	r4,58982
  182a68:	0007883a 	mov	r3,zero
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
  182a6c:	297fffc4 	addi	r5,r5,-1
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
  182a70:	211999c4 	addi	r4,r4,26215
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
  182a74:	297fffc4 	addi	r5,r5,-1
  182a78:	283ffe1e 	bne	r5,zero,182a74 <alt_busy_sleep+0x34>
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
  182a7c:	18c00044 	addi	r3,r3,1
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
  182a80:	8121883a 	add	r16,r16,r4
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
  182a84:	18bffb16 	blt	r3,r2,182a74 <alt_busy_sleep+0x34>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
  182a88:	01400144 	movi	r5,5
  182a8c:	8009883a 	mov	r4,r16
  182a90:	0181de80 	call	181de8 <__mulsi3>
  182a94:	10bfffc4 	addi	r2,r2,-1
  182a98:	103ffe1e 	bne	r2,zero,182a94 <alt_busy_sleep+0x54>
  182a9c:	00000506 	br	182ab4 <alt_busy_sleep+0x74>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
  182aa0:	01400144 	movi	r5,5
  182aa4:	8009883a 	mov	r4,r16
  182aa8:	0181de80 	call	181de8 <__mulsi3>
  182aac:	10bfffc4 	addi	r2,r2,-1
  182ab0:	00bffe16 	blt	zero,r2,182aac <alt_busy_sleep+0x6c>
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
}
  182ab4:	0005883a 	mov	r2,zero
  182ab8:	dfc00117 	ldw	ra,4(sp)
  182abc:	dc000017 	ldw	r16,0(sp)
  182ac0:	dec00204 	addi	sp,sp,8
  182ac4:	f800283a 	ret

00182ac8 <alt_dcache_flush>:
 *
 * Any dirty lines in the data cache are written back to memory.
 */

void alt_dcache_flush (void* start, alt_u32 len)
{
  182ac8:	f800283a 	ret

00182acc <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
  182acc:	f800283a 	ret

00182ad0 <alt_dev_llist_insert>:
{
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  182ad0:	20000226 	beq	r4,zero,182adc <alt_dev_llist_insert+0xc>
  182ad4:	20800217 	ldw	r2,8(r4)
  182ad8:	1000101e 	bne	r2,zero,182b1c <alt_dev_llist_insert+0x4c>
  182adc:	d0a00517 	ldw	r2,-32748(gp)
  182ae0:	10000926 	beq	r2,zero,182b08 <alt_dev_llist_insert+0x38>
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
  182ae4:	deffff04 	addi	sp,sp,-4
  182ae8:	dfc00015 	stw	ra,0(sp)
  182aec:	103ee83a 	callr	r2
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  {
    ALT_ERRNO = EINVAL;
  182af0:	00c00584 	movi	r3,22
  182af4:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
  182af8:	00bffa84 	movi	r2,-22
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
}
  182afc:	dfc00017 	ldw	ra,0(sp)
  182b00:	dec00104 	addi	sp,sp,4
  182b04:	f800283a 	ret
  182b08:	d0a23b04 	addi	r2,gp,-30484
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  {
    ALT_ERRNO = EINVAL;
  182b0c:	00c00584 	movi	r3,22
  182b10:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
  182b14:	00bffa84 	movi	r2,-22
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
}
  182b18:	f800283a 	ret

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  entry->next     = list->next;
  182b1c:	28800017 	ldw	r2,0(r5)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  182b20:	21400115 	stw	r5,4(r4)
  entry->next     = list->next;
  182b24:	20800015 	stw	r2,0(r4)

  list->next->previous = entry;
  182b28:	28800017 	ldw	r2,0(r5)
  182b2c:	11000115 	stw	r4,4(r2)
  list->next           = entry;
  182b30:	29000015 	stw	r4,0(r5)
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
  182b34:	0005883a 	mov	r2,zero
  182b38:	f800283a 	ret

00182b3c <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
  182b3c:	defffb04 	addi	sp,sp,-20
  182b40:	dcc00315 	stw	r19,12(sp)
  182b44:	dc800215 	stw	r18,8(sp)
  182b48:	dc400115 	stw	r17,4(sp)
  182b4c:	dc000015 	stw	r16,0(sp)
  182b50:	dfc00415 	stw	ra,16(sp)
  182b54:	2027883a 	mov	r19,r4
  182b58:	2823883a 	mov	r17,r5
  alt_dev* next = (alt_dev*) llist->next;
  182b5c:	2c000017 	ldw	r16,0(r5)
  alt_32 len;

  len  = strlen(name) + 1;
  182b60:	0181ef00 	call	181ef0 <strlen>
  182b64:	14800044 	addi	r18,r2,1
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
  182b68:	84400726 	beq	r16,r17,182b88 <alt_find_dev+0x4c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
  182b6c:	81000217 	ldw	r4,8(r16)
  182b70:	900d883a 	mov	r6,r18
  182b74:	980b883a 	mov	r5,r19
  182b78:	0182cb00 	call	182cb0 <memcmp>
  182b7c:	10000426 	beq	r2,zero,182b90 <alt_find_dev+0x54>
    {
      /* match found */

      return next;
    }
    next = (alt_dev*) next->llist.next;
  182b80:	84000017 	ldw	r16,0(r16)
  182b84:	003ff806 	br	182b68 <alt_find_dev+0x2c>
  }
  
  /* No match found */
  
  return NULL;
  182b88:	0005883a 	mov	r2,zero
  182b8c:	00000106 	br	182b94 <alt_find_dev+0x58>
  182b90:	8005883a 	mov	r2,r16
}
  182b94:	dfc00417 	ldw	ra,16(sp)
  182b98:	dcc00317 	ldw	r19,12(sp)
  182b9c:	dc800217 	ldw	r18,8(sp)
  182ba0:	dc400117 	ldw	r17,4(sp)
  182ba4:	dc000017 	ldw	r16,0(sp)
  182ba8:	dec00504 	addi	sp,sp,20
  182bac:	f800283a 	ret

00182bb0 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
  182bb0:	f800283a 	ret

00182bb4 <alt_ic_isr_register>:
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
  182bb4:	0182c401 	jmpi	182c40 <alt_iic_isr_register>

00182bb8 <alt_ic_irq_enable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  182bb8:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  182bbc:	00bfff84 	movi	r2,-2
  182bc0:	2084703a 	and	r2,r4,r2
  182bc4:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active |= (1 << id);
  182bc8:	00c00044 	movi	r3,1
  182bcc:	d0a23f17 	ldw	r2,-30468(gp)
  182bd0:	194a983a 	sll	r5,r3,r5
  182bd4:	288ab03a 	or	r5,r5,r2
  182bd8:	d1623f15 	stw	r5,-30468(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  182bdc:	d0a23f17 	ldw	r2,-30468(gp)
  182be0:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  182be4:	2001703a 	wrctl	status,r4
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_enable(irq);
}
  182be8:	0005883a 	mov	r2,zero
  182bec:	f800283a 	ret

00182bf0 <alt_ic_irq_disable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  182bf0:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  182bf4:	00bfff84 	movi	r2,-2
  182bf8:	2084703a 	and	r2,r4,r2
  182bfc:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active &= ~(1 << id);
  182c00:	00ffff84 	movi	r3,-2
  182c04:	d0a23f17 	ldw	r2,-30468(gp)
  182c08:	194a183a 	rol	r5,r3,r5
  182c0c:	288a703a 	and	r5,r5,r2
  182c10:	d1623f15 	stw	r5,-30468(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  182c14:	d0a23f17 	ldw	r2,-30468(gp)
  182c18:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  182c1c:	2001703a 	wrctl	status,r4
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_disable(irq);
}
  182c20:	0005883a 	mov	r2,zero
  182c24:	f800283a 	ret

00182c28 <alt_ic_irq_enabled>:
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
  182c28:	000730fa 	rdctl	r3,ienable

    return (irq_enabled & (1 << irq)) ? 1: 0;
  182c2c:	00800044 	movi	r2,1
  182c30:	1144983a 	sll	r2,r2,r5
  182c34:	10c4703a 	and	r2,r2,r3
}
  182c38:	1004c03a 	cmpne	r2,r2,zero
  182c3c:	f800283a 	ret

00182c40 <alt_iic_isr_register>:
{
  int rc = -EINVAL;  
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  alt_irq_context status;

  if (id < ALT_NIRQ)
  182c40:	00c007c4 	movi	r3,31
  182c44:	19401616 	blt	r3,r5,182ca0 <alt_iic_isr_register+0x60>
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  182c48:	defffe04 	addi	sp,sp,-8
  182c4c:	dfc00115 	stw	ra,4(sp)
  182c50:	dc000015 	stw	r16,0(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  182c54:	0021303a 	rdctl	r16,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  182c58:	00ffff84 	movi	r3,-2
  182c5c:	80c6703a 	and	r3,r16,r3
  182c60:	1801703a 	wrctl	status,r3
     * state.
     */

    status = alt_irq_disable_all();

    alt_irq[id].handler = isr;
  182c64:	280490fa 	slli	r2,r5,3
  182c68:	00c00634 	movhi	r3,24
  182c6c:	18d1f604 	addi	r3,r3,18392
  182c70:	1885883a 	add	r2,r3,r2
  182c74:	11800015 	stw	r6,0(r2)
    alt_irq[id].context = isr_context;
  182c78:	11c00115 	stw	r7,4(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
  182c7c:	30000226 	beq	r6,zero,182c88 <alt_iic_isr_register+0x48>
  182c80:	0182bb80 	call	182bb8 <alt_ic_irq_enable>
  182c84:	00000106 	br	182c8c <alt_iic_isr_register+0x4c>
  182c88:	0182bf00 	call	182bf0 <alt_ic_irq_disable>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  182c8c:	8001703a 	wrctl	status,r16

    alt_irq_enable_all(status);
  }

  return rc; 
}
  182c90:	dfc00117 	ldw	ra,4(sp)
  182c94:	dc000017 	ldw	r16,0(sp)
  182c98:	dec00204 	addi	sp,sp,8
  182c9c:	f800283a 	ret
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  int rc = -EINVAL;  
  182ca0:	00bffa84 	movi	r2,-22
  182ca4:	f800283a 	ret

00182ca8 <altera_nios2_gen2_irq_init>:
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
  182ca8:	000170fa 	wrctl	ienable,zero
  182cac:	f800283a 	ret

00182cb0 <memcmp>:
  182cb0:	218d883a 	add	r6,r4,r6
  182cb4:	21800826 	beq	r4,r6,182cd8 <memcmp+0x28>
  182cb8:	20800003 	ldbu	r2,0(r4)
  182cbc:	28c00003 	ldbu	r3,0(r5)
  182cc0:	10c00226 	beq	r2,r3,182ccc <memcmp+0x1c>
  182cc4:	10c5c83a 	sub	r2,r2,r3
  182cc8:	f800283a 	ret
  182ccc:	21000044 	addi	r4,r4,1
  182cd0:	29400044 	addi	r5,r5,1
  182cd4:	003ff706 	br	182cb4 <memcmp+0x4>
  182cd8:	0005883a 	mov	r2,zero
  182cdc:	f800283a 	ret

00182ce0 <__divsi3>:
  182ce0:	20001b16 	blt	r4,zero,182d50 <__divsi3+0x70>
  182ce4:	000f883a 	mov	r7,zero
  182ce8:	28001616 	blt	r5,zero,182d44 <__divsi3+0x64>
  182cec:	200d883a 	mov	r6,r4
  182cf0:	29001a2e 	bgeu	r5,r4,182d5c <__divsi3+0x7c>
  182cf4:	00800804 	movi	r2,32
  182cf8:	00c00044 	movi	r3,1
  182cfc:	00000106 	br	182d04 <__divsi3+0x24>
  182d00:	10000d26 	beq	r2,zero,182d38 <__divsi3+0x58>
  182d04:	294b883a 	add	r5,r5,r5
  182d08:	10bfffc4 	addi	r2,r2,-1
  182d0c:	18c7883a 	add	r3,r3,r3
  182d10:	293ffb36 	bltu	r5,r4,182d00 <__divsi3+0x20>
  182d14:	0005883a 	mov	r2,zero
  182d18:	18000726 	beq	r3,zero,182d38 <__divsi3+0x58>
  182d1c:	0005883a 	mov	r2,zero
  182d20:	31400236 	bltu	r6,r5,182d2c <__divsi3+0x4c>
  182d24:	314dc83a 	sub	r6,r6,r5
  182d28:	10c4b03a 	or	r2,r2,r3
  182d2c:	1806d07a 	srli	r3,r3,1
  182d30:	280ad07a 	srli	r5,r5,1
  182d34:	183ffa1e 	bne	r3,zero,182d20 <__divsi3+0x40>
  182d38:	38000126 	beq	r7,zero,182d40 <__divsi3+0x60>
  182d3c:	0085c83a 	sub	r2,zero,r2
  182d40:	f800283a 	ret
  182d44:	014bc83a 	sub	r5,zero,r5
  182d48:	39c0005c 	xori	r7,r7,1
  182d4c:	003fe706 	br	182cec <__divsi3+0xc>
  182d50:	0109c83a 	sub	r4,zero,r4
  182d54:	01c00044 	movi	r7,1
  182d58:	003fe306 	br	182ce8 <__divsi3+0x8>
  182d5c:	00c00044 	movi	r3,1
  182d60:	003fee06 	br	182d1c <__divsi3+0x3c>

00182d64 <__modsi3>:
  182d64:	20001716 	blt	r4,zero,182dc4 <__modsi3+0x60>
  182d68:	000f883a 	mov	r7,zero
  182d6c:	2005883a 	mov	r2,r4
  182d70:	28001216 	blt	r5,zero,182dbc <__modsi3+0x58>
  182d74:	2900162e 	bgeu	r5,r4,182dd0 <__modsi3+0x6c>
  182d78:	01800804 	movi	r6,32
  182d7c:	00c00044 	movi	r3,1
  182d80:	00000106 	br	182d88 <__modsi3+0x24>
  182d84:	30000a26 	beq	r6,zero,182db0 <__modsi3+0x4c>
  182d88:	294b883a 	add	r5,r5,r5
  182d8c:	31bfffc4 	addi	r6,r6,-1
  182d90:	18c7883a 	add	r3,r3,r3
  182d94:	293ffb36 	bltu	r5,r4,182d84 <__modsi3+0x20>
  182d98:	18000526 	beq	r3,zero,182db0 <__modsi3+0x4c>
  182d9c:	1806d07a 	srli	r3,r3,1
  182da0:	11400136 	bltu	r2,r5,182da8 <__modsi3+0x44>
  182da4:	1145c83a 	sub	r2,r2,r5
  182da8:	280ad07a 	srli	r5,r5,1
  182dac:	183ffb1e 	bne	r3,zero,182d9c <__modsi3+0x38>
  182db0:	38000126 	beq	r7,zero,182db8 <__modsi3+0x54>
  182db4:	0085c83a 	sub	r2,zero,r2
  182db8:	f800283a 	ret
  182dbc:	014bc83a 	sub	r5,zero,r5
  182dc0:	003fec06 	br	182d74 <__modsi3+0x10>
  182dc4:	0109c83a 	sub	r4,zero,r4
  182dc8:	01c00044 	movi	r7,1
  182dcc:	003fe706 	br	182d6c <__modsi3+0x8>
  182dd0:	00c00044 	movi	r3,1
  182dd4:	003ff106 	br	182d9c <__modsi3+0x38>

00182dd8 <__udivsi3>:
  182dd8:	200d883a 	mov	r6,r4
  182ddc:	2900152e 	bgeu	r5,r4,182e34 <__udivsi3+0x5c>
  182de0:	28001416 	blt	r5,zero,182e34 <__udivsi3+0x5c>
  182de4:	00800804 	movi	r2,32
  182de8:	00c00044 	movi	r3,1
  182dec:	00000206 	br	182df8 <__udivsi3+0x20>
  182df0:	10000e26 	beq	r2,zero,182e2c <__udivsi3+0x54>
  182df4:	28000516 	blt	r5,zero,182e0c <__udivsi3+0x34>
  182df8:	294b883a 	add	r5,r5,r5
  182dfc:	10bfffc4 	addi	r2,r2,-1
  182e00:	18c7883a 	add	r3,r3,r3
  182e04:	293ffa36 	bltu	r5,r4,182df0 <__udivsi3+0x18>
  182e08:	18000826 	beq	r3,zero,182e2c <__udivsi3+0x54>
  182e0c:	0005883a 	mov	r2,zero
  182e10:	31400236 	bltu	r6,r5,182e1c <__udivsi3+0x44>
  182e14:	314dc83a 	sub	r6,r6,r5
  182e18:	10c4b03a 	or	r2,r2,r3
  182e1c:	1806d07a 	srli	r3,r3,1
  182e20:	280ad07a 	srli	r5,r5,1
  182e24:	183ffa1e 	bne	r3,zero,182e10 <__udivsi3+0x38>
  182e28:	f800283a 	ret
  182e2c:	0005883a 	mov	r2,zero
  182e30:	f800283a 	ret
  182e34:	00c00044 	movi	r3,1
  182e38:	003ff406 	br	182e0c <__udivsi3+0x34>

00182e3c <__umodsi3>:
  182e3c:	2005883a 	mov	r2,r4
  182e40:	2900122e 	bgeu	r5,r4,182e8c <__umodsi3+0x50>
  182e44:	28001116 	blt	r5,zero,182e8c <__umodsi3+0x50>
  182e48:	01800804 	movi	r6,32
  182e4c:	00c00044 	movi	r3,1
  182e50:	00000206 	br	182e5c <__umodsi3+0x20>
  182e54:	30000c26 	beq	r6,zero,182e88 <__umodsi3+0x4c>
  182e58:	28000516 	blt	r5,zero,182e70 <__umodsi3+0x34>
  182e5c:	294b883a 	add	r5,r5,r5
  182e60:	31bfffc4 	addi	r6,r6,-1
  182e64:	18c7883a 	add	r3,r3,r3
  182e68:	293ffa36 	bltu	r5,r4,182e54 <__umodsi3+0x18>
  182e6c:	18000626 	beq	r3,zero,182e88 <__umodsi3+0x4c>
  182e70:	1806d07a 	srli	r3,r3,1
  182e74:	11400136 	bltu	r2,r5,182e7c <__umodsi3+0x40>
  182e78:	1145c83a 	sub	r2,r2,r5
  182e7c:	280ad07a 	srli	r5,r5,1
  182e80:	183ffb1e 	bne	r3,zero,182e70 <__umodsi3+0x34>
  182e84:	f800283a 	ret
  182e88:	f800283a 	ret
  182e8c:	00c00044 	movi	r3,1
  182e90:	003ff706 	br	182e70 <__umodsi3+0x34>
