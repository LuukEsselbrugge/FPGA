
barcode.elf:     file format elf32-littlenios2
barcode.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x0018014c

Program Header:
    LOAD off    0x00001000 vaddr 0x00180000 paddr 0x00180000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00180020 paddr 0x00180020 align 2**12
         filesz 0x000021ac memsz 0x000021ac flags r-x
    LOAD off    0x000031cc vaddr 0x001821cc paddr 0x00182a88 align 2**12
         filesz 0x000008bc memsz 0x000008bc flags rw-
    LOAD off    0x00004344 vaddr 0x00183344 paddr 0x00183344 align 2**12
         filesz 0x00000000 memsz 0x00000628 flags rw-
    LOAD off    0x00004000 vaddr 0x00008000 paddr 0x0018396c align 2**12
         filesz 0x00000080 memsz 0x00000080 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00180000  00180000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   0000012c  00180020  00180020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00001f54  0018014c  0018014c  0000114c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       0000012c  001820a0  001820a0  000030a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       000008bc  001821cc  00182a88  000031cc  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00000628  00183344  00183344  00004344  2**2
                  ALLOC, SMALL_DATA
  6 .VideoRAM     00000000  00000000  00000000  00004080  2**0
                  CONTENTS
  7 .descriptor_memory 00000080  00008000  0018396c  00004000  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  8 .onchip_memory 00000000  001839ec  001839ec  00004080  2**0
                  CONTENTS
  9 .comment      00000023  00000000  00000000  00004080  2**0
                  CONTENTS, READONLY
 10 .debug_aranges 00000520  00000000  00000000  000040a8  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   00007071  00000000  00000000  000045c8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 00002737  00000000  00000000  0000b639  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00002a68  00000000  00000000  0000dd70  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00000978  00000000  00000000  000107d8  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    000019ac  00000000  00000000  00011150  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    00002b44  00000000  00000000  00012afc  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_alt_sim_info 00000040  00000000  00000000  00015640  2**2
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_ranges 00000428  00000000  00000000  00015680  2**3
                  CONTENTS, READONLY, DEBUGGING
 19 .thread_model 00000003  00000000  00000000  0001775a  2**0
                  CONTENTS, READONLY
 20 .cpu          00000005  00000000  00000000  0001775d  2**0
                  CONTENTS, READONLY
 21 .qsys         00000001  00000000  00000000  00017762  2**0
                  CONTENTS, READONLY
 22 .simulation_enabled 00000001  00000000  00000000  00017763  2**0
                  CONTENTS, READONLY
 23 .stderr_dev   00000009  00000000  00000000  00017764  2**0
                  CONTENTS, READONLY
 24 .stdin_dev    00000009  00000000  00000000  0001776d  2**0
                  CONTENTS, READONLY
 25 .stdout_dev   00000009  00000000  00000000  00017776  2**0
                  CONTENTS, READONLY
 26 .sopc_system_name 00000013  00000000  00000000  0001777f  2**0
                  CONTENTS, READONLY
 27 .quartus_project_dir 0000001e  00000000  00000000  00017792  2**0
                  CONTENTS, READONLY
 28 .jdi          0000587f  00000000  00000000  000177b0  2**0
                  CONTENTS, READONLY
 29 .sopcinfo     0008ba38  00000000  00000000  0001d02f  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00180000 l    d  .entry	00000000 .entry
00180020 l    d  .exceptions	00000000 .exceptions
0018014c l    d  .text	00000000 .text
001820a0 l    d  .rodata	00000000 .rodata
001821cc l    d  .rwdata	00000000 .rwdata
00183344 l    d  .bss	00000000 .bss
00000000 l    d  .VideoRAM	00000000 .VideoRAM
00008000 l    d  .descriptor_memory	00000000 .descriptor_memory
001839ec l    d  .onchip_memory	00000000 .onchip_memory
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../barcode_bsp//obj/HAL/src/crt0.o
00180184 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_exception_entry.o
00180094 l       .exceptions	00000000 alt_exception_unknown
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 main.c
00000000 l    df *ABS*	00000000 network.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 putchar.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 vfprintf.c
00180b3c l     F .text	0000006c print_repeat
00000000 l    df *ABS*	00000000 fvwrite_small_dev.c
00000000 l    df *ABS*	00000000 impure.c
0018292c l     O .rwdata	000000e0 impure_data
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 lib2-mul.c
00000000 l    df *ABS*	00000000 alt_load.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_printf.c
00000000 l    df *ABS*	00000000 alt_putchar.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
00182a3c l     O .rwdata	00000030 sgdma_rx
00182a0c l     O .rwdata	00000030 sgdma_tx
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_sgdma.c
0018183c l     F .text	0000005c alt_avalon_sgdma_irq
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_dcache_flush.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 memcmp.c
00180b04 g     F .text	0000001c putchar
00181568 g     F .text	0000002c alt_main
001806dc g     F .text	000000c8 rx_ethernet_isr
0018386c g     O .bss	00000100 alt_irq
00182a88 g       *ABS*	00000000 __flash_rwdata_start
00180240 g     F .text	000002cc showText
00180ab0 g     F .text	0000004c printf
00181914 g     F .text	00000080 alt_avalon_sgdma_do_sync_transfer
00181aa0 g     F .text	00000114 alt_avalon_sgdma_construct_descriptor_burst
00182a74 g     O .rwdata	00000004 jtag_uart
00182068 g     F .text	00000008 altera_nios2_gen2_irq_init
00180000 g     F .entry	0000000c __reset
00181c34 g     F .text	00000048 alt_avalon_sgdma_construct_stream_to_mem_desc_burst
00180020 g       *ABS*	00000000 __flash_exceptions_start
00183358 g     O .bss	00000004 errno
00183360 g     O .bss	00000004 alt_argv
0018aa6c g       *ABS*	00000000 _gp
0018174c g     F .text	00000004 usleep
0018336c g     O .bss	00000100 charcode
00000000 g       *ABS*	00000000 __alt_mem_VideoRAM
00183344 g     O .bss	00000004 actualCount
00180afc g     F .text	00000008 _putchar_r
00181efc g     F .text	00000074 alt_find_dev
00180a4c g     F .text	00000028 memcpy
00181ca4 g     F .text	00000050 alt_avalon_sgdma_construct_mem_to_stream_desc_burst
00180a74 g     F .text	0000003c _printf_r
001813a4 g     F .text	00000064 .hidden __udivsi3
001801a0 g     F .text	000000a0 drawChars
001819bc g     F .text	0000001c alt_avalon_sgdma_stop
00181e88 g     F .text	00000004 alt_dcache_flush
00182a6c g     O .rwdata	00000004 _global_impure_ptr
0018396c g       *ABS*	00000000 __bss_end
00182000 g     F .text	00000068 alt_iic_isr_register
00181898 g     F .text	0000007c alt_avalon_sgdma_do_async_transfer
00008000 g     O .descriptor_memory	00000020 rx_descriptor_end
00181fe8 g     F .text	00000018 alt_ic_irq_enabled
00008000 g       *ABS*	00000000 __alt_mem_descriptor_memory
00183368 g     O .bss	00000004 alt_irq_active
0018252c g     O .rwdata	00000400 tx_frame
001800ec g     F .exceptions	00000060 alt_irq_handler
001819d8 g     F .text	0000002c alt_avalon_sgdma_check_descriptor_status
00181e8c g     F .text	00000004 alt_dcache_flush_all
00008020 g     O .descriptor_memory	00000020 rx_descriptor
00182a88 g       *ABS*	00000000 __ram_rwdata_end
00180000 g       *ABS*	00000000 __alt_mem_onchip_memory
001821cc g     O .rwdata	00000360 charTemplate
00181750 g     F .text	00000060 write
00181a50 g     F .text	00000030 alt_avalon_sgdma_enable_desc_poll
001811fc g     F .text	00000058 _putc_r
001821cc g       *ABS*	00000000 __ram_rodata_end
00181408 g     F .text	00000058 .hidden __umodsi3
00181cf4 g     F .text	00000040 alt_avalon_sgdma_construct_mem_to_stream_desc
00181994 g     F .text	00000010 alt_avalon_sgdma_register_callback
00183348 g     O .bss	00000004 barwidth
001839ec g       *ABS*	00000000 end
001cb000 g       *ABS*	00000000 __alt_stack_pointer
00181a80 g     F .text	00000020 alt_avalon_sgdma_disable_desc_poll
00181808 g     F .text	00000034 altera_avalon_jtag_uart_write
00181bfc g     F .text	00000038 alt_avalon_sgdma_construct_mem_to_mem_desc
00180ba8 g     F .text	0000052c ___vfprintf_internal_r
00181c7c g     F .text	00000028 alt_avalon_sgdma_construct_stream_to_mem_desc
00181594 g     F .text	00000170 alt_printf
00180918 g     F .text	00000004 refresh_ethernet
0018014c g     F .text	0000003c _start
0018334c g     O .bss	00000004 sgdma_tx_dev
00181a04 g     F .text	0000004c alt_avalon_sgdma_open
00183350 g     O .bss	00000004 text_length
001817d0 g     F .text	00000038 alt_sys_init
00181460 g     F .text	00000028 .hidden __mulsi3
001821cc g       *ABS*	00000000 __ram_rwdata_start
001820a0 g       *ABS*	00000000 __ram_rodata_start
0018050c g     F .text	00000168 scanBarcode
00181e00 g     F .text	00000088 alt_busy_sleep
00182070 g     F .text	00000030 memcmp
001839ec g       *ABS*	00000000 __alt_stack_base
00181e90 g     F .text	0000006c alt_dev_llist_insert
001819a4 g     F .text	00000018 alt_avalon_sgdma_start
001810f0 g     F .text	000000b8 __sfvwrite_small_dev
00183344 g       *ABS*	00000000 __bss_start
001806a8 g     F .text	00000034 main
0018335c g     O .bss	00000004 alt_envp
00182a78 g     O .rwdata	00000008 alt_sgdma_list
00182a80 g     O .rwdata	00000004 alt_errno
00008060 g     O .descriptor_memory	00000020 tx_descriptor
0018346c g     O .bss	00000400 rx_frame
001811a8 g     F .text	00000054 putc
001812ac g     F .text	00000084 .hidden __divsi3
00180930 g     F .text	00000068 transmit
001820a0 g       *ABS*	00000000 __flash_rodata_start
001817b0 g     F .text	00000020 alt_irq_init
00181254 g     F .text	00000058 _write_r
00182a70 g     O .rwdata	00000004 _impure_ptr
00183364 g     O .bss	00000004 alt_argc
00180020 g       .exceptions	00000000 alt_irq_entry
0018091c g     F .text	00000014 tx_char
001807a4 g     F .text	00000174 setup
00180020 g       *ABS*	00000000 __ram_exceptions_start
00181f74 g     F .text	00000004 alt_ic_isr_register
00182a88 g       *ABS*	00000000 _edata
001839ec g       *ABS*	00000000 _end
0018014c g       *ABS*	00000000 __ram_exceptions_end
00180188 g     F .text	00000018 clearText
00180998 g     F .text	000000b4 tx_ethernet_isr
00181fb0 g     F .text	00000038 alt_ic_irq_disable
00008040 g     O .descriptor_memory	00000020 tx_descriptor_end
00181d34 g     F .text	00000048 alt_avalon_sgdma_construct_descriptor
00181330 g     F .text	00000074 .hidden __modsi3
001cb000 g       *ABS*	00000000 __alt_data_end
00180020 g     F .exceptions	00000000 alt_exception
00183354 g     O .bss	00000004 sgdma_rx_dev
00180674 g     F .text	00000034 callback
0018000c g       .entry	00000000 _exit
00180b20 g     F .text	0000001c strlen
00181704 g     F .text	00000048 alt_putchar
00181f70 g     F .text	00000004 alt_icache_flush_all
00182a84 g     O .rwdata	00000004 alt_priority_mask
00181f78 g     F .text	00000038 alt_ic_irq_enable
001810d4 g     F .text	0000001c __vfprintf_internal
00181bb4 g     F .text	00000048 alt_avalon_sgdma_construct_mem_to_mem_desc_burst
00181488 g     F .text	000000e0 alt_load
00181d7c g     F .text	00000084 alt_avalon_sgdma_init



Disassembly of section .entry:

00180000 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
  180000:	00400634 	movhi	at,24
    ori r1, r1, %lo(_start)
  180004:	08405314 	ori	at,at,332
    jmp r1
  180008:	0800683a 	jmp	at

0018000c <_exit>:
	...

Disassembly of section .exceptions:

00180020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
  180020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
  180024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
  180028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
  18002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
  180030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
  180034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
  180038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
  18003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
  180040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
  180044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
  180048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
  18004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
  180050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
  180054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
  180058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
  18005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
  180060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
  180064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
  180068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
  18006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
  180070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
  180074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
  180078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
  18007c:	10000326 	beq	r2,zero,18008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
  180080:	20000226 	beq	r4,zero,18008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
  180084:	01800ec0 	call	1800ec <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
  180088:	00000306 	br	180098 <alt_exception_unknown+0x4>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
  18008c:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
  180090:	e8bfff17 	ldw	r2,-4(ea)

00180094 <alt_exception_unknown>:
#ifdef NIOS2_HAS_DEBUG_STUB
       /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
  180094:	003da03a 	break	0
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
  180098:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
  18009c:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
  1800a0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
  1800a4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
  1800a8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
  1800ac:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
  1800b0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
  1800b4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
  1800b8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
  1800bc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
  1800c0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
  1800c4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
  1800c8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
  1800cc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
  1800d0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
  1800d4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
  1800d8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
  1800dc:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
  1800e0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
  1800e4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
  1800e8:	ef80083a 	eret

001800ec <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
  1800ec:	defffe04 	addi	sp,sp,-8
  1800f0:	dfc00115 	stw	ra,4(sp)
  1800f4:	dc000015 	stw	r16,0(sp)
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
  1800f8:	0009313a 	rdctl	r4,ipending
    do
    {
      if (active & mask)
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
  1800fc:	04000634 	movhi	r16,24
  180100:	840e1b04 	addi	r16,r16,14444

  active = alt_irq_pending ();

  do
  {
    i = 0;
  180104:	0005883a 	mov	r2,zero
    mask = 1;
  180108:	00c00044 	movi	r3,1
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
  18010c:	20ca703a 	and	r5,r4,r3
  180110:	28000b26 	beq	r5,zero,180140 <alt_irq_handler+0x54>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
  180114:	100490fa 	slli	r2,r2,3
  180118:	8085883a 	add	r2,r16,r2
  18011c:	10c00017 	ldw	r3,0(r2)
  180120:	11000117 	ldw	r4,4(r2)
  180124:	183ee83a 	callr	r3
  180128:	0009313a 	rdctl	r4,ipending

    } while (1);

    active = alt_irq_pending ();
    
  } while (active);
  18012c:	203ff51e 	bne	r4,zero,180104 <alt_irq_handler+0x18>
  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
}
  180130:	dfc00117 	ldw	ra,4(sp)
  180134:	dc000017 	ldw	r16,0(sp)
  180138:	dec00204 	addi	sp,sp,8
  18013c:	f800283a 	ret
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
  180140:	18c7883a 	add	r3,r3,r3
      i++;
  180144:	10800044 	addi	r2,r2,1

    } while (1);
  180148:	003ff006 	br	18010c <alt_irq_handler+0x20>

Disassembly of section .text:

0018014c <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
  18014c:	06c00734 	movhi	sp,28
    ori sp, sp, %lo(__alt_stack_pointer)
  180150:	deec0014 	ori	sp,sp,45056
    movhi gp, %hi(_gp)
  180154:	06800634 	movhi	gp,24
    ori gp, gp, %lo(_gp)
  180158:	d6aa9b14 	ori	gp,gp,43628
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
  18015c:	00800634 	movhi	r2,24
    ori r2, r2, %lo(__bss_start)
  180160:	108cd114 	ori	r2,r2,13124

    movhi r3, %hi(__bss_end)
  180164:	00c00634 	movhi	r3,24
    ori r3, r3, %lo(__bss_end)
  180168:	18ce5b14 	ori	r3,r3,14700

    beq r2, r3, 1f
  18016c:	10c00326 	beq	r2,r3,18017c <_start+0x30>

0:
    stw zero, (r2)
  180170:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
  180174:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
  180178:	10fffd36 	bltu	r2,r3,180170 <_start+0x24>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
  18017c:	01814880 	call	181488 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
  180180:	01815680 	call	181568 <alt_main>

00180184 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
  180184:	003fff06 	br	180184 <alt_after_alt_main>

00180188 <clearText>:
			}

	};

	void clearText(){
		for(int x = 0; x < 10000; x+=4){
  180188:	0005883a 	mov	r2,zero
  18018c:	00c9c404 	movi	r3,10000
			IOWR_ALTERA_AVALON_PIO_DATA(x ,(0<<16)| (0<<8) | 0);
  180190:	10000035 	stwio	zero,0(r2)
			}

	};

	void clearText(){
		for(int x = 0; x < 10000; x+=4){
  180194:	10800104 	addi	r2,r2,4
  180198:	10fffd1e 	bne	r2,r3,180190 <clearText+0x8>
			IOWR_ALTERA_AVALON_PIO_DATA(x ,(0<<16)| (0<<8) | 0);
		}
	}
  18019c:	f800283a 	ret

001801a0 <drawChars>:

	void drawChars(int pixels[35][8]){
  1801a0:	defffe04 	addi	sp,sp,-8
  1801a4:	dc000015 	stw	r16,0(sp)
  1801a8:	dfc00115 	stw	ra,4(sp)
  1801ac:	2021883a 	mov	r16,r4
			int totalChars = 35;
			int add = 0;
			int x = 0;
			int linePixelCount = 0;
			clearText();
  1801b0:	01801880 	call	180188 <clearText>
  1801b4:	8009883a 	mov	r4,r16
  1801b8:	82800804 	addi	r10,r16,32
		}
	}

	void drawChars(int pixels[35][8]){
			int totalChars = 35;
			int add = 0;
  1801bc:	000f883a 	mov	r7,zero
			clearText();
			int pixel = 0;
			while(x < 40*totalChars){
				//Draw all chars to video memory used by VGA controller
				for(int currentChar = 0; currentChar < totalChars; currentChar++){
					for(int bit = 4; bit >= 0; bit--){
  1801c0:	02ffffc4 	movi	r11,-1
			int linePixelCount = 0;
			clearText();
			int pixel = 0;
			while(x < 40*totalChars){
				//Draw all chars to video memory used by VGA controller
				for(int currentChar = 0; currentChar < totalChars; currentChar++){
  1801c4:	03011804 	movi	r12,1120
					for(int bit = 4; bit >= 0; bit--){
						linePixelCount++;
						int val = 0;
						if((pixels[currentChar][pixel] & (1 << bit)) != 0){
							val = 255;
  1801c8:	380d883a 	mov	r6,r7
  1801cc:	0007883a 	mov	r3,zero
		for(int x = 0; x < 10000; x+=4){
			IOWR_ALTERA_AVALON_PIO_DATA(x ,(0<<16)| (0<<8) | 0);
		}
	}

	void drawChars(int pixels[35][8]){
  1801d0:	3011883a 	mov	r8,r6
  1801d4:	01400104 	movi	r5,4
				//Draw all chars to video memory used by VGA controller
				for(int currentChar = 0; currentChar < totalChars; currentChar++){
					for(int bit = 4; bit >= 0; bit--){
						linePixelCount++;
						int val = 0;
						if((pixels[currentChar][pixel] & (1 << bit)) != 0){
  1801d8:	20db883a 	add	r13,r4,r3
  1801dc:	68800017 	ldw	r2,0(r13)
  1801e0:	1145d83a 	sra	r2,r2,r5
  1801e4:	1080004c 	andi	r2,r2,1
  1801e8:	10000226 	beq	r2,zero,1801f4 <drawChars+0x54>
							val = 255;
  1801ec:	00803fc4 	movi	r2,255
  1801f0:	00000106 	br	1801f8 <drawChars+0x58>
			while(x < 40*totalChars){
				//Draw all chars to video memory used by VGA controller
				for(int currentChar = 0; currentChar < totalChars; currentChar++){
					for(int bit = 4; bit >= 0; bit--){
						linePixelCount++;
						int val = 0;
  1801f4:	0005883a 	mov	r2,zero
						if((pixels[currentChar][pixel] & (1 << bit)) != 0){
							val = 255;
						}
						IOWR_ALTERA_AVALON_PIO_DATA(add ,(val<<16)| (val<<8) | val);
  1801f8:	101c943a 	slli	r14,r2,16
  1801fc:	1012923a 	slli	r9,r2,8
  180200:	7252b03a 	or	r9,r14,r9
  180204:	4884b03a 	or	r2,r9,r2
  180208:	40800035 	stwio	r2,0(r8)
			clearText();
			int pixel = 0;
			while(x < 40*totalChars){
				//Draw all chars to video memory used by VGA controller
				for(int currentChar = 0; currentChar < totalChars; currentChar++){
					for(int bit = 4; bit >= 0; bit--){
  18020c:	297fffc4 	addi	r5,r5,-1
						if((pixels[currentChar][pixel] & (1 << bit)) != 0){
							val = 255;
						}
						IOWR_ALTERA_AVALON_PIO_DATA(add ,(val<<16)| (val<<8) | val);
						x++;
						add+=4;
  180210:	42000104 	addi	r8,r8,4
			clearText();
			int pixel = 0;
			while(x < 40*totalChars){
				//Draw all chars to video memory used by VGA controller
				for(int currentChar = 0; currentChar < totalChars; currentChar++){
					for(int bit = 4; bit >= 0; bit--){
  180214:	2afff11e 	bne	r5,r11,1801dc <drawChars+0x3c>
  180218:	18c00804 	addi	r3,r3,32
  18021c:	31800604 	addi	r6,r6,24
			int linePixelCount = 0;
			clearText();
			int pixel = 0;
			while(x < 40*totalChars){
				//Draw all chars to video memory used by VGA controller
				for(int currentChar = 0; currentChar < totalChars; currentChar++){
  180220:	1b3feb1e 	bne	r3,r12,1801d0 <drawChars+0x30>
  180224:	21000104 	addi	r4,r4,4
						add+=4;
					}
					add+=4;
				}
				if(linePixelCount == (5*totalChars)){
					add+=(800-(24*totalChars));
  180228:	39c0c804 	addi	r7,r7,800
			int add = 0;
			int x = 0;
			int linePixelCount = 0;
			clearText();
			int pixel = 0;
			while(x < 40*totalChars){
  18022c:	513fe61e 	bne	r10,r4,1801c8 <drawChars+0x28>
					add+=(800-(24*totalChars));
					linePixelCount = 0;
				}
				pixel++;
			}
		}
  180230:	dfc00117 	ldw	ra,4(sp)
  180234:	dc000017 	ldw	r16,0(sp)
  180238:	dec00204 	addi	sp,sp,8
  18023c:	f800283a 	ret

00180240 <showText>:


void showText(char *chars){
  180240:	defee504 	addi	sp,sp,-1132
  180244:	dc411915 	stw	r17,1124(sp)
  180248:	dc011815 	stw	r16,1120(sp)
  18024c:	dfc11a15 	stw	ra,1128(sp)
  180250:	2021883a 	mov	r16,r4
  180254:	d807883a 	mov	r3,sp
  180258:	244008c4 	addi	r17,r4,35
	int pixeldata[35][8];
	for(int x = 0; x < 35; x++){
		switch (chars[x]) {
  18025c:	80800007 	ldb	r2,0(r16)
  180260:	01001b44 	movi	r4,109
  180264:	11007026 	beq	r2,r4,180428 <showText+0x1e8>
  180268:	20802616 	blt	r4,r2,180304 <showText+0xc4>
  18026c:	01001984 	movi	r4,102
  180270:	11005926 	beq	r2,r4,1803d8 <showText+0x198>
  180274:	20801116 	blt	r4,r2,1802bc <showText+0x7c>
  180278:	01001884 	movi	r4,98
  18027c:	11004a26 	beq	r2,r4,1803a8 <showText+0x168>
  180280:	20800716 	blt	r4,r2,1802a0 <showText+0x60>
  180284:	01800804 	movi	r6,32
  180288:	11808f26 	beq	r2,r6,1804c8 <showText+0x288>
  18028c:	01001844 	movi	r4,97
  180290:	11008f1e 	bne	r2,r4,1804d0 <showText+0x290>
		  case 'a': memcpy(&pixeldata[x], &charTemplate[0], sizeof(pixeldata[x]) ); break;
  180294:	01400634 	movhi	r5,24
  180298:	29487304 	addi	r5,r5,8652
  18029c:	00008f06 	br	1804dc <showText+0x29c>


void showText(char *chars){
	int pixeldata[35][8];
	for(int x = 0; x < 35; x++){
		switch (chars[x]) {
  1802a0:	01001904 	movi	r4,100
  1802a4:	11004426 	beq	r2,r4,1803b8 <showText+0x178>
  1802a8:	20804716 	blt	r4,r2,1803c8 <showText+0x188>
		  case 'a': memcpy(&pixeldata[x], &charTemplate[0], sizeof(pixeldata[x]) ); break;
		  case 'b': memcpy(&pixeldata[x], &charTemplate[1], sizeof(pixeldata[x]) ); break;
		  case 'c': memcpy(&pixeldata[x], &charTemplate[2], sizeof(pixeldata[x]) ); break;
  1802ac:	01400634 	movhi	r5,24
  1802b0:	01800804 	movi	r6,32
  1802b4:	29488304 	addi	r5,r5,8716
  1802b8:	00008806 	br	1804dc <showText+0x29c>


void showText(char *chars){
	int pixeldata[35][8];
	for(int x = 0; x < 35; x++){
		switch (chars[x]) {
  1802bc:	01001a44 	movi	r4,105
  1802c0:	11004d26 	beq	r2,r4,1803f8 <showText+0x1b8>
  1802c4:	20800816 	blt	r4,r2,1802e8 <showText+0xa8>
  1802c8:	010019c4 	movi	r4,103
  1802cc:	11004626 	beq	r2,r4,1803e8 <showText+0x1a8>
  1802d0:	01001a04 	movi	r4,104
  1802d4:	11007e1e 	bne	r2,r4,1804d0 <showText+0x290>
		  case 'c': memcpy(&pixeldata[x], &charTemplate[2], sizeof(pixeldata[x]) ); break;
		  case 'd': memcpy(&pixeldata[x], &charTemplate[3], sizeof(pixeldata[x]) ); break;
		  case 'e': memcpy(&pixeldata[x], &charTemplate[4], sizeof(pixeldata[x]) ); break;
		  case 'f': memcpy(&pixeldata[x], &charTemplate[5], sizeof(pixeldata[x]) ); break;
		  case 'g': memcpy(&pixeldata[x], &charTemplate[6], sizeof(pixeldata[x]) ); break;
		  case 'h': memcpy(&pixeldata[x], &charTemplate[7], sizeof(pixeldata[x]) ); break;
  1802d8:	01400634 	movhi	r5,24
  1802dc:	01800804 	movi	r6,32
  1802e0:	2948ab04 	addi	r5,r5,8876
  1802e4:	00007d06 	br	1804dc <showText+0x29c>


void showText(char *chars){
	int pixeldata[35][8];
	for(int x = 0; x < 35; x++){
		switch (chars[x]) {
  1802e8:	01001ac4 	movi	r4,107
  1802ec:	11004626 	beq	r2,r4,180408 <showText+0x1c8>
  1802f0:	20804916 	blt	r4,r2,180418 <showText+0x1d8>
		  case 'e': memcpy(&pixeldata[x], &charTemplate[4], sizeof(pixeldata[x]) ); break;
		  case 'f': memcpy(&pixeldata[x], &charTemplate[5], sizeof(pixeldata[x]) ); break;
		  case 'g': memcpy(&pixeldata[x], &charTemplate[6], sizeof(pixeldata[x]) ); break;
		  case 'h': memcpy(&pixeldata[x], &charTemplate[7], sizeof(pixeldata[x]) ); break;
		  case 'i': memcpy(&pixeldata[x], &charTemplate[8], sizeof(pixeldata[x]) ); break;
		  case 'j': memcpy(&pixeldata[x], &charTemplate[9], sizeof(pixeldata[x]) ); break;
  1802f4:	01400634 	movhi	r5,24
  1802f8:	01800804 	movi	r6,32
  1802fc:	2948bb04 	addi	r5,r5,8940
  180300:	00007606 	br	1804dc <showText+0x29c>


void showText(char *chars){
	int pixeldata[35][8];
	for(int x = 0; x < 35; x++){
		switch (chars[x]) {
  180304:	01001d04 	movi	r4,116
  180308:	11005b26 	beq	r2,r4,180478 <showText+0x238>
  18030c:	20801216 	blt	r4,r2,180358 <showText+0x118>
  180310:	01001c04 	movi	r4,112
  180314:	11004c26 	beq	r2,r4,180448 <showText+0x208>
  180318:	20800816 	blt	r4,r2,18033c <showText+0xfc>
  18031c:	01001b84 	movi	r4,110
  180320:	11004526 	beq	r2,r4,180438 <showText+0x1f8>
  180324:	01001bc4 	movi	r4,111
  180328:	1100691e 	bne	r2,r4,1804d0 <showText+0x290>
		  case 'j': memcpy(&pixeldata[x], &charTemplate[9], sizeof(pixeldata[x]) ); break;
		  case 'k': memcpy(&pixeldata[x], &charTemplate[10], sizeof(pixeldata[x]) ); break;
		  case 'l': memcpy(&pixeldata[x], &charTemplate[11], sizeof(pixeldata[x]) ); break;
		  case 'm': memcpy(&pixeldata[x], &charTemplate[12], sizeof(pixeldata[x]) ); break;
		  case 'n': memcpy(&pixeldata[x], &charTemplate[13], sizeof(pixeldata[x]) ); break;
		  case 'o': memcpy(&pixeldata[x], &charTemplate[14], sizeof(pixeldata[x]) ); break;
  18032c:	01400634 	movhi	r5,24
  180330:	01800804 	movi	r6,32
  180334:	2948e304 	addi	r5,r5,9100
  180338:	00006806 	br	1804dc <showText+0x29c>


void showText(char *chars){
	int pixeldata[35][8];
	for(int x = 0; x < 35; x++){
		switch (chars[x]) {
  18033c:	01001c84 	movi	r4,114
  180340:	11004526 	beq	r2,r4,180458 <showText+0x218>
  180344:	20804816 	blt	r4,r2,180468 <showText+0x228>
		  case 'l': memcpy(&pixeldata[x], &charTemplate[11], sizeof(pixeldata[x]) ); break;
		  case 'm': memcpy(&pixeldata[x], &charTemplate[12], sizeof(pixeldata[x]) ); break;
		  case 'n': memcpy(&pixeldata[x], &charTemplate[13], sizeof(pixeldata[x]) ); break;
		  case 'o': memcpy(&pixeldata[x], &charTemplate[14], sizeof(pixeldata[x]) ); break;
		  case 'p': memcpy(&pixeldata[x], &charTemplate[15], sizeof(pixeldata[x]) ); break;
		  case 'q': memcpy(&pixeldata[x], &charTemplate[16], sizeof(pixeldata[x]) ); break;
  180348:	01400634 	movhi	r5,24
  18034c:	01800804 	movi	r6,32
  180350:	2948f304 	addi	r5,r5,9164
  180354:	00006106 	br	1804dc <showText+0x29c>


void showText(char *chars){
	int pixeldata[35][8];
	for(int x = 0; x < 35; x++){
		switch (chars[x]) {
  180358:	01001dc4 	movi	r4,119
  18035c:	11004e26 	beq	r2,r4,180498 <showText+0x258>
  180360:	20800816 	blt	r4,r2,180384 <showText+0x144>
  180364:	01001d44 	movi	r4,117
  180368:	11004726 	beq	r2,r4,180488 <showText+0x248>
  18036c:	01001d84 	movi	r4,118
  180370:	1100571e 	bne	r2,r4,1804d0 <showText+0x290>
		  case 'q': memcpy(&pixeldata[x], &charTemplate[16], sizeof(pixeldata[x]) ); break;
		  case 'r': memcpy(&pixeldata[x], &charTemplate[17], sizeof(pixeldata[x]) ); break;
		  case 's': memcpy(&pixeldata[x], &charTemplate[18], sizeof(pixeldata[x]) ); break;
		  case 't': memcpy(&pixeldata[x], &charTemplate[19], sizeof(pixeldata[x]) ); break;
		  case 'u': memcpy(&pixeldata[x], &charTemplate[20], sizeof(pixeldata[x]) ); break;
		  case 'v': memcpy(&pixeldata[x], &charTemplate[21], sizeof(pixeldata[x]) ); break;
  180374:	01400634 	movhi	r5,24
  180378:	01800804 	movi	r6,32
  18037c:	29491b04 	addi	r5,r5,9324
  180380:	00005606 	br	1804dc <showText+0x29c>


void showText(char *chars){
	int pixeldata[35][8];
	for(int x = 0; x < 35; x++){
		switch (chars[x]) {
  180384:	01001e44 	movi	r4,121
  180388:	11004b26 	beq	r2,r4,1804b8 <showText+0x278>
  18038c:	11004616 	blt	r2,r4,1804a8 <showText+0x268>
  180390:	01001e84 	movi	r4,122
  180394:	11004e1e 	bne	r2,r4,1804d0 <showText+0x290>
		  case 'u': memcpy(&pixeldata[x], &charTemplate[20], sizeof(pixeldata[x]) ); break;
		  case 'v': memcpy(&pixeldata[x], &charTemplate[21], sizeof(pixeldata[x]) ); break;
		  case 'w': memcpy(&pixeldata[x], &charTemplate[22], sizeof(pixeldata[x]) ); break;
		  case 'x': memcpy(&pixeldata[x], &charTemplate[23], sizeof(pixeldata[x]) ); break;
		  case 'y': memcpy(&pixeldata[x], &charTemplate[24], sizeof(pixeldata[x]) ); break;
		  case 'z': memcpy(&pixeldata[x], &charTemplate[25], sizeof(pixeldata[x]) ); break;
  180398:	01400634 	movhi	r5,24
  18039c:	01800804 	movi	r6,32
  1803a0:	29493b04 	addi	r5,r5,9452
  1803a4:	00004d06 	br	1804dc <showText+0x29c>
void showText(char *chars){
	int pixeldata[35][8];
	for(int x = 0; x < 35; x++){
		switch (chars[x]) {
		  case 'a': memcpy(&pixeldata[x], &charTemplate[0], sizeof(pixeldata[x]) ); break;
		  case 'b': memcpy(&pixeldata[x], &charTemplate[1], sizeof(pixeldata[x]) ); break;
  1803a8:	01400634 	movhi	r5,24
  1803ac:	01800804 	movi	r6,32
  1803b0:	29487b04 	addi	r5,r5,8684
  1803b4:	00004906 	br	1804dc <showText+0x29c>
		  case 'c': memcpy(&pixeldata[x], &charTemplate[2], sizeof(pixeldata[x]) ); break;
		  case 'd': memcpy(&pixeldata[x], &charTemplate[3], sizeof(pixeldata[x]) ); break;
  1803b8:	01400634 	movhi	r5,24
  1803bc:	01800804 	movi	r6,32
  1803c0:	29488b04 	addi	r5,r5,8748
  1803c4:	00004506 	br	1804dc <showText+0x29c>
		  case 'e': memcpy(&pixeldata[x], &charTemplate[4], sizeof(pixeldata[x]) ); break;
  1803c8:	01400634 	movhi	r5,24
  1803cc:	01800804 	movi	r6,32
  1803d0:	29489304 	addi	r5,r5,8780
  1803d4:	00004106 	br	1804dc <showText+0x29c>
		  case 'f': memcpy(&pixeldata[x], &charTemplate[5], sizeof(pixeldata[x]) ); break;
  1803d8:	01400634 	movhi	r5,24
  1803dc:	01800804 	movi	r6,32
  1803e0:	29489b04 	addi	r5,r5,8812
  1803e4:	00003d06 	br	1804dc <showText+0x29c>
		  case 'g': memcpy(&pixeldata[x], &charTemplate[6], sizeof(pixeldata[x]) ); break;
  1803e8:	01400634 	movhi	r5,24
  1803ec:	01800804 	movi	r6,32
  1803f0:	2948a304 	addi	r5,r5,8844
  1803f4:	00003906 	br	1804dc <showText+0x29c>
		  case 'h': memcpy(&pixeldata[x], &charTemplate[7], sizeof(pixeldata[x]) ); break;
		  case 'i': memcpy(&pixeldata[x], &charTemplate[8], sizeof(pixeldata[x]) ); break;
  1803f8:	01400634 	movhi	r5,24
  1803fc:	01800804 	movi	r6,32
  180400:	2948b304 	addi	r5,r5,8908
  180404:	00003506 	br	1804dc <showText+0x29c>
		  case 'j': memcpy(&pixeldata[x], &charTemplate[9], sizeof(pixeldata[x]) ); break;
		  case 'k': memcpy(&pixeldata[x], &charTemplate[10], sizeof(pixeldata[x]) ); break;
  180408:	01400634 	movhi	r5,24
  18040c:	01800804 	movi	r6,32
  180410:	2948c304 	addi	r5,r5,8972
  180414:	00003106 	br	1804dc <showText+0x29c>
		  case 'l': memcpy(&pixeldata[x], &charTemplate[11], sizeof(pixeldata[x]) ); break;
  180418:	01400634 	movhi	r5,24
  18041c:	01800804 	movi	r6,32
  180420:	2948cb04 	addi	r5,r5,9004
  180424:	00002d06 	br	1804dc <showText+0x29c>
		  case 'm': memcpy(&pixeldata[x], &charTemplate[12], sizeof(pixeldata[x]) ); break;
  180428:	01400634 	movhi	r5,24
  18042c:	01800804 	movi	r6,32
  180430:	2948d304 	addi	r5,r5,9036
  180434:	00002906 	br	1804dc <showText+0x29c>
		  case 'n': memcpy(&pixeldata[x], &charTemplate[13], sizeof(pixeldata[x]) ); break;
  180438:	01400634 	movhi	r5,24
  18043c:	01800804 	movi	r6,32
  180440:	2948db04 	addi	r5,r5,9068
  180444:	00002506 	br	1804dc <showText+0x29c>
		  case 'o': memcpy(&pixeldata[x], &charTemplate[14], sizeof(pixeldata[x]) ); break;
		  case 'p': memcpy(&pixeldata[x], &charTemplate[15], sizeof(pixeldata[x]) ); break;
  180448:	01400634 	movhi	r5,24
  18044c:	01800804 	movi	r6,32
  180450:	2948eb04 	addi	r5,r5,9132
  180454:	00002106 	br	1804dc <showText+0x29c>
		  case 'q': memcpy(&pixeldata[x], &charTemplate[16], sizeof(pixeldata[x]) ); break;
		  case 'r': memcpy(&pixeldata[x], &charTemplate[17], sizeof(pixeldata[x]) ); break;
  180458:	01400634 	movhi	r5,24
  18045c:	01800804 	movi	r6,32
  180460:	2948fb04 	addi	r5,r5,9196
  180464:	00001d06 	br	1804dc <showText+0x29c>
		  case 's': memcpy(&pixeldata[x], &charTemplate[18], sizeof(pixeldata[x]) ); break;
  180468:	01400634 	movhi	r5,24
  18046c:	01800804 	movi	r6,32
  180470:	29490304 	addi	r5,r5,9228
  180474:	00001906 	br	1804dc <showText+0x29c>
		  case 't': memcpy(&pixeldata[x], &charTemplate[19], sizeof(pixeldata[x]) ); break;
  180478:	01400634 	movhi	r5,24
  18047c:	01800804 	movi	r6,32
  180480:	29490b04 	addi	r5,r5,9260
  180484:	00001506 	br	1804dc <showText+0x29c>
		  case 'u': memcpy(&pixeldata[x], &charTemplate[20], sizeof(pixeldata[x]) ); break;
  180488:	01400634 	movhi	r5,24
  18048c:	01800804 	movi	r6,32
  180490:	29491304 	addi	r5,r5,9292
  180494:	00001106 	br	1804dc <showText+0x29c>
		  case 'v': memcpy(&pixeldata[x], &charTemplate[21], sizeof(pixeldata[x]) ); break;
		  case 'w': memcpy(&pixeldata[x], &charTemplate[22], sizeof(pixeldata[x]) ); break;
  180498:	01400634 	movhi	r5,24
  18049c:	01800804 	movi	r6,32
  1804a0:	29492304 	addi	r5,r5,9356
  1804a4:	00000d06 	br	1804dc <showText+0x29c>
		  case 'x': memcpy(&pixeldata[x], &charTemplate[23], sizeof(pixeldata[x]) ); break;
  1804a8:	01400634 	movhi	r5,24
  1804ac:	01800804 	movi	r6,32
  1804b0:	29492b04 	addi	r5,r5,9388
  1804b4:	00000906 	br	1804dc <showText+0x29c>
		  case 'y': memcpy(&pixeldata[x], &charTemplate[24], sizeof(pixeldata[x]) ); break;
  1804b8:	01400634 	movhi	r5,24
  1804bc:	01800804 	movi	r6,32
  1804c0:	29493304 	addi	r5,r5,9420
  1804c4:	00000506 	br	1804dc <showText+0x29c>
		  case 'z': memcpy(&pixeldata[x], &charTemplate[25], sizeof(pixeldata[x]) ); break;
		  case ' ': memcpy(&pixeldata[x], &charTemplate[26], sizeof(pixeldata[x]) ); break;
  1804c8:	100d883a 	mov	r6,r2
  1804cc:	00000106 	br	1804d4 <showText+0x294>
		  default: memcpy(&pixeldata[x], &charTemplate[26], sizeof(pixeldata[x]) );
  1804d0:	01800804 	movi	r6,32
  1804d4:	01400634 	movhi	r5,24
  1804d8:	29494304 	addi	r5,r5,9484
  1804dc:	1809883a 	mov	r4,r3
  1804e0:	0180a4c0 	call	180a4c <memcpy>
  1804e4:	84000044 	addi	r16,r16,1
  1804e8:	10c00804 	addi	r3,r2,32
		}


void showText(char *chars){
	int pixeldata[35][8];
	for(int x = 0; x < 35; x++){
  1804ec:	847f5b1e 	bne	r16,r17,18025c <showText+0x1c>
		  default: memcpy(&pixeldata[x], &charTemplate[26], sizeof(pixeldata[x]) );

		 }
	}

	drawChars(pixeldata);
  1804f0:	d809883a 	mov	r4,sp
  1804f4:	01801a00 	call	1801a0 <drawChars>
}
  1804f8:	dfc11a17 	ldw	ra,1128(sp)
  1804fc:	dc411917 	ldw	r17,1124(sp)
  180500:	dc011817 	ldw	r16,1120(sp)
  180504:	dec11b04 	addi	sp,sp,1132
  180508:	f800283a 	ret

0018050c <scanBarcode>:

char charcode[256] = {};
int barwidth = 0;
int actualCount = 0;
void scanBarcode(){
  18050c:	defff704 	addi	sp,sp,-36
  180510:	dd000415 	stw	r20,16(sp)
				charcode[actualCount] = '0';
				actualCount++;
			}
		}else{
			//alt_printf("1");
			charcode[actualCount] = '1';
  180514:	05000634 	movhi	r20,24
}

char charcode[256] = {};
int barwidth = 0;
int actualCount = 0;
void scanBarcode(){
  180518:	ddc00715 	stw	r23,28(sp)
  18051c:	dd800615 	stw	r22,24(sp)
  180520:	dd400515 	stw	r21,20(sp)
  180524:	dc800215 	stw	r18,8(sp)
  180528:	dc400115 	stw	r17,4(sp)
  18052c:	dc000015 	stw	r16,0(sp)
  180530:	dfc00815 	stw	ra,32(sp)
  180534:	dcc00315 	stw	r19,12(sp)
	int firstBit = 0;
	int countingBarWidth = 1;
	barwidth = 0;
  180538:	d0223715 	stw	zero,-30500(gp)
	actualCount = 0;
  18053c:	d0223615 	stw	zero,-30504(gp)

	for(int x =0; x < 255; x++){
  180540:	0021883a 	mov	r16,zero
char charcode[256] = {};
int barwidth = 0;
int actualCount = 0;
void scanBarcode(){
	int firstBit = 0;
	int countingBarWidth = 1;
  180544:	04800044 	movi	r18,1

char charcode[256] = {};
int barwidth = 0;
int actualCount = 0;
void scanBarcode(){
	int firstBit = 0;
  180548:	0023883a 	mov	r17,zero
	int countingBarWidth = 1;
	barwidth = 0;
	actualCount = 0;

	for(int x =0; x < 255; x++){
		IOWR_ALTERA_AVALON_PIO_DATA(0x4020, x);
  18054c:	05500804 	movi	r21,16416
		int r = IORD_ALTERA_AVALON_PIO_DATA(0x4000);
  180550:	05900004 	movi	r22,16384
		int g = IORD_ALTERA_AVALON_PIO_DATA(0x4010);
  180554:	05d00404 	movi	r23,16400
				charcode[actualCount] = '0';
				actualCount++;
			}
		}else{
			//alt_printf("1");
			charcode[actualCount] = '1';
  180558:	a50cdb04 	addi	r20,r20,13164
	int countingBarWidth = 1;
	barwidth = 0;
	actualCount = 0;

	for(int x =0; x < 255; x++){
		IOWR_ALTERA_AVALON_PIO_DATA(0x4020, x);
  18055c:	ac000035 	stwio	r16,0(r21)
		int r = IORD_ALTERA_AVALON_PIO_DATA(0x4000);
  180560:	b4c00037 	ldwio	r19,0(r22)
		int g = IORD_ALTERA_AVALON_PIO_DATA(0x4010);
  180564:	b8c00037 	ldwio	r3,0(r23)
		int b = IORD_ALTERA_AVALON_PIO_DATA(0x4040);
  180568:	00901004 	movi	r2,16448
  18056c:	10800037 	ldwio	r2,0(r2)

		//int grey =  0.2126*r + 0.7152*g + 0.0722*b;
		int grey = (r+g+b) / 3;
		//printf( " R=%d ",grey);
		usleep(5100);
  180570:	0104fb04 	movi	r4,5100
		int r = IORD_ALTERA_AVALON_PIO_DATA(0x4000);
		int g = IORD_ALTERA_AVALON_PIO_DATA(0x4010);
		int b = IORD_ALTERA_AVALON_PIO_DATA(0x4040);

		//int grey =  0.2126*r + 0.7152*g + 0.0722*b;
		int grey = (r+g+b) / 3;
  180574:	98e7883a 	add	r19,r19,r3
  180578:	98a7883a 	add	r19,r19,r2
		//printf( " R=%d ",grey);
		usleep(5100);
  18057c:	018174c0 	call	18174c <usleep>
		if(grey > 128){
  180580:	00806084 	movi	r2,386
  180584:	00c00044 	movi	r3,1
  180588:	14c0090e 	bge	r2,r19,1805b0 <scanBarcode+0xa4>
			if(firstBit==1){
  18058c:	88c0141e 	bne	r17,r3,1805e0 <scanBarcode+0xd4>
				countingBarWidth = 0;
				//alt_printf("0");
				charcode[actualCount] = '0';
  180590:	d0a23617 	ldw	r2,-30504(gp)
  180594:	01000c04 	movi	r4,48
		int grey = (r+g+b) / 3;
		//printf( " R=%d ",grey);
		usleep(5100);
		if(grey > 128){
			if(firstBit==1){
				countingBarWidth = 0;
  180598:	0025883a 	mov	r18,zero
				//alt_printf("0");
				charcode[actualCount] = '0';
  18059c:	a087883a 	add	r3,r20,r2
				actualCount++;
  1805a0:	10800044 	addi	r2,r2,1
		usleep(5100);
		if(grey > 128){
			if(firstBit==1){
				countingBarWidth = 0;
				//alt_printf("0");
				charcode[actualCount] = '0';
  1805a4:	19000005 	stb	r4,0(r3)
				actualCount++;
  1805a8:	d0a23615 	stw	r2,-30504(gp)
  1805ac:	00000f06 	br	1805ec <scanBarcode+0xe0>
			}
		}else{
			//alt_printf("1");
			charcode[actualCount] = '1';
  1805b0:	d0a23617 	ldw	r2,-30504(gp)
  1805b4:	01400c44 	movi	r5,49
  1805b8:	a089883a 	add	r4,r20,r2
			actualCount++;
  1805bc:	10800044 	addi	r2,r2,1
				charcode[actualCount] = '0';
				actualCount++;
			}
		}else{
			//alt_printf("1");
			charcode[actualCount] = '1';
  1805c0:	21400005 	stb	r5,0(r4)
			actualCount++;
  1805c4:	d0a23615 	stw	r2,-30504(gp)
			if(countingBarWidth == 1){
  1805c8:	90c0071e 	bne	r18,r3,1805e8 <scanBarcode+0xdc>
				barwidth++;
  1805cc:	d0a23717 	ldw	r2,-30500(gp)
			}
			firstBit = 1;
  1805d0:	9023883a 	mov	r17,r18
		}else{
			//alt_printf("1");
			charcode[actualCount] = '1';
			actualCount++;
			if(countingBarWidth == 1){
				barwidth++;
  1805d4:	10800044 	addi	r2,r2,1
  1805d8:	d0a23715 	stw	r2,-30500(gp)
  1805dc:	00000306 	br	1805ec <scanBarcode+0xe0>
  1805e0:	0023883a 	mov	r17,zero
  1805e4:	00000106 	br	1805ec <scanBarcode+0xe0>
			}
			firstBit = 1;
  1805e8:	1823883a 	mov	r17,r3
	int firstBit = 0;
	int countingBarWidth = 1;
	barwidth = 0;
	actualCount = 0;

	for(int x =0; x < 255; x++){
  1805ec:	84000044 	addi	r16,r16,1
  1805f0:	00803fc4 	movi	r2,255
  1805f4:	80bfd91e 	bne	r16,r2,18055c <scanBarcode+0x50>
				barwidth++;
			}
			firstBit = 1;
		}
	}
	printf("\nWidth: %d",barwidth);
  1805f8:	d1623717 	ldw	r5,-30500(gp)
  1805fc:	01000634 	movhi	r4,24
  180600:	21082804 	addi	r4,r4,8352
  180604:	0180ab00 	call	180ab0 <printf>
	alt_printf("\n");
  180608:	01000634 	movhi	r4,24
  18060c:	21087004 	addi	r4,r4,8640

	for(int x = 0; x < 255; x+=barwidth){
		printf("%c",charcode[x]);
  180610:	04c00634 	movhi	r19,24
			}
			firstBit = 1;
		}
	}
	printf("\nWidth: %d",barwidth);
	alt_printf("\n");
  180614:	01815940 	call	181594 <alt_printf>

	for(int x = 0; x < 255; x+=barwidth){
  180618:	0021883a 	mov	r16,zero
		printf("%c",charcode[x]);
  18061c:	9cccdb04 	addi	r19,r19,13164
		}
	}
	printf("\nWidth: %d",barwidth);
	alt_printf("\n");

	for(int x = 0; x < 255; x+=barwidth){
  180620:	04803f84 	movi	r18,254
		printf("%c",charcode[x]);
  180624:	9c23883a 	add	r17,r19,r16
  180628:	89000007 	ldb	r4,0(r17)
  18062c:	0180b040 	call	180b04 <putchar>
		tx_char(charcode[x],x);
  180630:	89000007 	ldb	r4,0(r17)
  180634:	800b883a 	mov	r5,r16
  180638:	018091c0 	call	18091c <tx_char>
		}
	}
	printf("\nWidth: %d",barwidth);
	alt_printf("\n");

	for(int x = 0; x < 255; x+=barwidth){
  18063c:	d0a23717 	ldw	r2,-30500(gp)
  180640:	80a1883a 	add	r16,r16,r2
  180644:	943ff70e 	bge	r18,r16,180624 <scanBarcode+0x118>
		printf("%c",charcode[x]);
		tx_char(charcode[x],x);
	}
	transmit();
	//tx_ethernet_isr(tmp);
}
  180648:	dfc00817 	ldw	ra,32(sp)
  18064c:	ddc00717 	ldw	r23,28(sp)
  180650:	dd800617 	ldw	r22,24(sp)
  180654:	dd400517 	ldw	r21,20(sp)
  180658:	dd000417 	ldw	r20,16(sp)
  18065c:	dcc00317 	ldw	r19,12(sp)
  180660:	dc800217 	ldw	r18,8(sp)
  180664:	dc400117 	ldw	r17,4(sp)
  180668:	dc000017 	ldw	r16,0(sp)
  18066c:	dec00904 	addi	sp,sp,36

	for(int x = 0; x < 255; x+=barwidth){
		printf("%c",charcode[x]);
		tx_char(charcode[x],x);
	}
	transmit();
  180670:	01809301 	jmpi	180930 <transmit>

00180674 <callback>:
	}

	return 0;
}

void callback(unsigned char *data){
  180674:	defffe04 	addi	sp,sp,-8
  180678:	dc000015 	stw	r16,0(sp)
	alt_printf( "\nResponds: %s\n", data + 16);
  18067c:	24000404 	addi	r16,r4,16
  180680:	01000634 	movhi	r4,24
  180684:	800b883a 	mov	r5,r16
  180688:	21083104 	addi	r4,r4,8388
	}

	return 0;
}

void callback(unsigned char *data){
  18068c:	dfc00115 	stw	ra,4(sp)
	alt_printf( "\nResponds: %s\n", data + 16);
  180690:	01815940 	call	181594 <alt_printf>
	showText(data + 16);
  180694:	8009883a 	mov	r4,r16
}
  180698:	dfc00117 	ldw	ra,4(sp)
  18069c:	dc000017 	ldw	r16,0(sp)
  1806a0:	dec00204 	addi	sp,sp,8
	return 0;
}

void callback(unsigned char *data){
	alt_printf( "\nResponds: %s\n", data + 16);
	showText(data + 16);
  1806a4:	01802401 	jmpi	180240 <showText>

001806a8 <main>:
		tx_char(charcode[x],x);
	}
	transmit();
	//tx_ethernet_isr(tmp);
}
int main(void){
  1806a8:	deffff04 	addi	sp,sp,-4
  1806ac:	dfc00015 	stw	ra,0(sp)
	setup();
  1806b0:	01807a40 	call	1807a4 <setup>
	showText("please scan a barcode");
  1806b4:	01000634 	movhi	r4,24
  1806b8:	21082b04 	addi	r4,r4,8364
  1806bc:	01802400 	call	180240 <showText>

	scanBarcode();
  1806c0:	018050c0 	call	18050c <scanBarcode>
	scanBarcode();
  1806c4:	018050c0 	call	18050c <scanBarcode>
	scanBarcode();
  1806c8:	018050c0 	call	18050c <scanBarcode>
	while(1){
		usleep(200000);
  1806cc:	010000f4 	movhi	r4,3
  1806d0:	21035004 	addi	r4,r4,3392
  1806d4:	018174c0 	call	18174c <usleep>
  1806d8:	003ffc06 	br	1806cc <main+0x24>

001806dc <rx_ethernet_isr>:
	//while (alt_avalon_sgdma_check_descriptor_status(&tx_descriptor) != 0)

}

void rx_ethernet_isr (void *context)
{
  1806dc:	defffa04 	addi	sp,sp,-24
  1806e0:	dfc00515 	stw	ra,20(sp)
  1806e4:	dc000415 	stw	r16,16(sp)
	int i;

		// Wait until receive descriptor transfer is complete
		while (alt_avalon_sgdma_check_descriptor_status(&rx_descriptor) != 0)
  1806e8:	01000074 	movhi	r4,1
  1806ec:	21200804 	addi	r4,r4,-32736
  1806f0:	01819d80 	call	1819d8 <alt_avalon_sgdma_check_descriptor_status>
  1806f4:	103ffc1e 	bne	r2,zero,1806e8 <rx_ethernet_isr+0xc>
		// Clear input line before writing
//		for (i = 0; i < (6 + text_length); i++) {
//			alt_printf( "%c", 0x08 );		 // 0x08 --> backspace
//		}
		//alt_printf( "got: %s\n", rx_frame + 16);
		if(rx_frame[2] == 0x69){
  1806f8:	04000634 	movhi	r16,24
  1806fc:	840d1b04 	addi	r16,r16,13420
  180700:	80c00083 	ldbu	r3,2(r16)
  180704:	00801a44 	movi	r2,105
  180708:	1880021e 	bne	r3,r2,180714 <rx_ethernet_isr+0x38>

			callback(rx_frame);
  18070c:	8009883a 	mov	r4,r16
  180710:	01806740 	call	180674 <callback>
		}

		alt_avalon_sgdma_construct_mem_to_stream_desc( &tx_descriptor, &tx_descriptor_end, (alt_u32 *)tx_frame, 62, 0, 1, 1, 0 );
  180714:	00800044 	movi	r2,1
  180718:	01800634 	movhi	r6,24
  18071c:	01400074 	movhi	r5,1
  180720:	01000074 	movhi	r4,1
  180724:	d8800215 	stw	r2,8(sp)
  180728:	d8800115 	stw	r2,4(sp)
  18072c:	01c00f84 	movi	r7,62
  180730:	31894b04 	addi	r6,r6,9516
  180734:	29601004 	addi	r5,r5,-32704
  180738:	21201804 	addi	r4,r4,-32672
  18073c:	d8000315 	stw	zero,12(sp)
  180740:	d8000015 	stw	zero,0(sp)
  180744:	0181cf40 	call	181cf4 <alt_avalon_sgdma_construct_mem_to_stream_desc>
		// Create new receive sgdma descriptor
		alt_avalon_sgdma_construct_stream_to_mem_desc( &rx_descriptor, &rx_descriptor_end, (alt_u32 *)rx_frame, 0, 0 );
  180748:	01800634 	movhi	r6,24
  18074c:	01400074 	movhi	r5,1
  180750:	01000074 	movhi	r4,1
  180754:	000f883a 	mov	r7,zero
  180758:	318d1b04 	addi	r6,r6,13420
  18075c:	29600004 	addi	r5,r5,-32768
  180760:	21200804 	addi	r4,r4,-32736
  180764:	d8000015 	stw	zero,0(sp)
  180768:	0181c7c0 	call	181c7c <alt_avalon_sgdma_construct_stream_to_mem_desc>


		// Set up non-blocking transfer of sgdma receive descriptor
		alt_avalon_sgdma_do_async_transfer( sgdma_rx_dev, &rx_descriptor );
  18076c:	d1223a17 	ldw	r4,-30488(gp)
  180770:	01400074 	movhi	r5,1
  180774:	29600804 	addi	r5,r5,-32736
  180778:	01818980 	call	181898 <alt_avalon_sgdma_do_async_transfer>

		// Output received text
			for(int x = 0; x < 1024; x++){
  18077c:	0005883a 	mov	r2,zero
  180780:	00c10004 	movi	r3,1024
						rx_frame[x] = 0;
  180784:	1409883a 	add	r4,r2,r16
  180788:	20000005 	stb	zero,0(r4)

		// Set up non-blocking transfer of sgdma receive descriptor
		alt_avalon_sgdma_do_async_transfer( sgdma_rx_dev, &rx_descriptor );

		// Output received text
			for(int x = 0; x < 1024; x++){
  18078c:	10800044 	addi	r2,r2,1
  180790:	10fffc1e 	bne	r2,r3,180784 <rx_ethernet_isr+0xa8>
						rx_frame[x] = 0;
			}
}
  180794:	dfc00517 	ldw	ra,20(sp)
  180798:	dc000417 	ldw	r16,16(sp)
  18079c:	dec00604 	addi	sp,sp,24
  1807a0:	f800283a 	ret

001807a4 <setup>:
alt_sgdma_descriptor rx_descriptor_end  __attribute__ (( section ( ".descriptor_memory" )));

void setup(void)
{
	// Open the sgdma transmit device
	sgdma_tx_dev = alt_avalon_sgdma_open ("/dev/sgdma_tx");
  1807a4:	01000634 	movhi	r4,24

alt_sgdma_descriptor rx_descriptor  	__attribute__ (( section ( ".descriptor_memory" )));
alt_sgdma_descriptor rx_descriptor_end  __attribute__ (( section ( ".descriptor_memory" )));

void setup(void)
{
  1807a8:	defffe04 	addi	sp,sp,-8
	// Open the sgdma transmit device
	sgdma_tx_dev = alt_avalon_sgdma_open ("/dev/sgdma_tx");
  1807ac:	21083504 	addi	r4,r4,8404

alt_sgdma_descriptor rx_descriptor  	__attribute__ (( section ( ".descriptor_memory" )));
alt_sgdma_descriptor rx_descriptor_end  __attribute__ (( section ( ".descriptor_memory" )));

void setup(void)
{
  1807b0:	dfc00115 	stw	ra,4(sp)
	// Open the sgdma transmit device
	sgdma_tx_dev = alt_avalon_sgdma_open ("/dev/sgdma_tx");
  1807b4:	0181a040 	call	181a04 <alt_avalon_sgdma_open>
  1807b8:	d0a23815 	stw	r2,-30496(gp)
	if (sgdma_tx_dev == NULL) {
  1807bc:	1000031e 	bne	r2,zero,1807cc <setup+0x28>
		alt_printf ("Error: could not open scatter-gather dma transmit device\n");
  1807c0:	01000634 	movhi	r4,24
  1807c4:	21083904 	addi	r4,r4,8420
  1807c8:	00000206 	br	1807d4 <setup+0x30>
	} else alt_printf ("Opened scatter-gather dma transmit device\n");
  1807cc:	01000634 	movhi	r4,24
  1807d0:	21084804 	addi	r4,r4,8480
  1807d4:	01815940 	call	181594 <alt_printf>

	// Open the sgdma receive device
	sgdma_rx_dev = alt_avalon_sgdma_open ("/dev/sgdma_rx");
  1807d8:	01000634 	movhi	r4,24
  1807dc:	21085304 	addi	r4,r4,8524
  1807e0:	0181a040 	call	181a04 <alt_avalon_sgdma_open>
  1807e4:	d0a23a15 	stw	r2,-30488(gp)
	if (sgdma_rx_dev == NULL) {
  1807e8:	1000031e 	bne	r2,zero,1807f8 <setup+0x54>
		alt_printf ("Error: could not open scatter-gather dma receive device\n");
  1807ec:	01000634 	movhi	r4,24
  1807f0:	21085704 	addi	r4,r4,8540
  1807f4:	00000206 	br	180800 <setup+0x5c>
	} else alt_printf ("Opened scatter-gather dma receive device\n");
  1807f8:	01000634 	movhi	r4,24
  1807fc:	21086604 	addi	r4,r4,8600
  180800:	01815940 	call	181594 <alt_printf>

	// Set interrupts for the sgdma receive device
	alt_avalon_sgdma_register_callback( sgdma_rx_dev, (alt_avalon_sgdma_callback) rx_ethernet_isr, 0x00000014, NULL );
  180804:	d1223a17 	ldw	r4,-30488(gp)
  180808:	01400634 	movhi	r5,24
  18080c:	000f883a 	mov	r7,zero
  180810:	01800504 	movi	r6,20
  180814:	2941b704 	addi	r5,r5,1756
  180818:	01819940 	call	181994 <alt_avalon_sgdma_register_callback>

	// Create sgdma receive descriptor
	alt_avalon_sgdma_construct_stream_to_mem_desc( &rx_descriptor, &rx_descriptor_end, (alt_u32 *)rx_frame, 0, 0 );
  18081c:	01800634 	movhi	r6,24
  180820:	01400074 	movhi	r5,1
  180824:	01000074 	movhi	r4,1
  180828:	000f883a 	mov	r7,zero
  18082c:	318d1b04 	addi	r6,r6,13420
  180830:	29600004 	addi	r5,r5,-32768
  180834:	21200804 	addi	r4,r4,-32736
  180838:	d8000015 	stw	zero,0(sp)
  18083c:	0181c7c0 	call	181c7c <alt_avalon_sgdma_construct_stream_to_mem_desc>

	// Set up non-blocking transfer of sgdma receive descriptor
	alt_avalon_sgdma_do_async_transfer( sgdma_rx_dev, &rx_descriptor );
  180840:	d1223a17 	ldw	r4,-30488(gp)
  180844:	01400074 	movhi	r5,1
  180848:	29600804 	addi	r5,r5,-32736
  18084c:	01818980 	call	181898 <alt_avalon_sgdma_do_async_transfer>

	// Triple-speed Ethernet MegaCore base address
	volatile int * tse = (int *) ETH_TSE_BASE;

	// Initialize the MAC address
	*(tse + 3) = 0x116E6001;
  180850:	00800434 	movhi	r2,16
  180854:	00c45bb4 	movhi	r3,4462
  180858:	18d80044 	addi	r3,r3,24577
  18085c:	10880304 	addi	r2,r2,8204
  180860:	10c00015 	stw	r3,0(r2)
	*(tse + 4) = 0x00000F02;
  180864:	00800434 	movhi	r2,16
  180868:	00c3c084 	movi	r3,3842
  18086c:	10880404 	addi	r2,r2,8208
  180870:	10c00015 	stw	r3,0(r2)

	// Specify the addresses of the PHY devices to be accessed through MDIO interface
	*(tse + 0x0F) = 0x10;
  180874:	00800434 	movhi	r2,16
  180878:	00c00404 	movi	r3,16
  18087c:	10880f04 	addi	r2,r2,8252
  180880:	10c00015 	stw	r3,0(r2)
	*(tse + 0x10) = 0x11;
  180884:	00800434 	movhi	r2,16
  180888:	00c00444 	movi	r3,17
  18088c:	10881004 	addi	r2,r2,8256
  180890:	10c00015 	stw	r3,0(r2)

	// Write to register 20 of the PHY chip for Ethernet port 0 to set up line loopback
	*(tse + 0x94) = 0x4000;
  180894:	00800434 	movhi	r2,16
  180898:	00d00004 	movi	r3,16384
  18089c:	10889404 	addi	r2,r2,8784
  1808a0:	10c00015 	stw	r3,0(r2)

	// Write to register 16 of the PHY chip for Ethernet port 1 to enable automatic crossover for all modes
	*(tse + 0xB0) = *(tse + 0xB0) | 0x0060;
  1808a4:	00c00434 	movhi	r3,16
  1808a8:	18c8b004 	addi	r3,r3,8896
  1808ac:	18800017 	ldw	r2,0(r3)
  1808b0:	10801814 	ori	r2,r2,96
  1808b4:	18800015 	stw	r2,0(r3)

	// Write to register 20 of the PHY chip for Ethernet port 2 to set up delay for input/output clk
	*(tse + 0xB4) = *(tse + 0xB4) | 0x0082;
  1808b8:	00c00434 	movhi	r3,16
  1808bc:	18c8b404 	addi	r3,r3,8912
  1808c0:	18800017 	ldw	r2,0(r3)
  1808c4:	10802094 	ori	r2,r2,130
  1808c8:	18800015 	stw	r2,0(r3)

	// Software reset the second PHY chip and wait
	*(tse + 0xA0) = *(tse + 0xA0) | 0x8000;
  1808cc:	00800434 	movhi	r2,16
  1808d0:	1088a004 	addi	r2,r2,8832
  1808d4:	10c00017 	ldw	r3,0(r2)
  1808d8:	18e00014 	ori	r3,r3,32768
  1808dc:	10c00015 	stw	r3,0(r2)

	while ( *(tse + 0xA0) & 0x8000 );
  1808e0:	10c00017 	ldw	r3,0(r2)
  1808e4:	18e0000c 	andi	r3,r3,32768
  1808e8:	183ffd1e 	bne	r3,zero,1808e0 <setup+0x13c>
	alt_printf("help");
  1808ec:	01000634 	movhi	r4,24
  1808f0:	21087104 	addi	r4,r4,8644
  1808f4:	01815940 	call	181594 <alt_printf>

	// Enable read and write transfers, 100 mbit Ethernet operation, and CRC forwarding
	//*(tse + 2) = *(tse + 2) | 0x00000043;

	// Enable read and write transfers, gigabit Ethernet operation, and CRC forwarding
	*(tse + 2) = *(tse + 2) | 0x0000004B;
  1808f8:	00c00434 	movhi	r3,16
  1808fc:	18c80204 	addi	r3,r3,8200
  180900:	18800017 	ldw	r2,0(r3)
  180904:	108012d4 	ori	r2,r2,75
  180908:	18800015 	stw	r2,0(r3)
}
  18090c:	dfc00117 	ldw	ra,4(sp)
  180910:	dec00204 	addi	sp,sp,8
  180914:	f800283a 	ret

00180918 <refresh_ethernet>:

void refresh_ethernet(){
  180918:	f800283a 	ret

0018091c <tx_char>:
						rx_frame[x] = 0;
			}
}

void tx_char(char *c, int x){
	tx_frame[16 + x] = c;
  18091c:	00800634 	movhi	r2,24
  180920:	10894f04 	addi	r2,r2,9532
  180924:	288b883a 	add	r5,r5,r2
  180928:	29000005 	stb	r4,0(r5)
  18092c:	f800283a 	ret

00180930 <transmit>:
}

void transmit(){
  180930:	defffb04 	addi	sp,sp,-20
	// Create transmit sgdma descriptor
				alt_avalon_sgdma_construct_mem_to_stream_desc( &tx_descriptor, &tx_descriptor_end, (alt_u32 *)tx_frame, 62, 0, 1, 1, 0 );
  180934:	00800044 	movi	r2,1
  180938:	01800634 	movhi	r6,24
  18093c:	01400074 	movhi	r5,1
  180940:	01000074 	movhi	r4,1
  180944:	29601004 	addi	r5,r5,-32704
  180948:	21201804 	addi	r4,r4,-32672
  18094c:	d8000315 	stw	zero,12(sp)
  180950:	d8800215 	stw	r2,8(sp)
  180954:	d8800115 	stw	r2,4(sp)
  180958:	d8000015 	stw	zero,0(sp)
  18095c:	01c00f84 	movi	r7,62
  180960:	31894b04 	addi	r6,r6,9516

void tx_char(char *c, int x){
	tx_frame[16 + x] = c;
}

void transmit(){
  180964:	dfc00415 	stw	ra,16(sp)
	// Create transmit sgdma descriptor
				alt_avalon_sgdma_construct_mem_to_stream_desc( &tx_descriptor, &tx_descriptor_end, (alt_u32 *)tx_frame, 62, 0, 1, 1, 0 );
  180968:	0181cf40 	call	181cf4 <alt_avalon_sgdma_construct_mem_to_stream_desc>
				// Set up non-blocking transfer of sgdma transmit descriptor
				alt_avalon_sgdma_do_async_transfer( sgdma_tx_dev, &tx_descriptor );
  18096c:	d1223817 	ldw	r4,-30496(gp)
  180970:	01400074 	movhi	r5,1
  180974:	29601804 	addi	r5,r5,-32672
  180978:	01818980 	call	181898 <alt_avalon_sgdma_do_async_transfer>
				// Wait until transmit descriptor transfer is complete
				while (alt_avalon_sgdma_check_descriptor_status(&tx_descriptor) != 0);
  18097c:	01000074 	movhi	r4,1
  180980:	21201804 	addi	r4,r4,-32672
  180984:	01819d80 	call	1819d8 <alt_avalon_sgdma_check_descriptor_status>
  180988:	103ffc1e 	bne	r2,zero,18097c <transmit+0x4c>
}
  18098c:	dfc00417 	ldw	ra,16(sp)
  180990:	dec00504 	addi	sp,sp,20
  180994:	f800283a 	ret

00180998 <tx_ethernet_isr>:

void tx_ethernet_isr(char *chars){
  180998:	defff804 	addi	sp,sp,-32
  18099c:	dc800615 	stw	r18,24(sp)
  1809a0:	04800634 	movhi	r18,24
  1809a4:	dc400515 	stw	r17,20(sp)
  1809a8:	dc000415 	stw	r16,16(sp)
  1809ac:	dfc00715 	stw	ra,28(sp)
  1809b0:	2023883a 	mov	r17,r4
  1809b4:	94894f04 	addi	r18,r18,9532
			for(int x = 0; x < strlen(chars); x++){
  1809b8:	2021883a 	mov	r16,r4
  1809bc:	8809883a 	mov	r4,r17
  1809c0:	0180b200 	call	180b20 <strlen>
  1809c4:	8447c83a 	sub	r3,r16,r17
  1809c8:	1880052e 	bgeu	r3,r2,1809e0 <tx_ethernet_isr+0x48>
				tx_frame[16 + x] = chars[x];
  1809cc:	80800003 	ldbu	r2,0(r16)
  1809d0:	94800044 	addi	r18,r18,1
  1809d4:	84000044 	addi	r16,r16,1
  1809d8:	90bfffc5 	stb	r2,-1(r18)
  1809dc:	003ff706 	br	1809bc <tx_ethernet_isr+0x24>
			}
			// Create transmit sgdma descriptor
			alt_avalon_sgdma_construct_mem_to_stream_desc( &tx_descriptor, &tx_descriptor_end, (alt_u32 *)tx_frame, 62, 0, 1, 1, 0 );
  1809e0:	00800044 	movi	r2,1
  1809e4:	01800634 	movhi	r6,24
  1809e8:	01400074 	movhi	r5,1
  1809ec:	01000074 	movhi	r4,1
  1809f0:	29601004 	addi	r5,r5,-32704
  1809f4:	21201804 	addi	r4,r4,-32672
  1809f8:	d8000315 	stw	zero,12(sp)
  1809fc:	d8800215 	stw	r2,8(sp)
  180a00:	d8800115 	stw	r2,4(sp)
  180a04:	d8000015 	stw	zero,0(sp)
  180a08:	01c00f84 	movi	r7,62
  180a0c:	31894b04 	addi	r6,r6,9516
  180a10:	0181cf40 	call	181cf4 <alt_avalon_sgdma_construct_mem_to_stream_desc>
			// Set up non-blocking transfer of sgdma transmit descriptor
			alt_avalon_sgdma_do_async_transfer( sgdma_tx_dev, &tx_descriptor );
  180a14:	d1223817 	ldw	r4,-30496(gp)
  180a18:	01400074 	movhi	r5,1
  180a1c:	29601804 	addi	r5,r5,-32672
  180a20:	01818980 	call	181898 <alt_avalon_sgdma_do_async_transfer>
			// Wait until transmit descriptor transfer is complete
			while (alt_avalon_sgdma_check_descriptor_status(&tx_descriptor) != 0);
  180a24:	01000074 	movhi	r4,1
  180a28:	21201804 	addi	r4,r4,-32672
  180a2c:	01819d80 	call	1819d8 <alt_avalon_sgdma_check_descriptor_status>
  180a30:	103ffc1e 	bne	r2,zero,180a24 <tx_ethernet_isr+0x8c>

}
  180a34:	dfc00717 	ldw	ra,28(sp)
  180a38:	dc800617 	ldw	r18,24(sp)
  180a3c:	dc400517 	ldw	r17,20(sp)
  180a40:	dc000417 	ldw	r16,16(sp)
  180a44:	dec00804 	addi	sp,sp,32
  180a48:	f800283a 	ret

00180a4c <memcpy>:
  180a4c:	2005883a 	mov	r2,r4
  180a50:	2007883a 	mov	r3,r4
  180a54:	218d883a 	add	r6,r4,r6
  180a58:	19800526 	beq	r3,r6,180a70 <memcpy+0x24>
  180a5c:	29000003 	ldbu	r4,0(r5)
  180a60:	18c00044 	addi	r3,r3,1
  180a64:	29400044 	addi	r5,r5,1
  180a68:	193fffc5 	stb	r4,-1(r3)
  180a6c:	003ffa06 	br	180a58 <memcpy+0xc>
  180a70:	f800283a 	ret

00180a74 <_printf_r>:
  180a74:	defffd04 	addi	sp,sp,-12
  180a78:	dfc00015 	stw	ra,0(sp)
  180a7c:	d9800115 	stw	r6,4(sp)
  180a80:	d9c00215 	stw	r7,8(sp)
  180a84:	20c00217 	ldw	r3,8(r4)
  180a88:	01800634 	movhi	r6,24
  180a8c:	31843c04 	addi	r6,r6,4336
  180a90:	19800115 	stw	r6,4(r3)
  180a94:	280d883a 	mov	r6,r5
  180a98:	21400217 	ldw	r5,8(r4)
  180a9c:	d9c00104 	addi	r7,sp,4
  180aa0:	0180ba80 	call	180ba8 <___vfprintf_internal_r>
  180aa4:	dfc00017 	ldw	ra,0(sp)
  180aa8:	dec00304 	addi	sp,sp,12
  180aac:	f800283a 	ret

00180ab0 <printf>:
  180ab0:	defffc04 	addi	sp,sp,-16
  180ab4:	dfc00015 	stw	ra,0(sp)
  180ab8:	d9400115 	stw	r5,4(sp)
  180abc:	d9800215 	stw	r6,8(sp)
  180ac0:	d9c00315 	stw	r7,12(sp)
  180ac4:	00800634 	movhi	r2,24
  180ac8:	108a9c04 	addi	r2,r2,10864
  180acc:	10800017 	ldw	r2,0(r2)
  180ad0:	01400634 	movhi	r5,24
  180ad4:	29443c04 	addi	r5,r5,4336
  180ad8:	10c00217 	ldw	r3,8(r2)
  180adc:	d9800104 	addi	r6,sp,4
  180ae0:	19400115 	stw	r5,4(r3)
  180ae4:	200b883a 	mov	r5,r4
  180ae8:	11000217 	ldw	r4,8(r2)
  180aec:	01810d40 	call	1810d4 <__vfprintf_internal>
  180af0:	dfc00017 	ldw	ra,0(sp)
  180af4:	dec00404 	addi	sp,sp,16
  180af8:	f800283a 	ret

00180afc <_putchar_r>:
  180afc:	21800217 	ldw	r6,8(r4)
  180b00:	01811fc1 	jmpi	1811fc <_putc_r>

00180b04 <putchar>:
  180b04:	00800634 	movhi	r2,24
  180b08:	108a9c04 	addi	r2,r2,10864
  180b0c:	10800017 	ldw	r2,0(r2)
  180b10:	200b883a 	mov	r5,r4
  180b14:	11800217 	ldw	r6,8(r2)
  180b18:	1009883a 	mov	r4,r2
  180b1c:	01811fc1 	jmpi	1811fc <_putc_r>

00180b20 <strlen>:
  180b20:	2005883a 	mov	r2,r4
  180b24:	10c00007 	ldb	r3,0(r2)
  180b28:	18000226 	beq	r3,zero,180b34 <strlen+0x14>
  180b2c:	10800044 	addi	r2,r2,1
  180b30:	003ffc06 	br	180b24 <strlen+0x4>
  180b34:	1105c83a 	sub	r2,r2,r4
  180b38:	f800283a 	ret

00180b3c <print_repeat>:
  180b3c:	defffb04 	addi	sp,sp,-20
  180b40:	dc800315 	stw	r18,12(sp)
  180b44:	dc400215 	stw	r17,8(sp)
  180b48:	dc000115 	stw	r16,4(sp)
  180b4c:	dfc00415 	stw	ra,16(sp)
  180b50:	2025883a 	mov	r18,r4
  180b54:	2823883a 	mov	r17,r5
  180b58:	d9800005 	stb	r6,0(sp)
  180b5c:	3821883a 	mov	r16,r7
  180b60:	04000a0e 	bge	zero,r16,180b8c <print_repeat+0x50>
  180b64:	88800117 	ldw	r2,4(r17)
  180b68:	01c00044 	movi	r7,1
  180b6c:	d80d883a 	mov	r6,sp
  180b70:	880b883a 	mov	r5,r17
  180b74:	9009883a 	mov	r4,r18
  180b78:	103ee83a 	callr	r2
  180b7c:	843fffc4 	addi	r16,r16,-1
  180b80:	103ff726 	beq	r2,zero,180b60 <print_repeat+0x24>
  180b84:	00bfffc4 	movi	r2,-1
  180b88:	00000106 	br	180b90 <print_repeat+0x54>
  180b8c:	0005883a 	mov	r2,zero
  180b90:	dfc00417 	ldw	ra,16(sp)
  180b94:	dc800317 	ldw	r18,12(sp)
  180b98:	dc400217 	ldw	r17,8(sp)
  180b9c:	dc000117 	ldw	r16,4(sp)
  180ba0:	dec00504 	addi	sp,sp,20
  180ba4:	f800283a 	ret

00180ba8 <___vfprintf_internal_r>:
  180ba8:	deffe504 	addi	sp,sp,-108
  180bac:	d8c00804 	addi	r3,sp,32
  180bb0:	ddc01815 	stw	r23,96(sp)
  180bb4:	dd801715 	stw	r22,92(sp)
  180bb8:	dd401615 	stw	r21,88(sp)
  180bbc:	dd001515 	stw	r20,84(sp)
  180bc0:	dcc01415 	stw	r19,80(sp)
  180bc4:	dc801315 	stw	r18,76(sp)
  180bc8:	dc401215 	stw	r17,72(sp)
  180bcc:	dc001115 	stw	r16,68(sp)
  180bd0:	dfc01a15 	stw	ra,104(sp)
  180bd4:	df001915 	stw	fp,100(sp)
  180bd8:	2029883a 	mov	r20,r4
  180bdc:	2823883a 	mov	r17,r5
  180be0:	382d883a 	mov	r22,r7
  180be4:	d9800f15 	stw	r6,60(sp)
  180be8:	0021883a 	mov	r16,zero
  180bec:	d8000e15 	stw	zero,56(sp)
  180bf0:	d8000a15 	stw	zero,40(sp)
  180bf4:	002b883a 	mov	r21,zero
  180bf8:	0027883a 	mov	r19,zero
  180bfc:	0025883a 	mov	r18,zero
  180c00:	d8000c15 	stw	zero,48(sp)
  180c04:	d8000b15 	stw	zero,44(sp)
  180c08:	002f883a 	mov	r23,zero
  180c0c:	d8c00915 	stw	r3,36(sp)
  180c10:	d8c00f17 	ldw	r3,60(sp)
  180c14:	19000003 	ldbu	r4,0(r3)
  180c18:	20803fcc 	andi	r2,r4,255
  180c1c:	1080201c 	xori	r2,r2,128
  180c20:	10bfe004 	addi	r2,r2,-128
  180c24:	10011e26 	beq	r2,zero,1810a0 <___vfprintf_internal_r+0x4f8>
  180c28:	00c00044 	movi	r3,1
  180c2c:	b8c01426 	beq	r23,r3,180c80 <___vfprintf_internal_r+0xd8>
  180c30:	1dc00216 	blt	r3,r23,180c3c <___vfprintf_internal_r+0x94>
  180c34:	b8000626 	beq	r23,zero,180c50 <___vfprintf_internal_r+0xa8>
  180c38:	00011506 	br	181090 <___vfprintf_internal_r+0x4e8>
  180c3c:	01400084 	movi	r5,2
  180c40:	b9401d26 	beq	r23,r5,180cb8 <___vfprintf_internal_r+0x110>
  180c44:	014000c4 	movi	r5,3
  180c48:	b9402b26 	beq	r23,r5,180cf8 <___vfprintf_internal_r+0x150>
  180c4c:	00011006 	br	181090 <___vfprintf_internal_r+0x4e8>
  180c50:	01400944 	movi	r5,37
  180c54:	1140fc26 	beq	r2,r5,181048 <___vfprintf_internal_r+0x4a0>
  180c58:	88800117 	ldw	r2,4(r17)
  180c5c:	d9000005 	stb	r4,0(sp)
  180c60:	01c00044 	movi	r7,1
  180c64:	d80d883a 	mov	r6,sp
  180c68:	880b883a 	mov	r5,r17
  180c6c:	a009883a 	mov	r4,r20
  180c70:	103ee83a 	callr	r2
  180c74:	1000d81e 	bne	r2,zero,180fd8 <___vfprintf_internal_r+0x430>
  180c78:	84000044 	addi	r16,r16,1
  180c7c:	00010406 	br	181090 <___vfprintf_internal_r+0x4e8>
  180c80:	01400c04 	movi	r5,48
  180c84:	1140fa26 	beq	r2,r5,181070 <___vfprintf_internal_r+0x4c8>
  180c88:	01400944 	movi	r5,37
  180c8c:	11400a1e 	bne	r2,r5,180cb8 <___vfprintf_internal_r+0x110>
  180c90:	d8800005 	stb	r2,0(sp)
  180c94:	88800117 	ldw	r2,4(r17)
  180c98:	b80f883a 	mov	r7,r23
  180c9c:	d80d883a 	mov	r6,sp
  180ca0:	880b883a 	mov	r5,r17
  180ca4:	a009883a 	mov	r4,r20
  180ca8:	103ee83a 	callr	r2
  180cac:	1000ca1e 	bne	r2,zero,180fd8 <___vfprintf_internal_r+0x430>
  180cb0:	84000044 	addi	r16,r16,1
  180cb4:	0000f506 	br	18108c <___vfprintf_internal_r+0x4e4>
  180cb8:	25fff404 	addi	r23,r4,-48
  180cbc:	bdc03fcc 	andi	r23,r23,255
  180cc0:	00c00244 	movi	r3,9
  180cc4:	1dc00936 	bltu	r3,r23,180cec <___vfprintf_internal_r+0x144>
  180cc8:	00bfffc4 	movi	r2,-1
  180ccc:	90800426 	beq	r18,r2,180ce0 <___vfprintf_internal_r+0x138>
  180cd0:	01400284 	movi	r5,10
  180cd4:	9009883a 	mov	r4,r18
  180cd8:	01814600 	call	181460 <__mulsi3>
  180cdc:	00000106 	br	180ce4 <___vfprintf_internal_r+0x13c>
  180ce0:	0005883a 	mov	r2,zero
  180ce4:	b8a5883a 	add	r18,r23,r2
  180ce8:	0000e206 	br	181074 <___vfprintf_internal_r+0x4cc>
  180cec:	01400b84 	movi	r5,46
  180cf0:	1140e426 	beq	r2,r5,181084 <___vfprintf_internal_r+0x4dc>
  180cf4:	05c00084 	movi	r23,2
  180cf8:	213ff404 	addi	r4,r4,-48
  180cfc:	27003fcc 	andi	fp,r4,255
  180d00:	00c00244 	movi	r3,9
  180d04:	1f000936 	bltu	r3,fp,180d2c <___vfprintf_internal_r+0x184>
  180d08:	00bfffc4 	movi	r2,-1
  180d0c:	98800426 	beq	r19,r2,180d20 <___vfprintf_internal_r+0x178>
  180d10:	01400284 	movi	r5,10
  180d14:	9809883a 	mov	r4,r19
  180d18:	01814600 	call	181460 <__mulsi3>
  180d1c:	00000106 	br	180d24 <___vfprintf_internal_r+0x17c>
  180d20:	0005883a 	mov	r2,zero
  180d24:	e0a7883a 	add	r19,fp,r2
  180d28:	0000d906 	br	181090 <___vfprintf_internal_r+0x4e8>
  180d2c:	00c01b04 	movi	r3,108
  180d30:	10c0d226 	beq	r2,r3,18107c <___vfprintf_internal_r+0x4d4>
  180d34:	013fffc4 	movi	r4,-1
  180d38:	99000226 	beq	r19,r4,180d44 <___vfprintf_internal_r+0x19c>
  180d3c:	d8000b15 	stw	zero,44(sp)
  180d40:	00000106 	br	180d48 <___vfprintf_internal_r+0x1a0>
  180d44:	04c00044 	movi	r19,1
  180d48:	01001a44 	movi	r4,105
  180d4c:	11001626 	beq	r2,r4,180da8 <___vfprintf_internal_r+0x200>
  180d50:	20800916 	blt	r4,r2,180d78 <___vfprintf_internal_r+0x1d0>
  180d54:	010018c4 	movi	r4,99
  180d58:	11008826 	beq	r2,r4,180f7c <___vfprintf_internal_r+0x3d4>
  180d5c:	01001904 	movi	r4,100
  180d60:	11001126 	beq	r2,r4,180da8 <___vfprintf_internal_r+0x200>
  180d64:	01001604 	movi	r4,88
  180d68:	1100c81e 	bne	r2,r4,18108c <___vfprintf_internal_r+0x4e4>
  180d6c:	00c00044 	movi	r3,1
  180d70:	d8c00e15 	stw	r3,56(sp)
  180d74:	00001506 	br	180dcc <___vfprintf_internal_r+0x224>
  180d78:	01001cc4 	movi	r4,115
  180d7c:	11009826 	beq	r2,r4,180fe0 <___vfprintf_internal_r+0x438>
  180d80:	20800416 	blt	r4,r2,180d94 <___vfprintf_internal_r+0x1ec>
  180d84:	01001bc4 	movi	r4,111
  180d88:	1100c01e 	bne	r2,r4,18108c <___vfprintf_internal_r+0x4e4>
  180d8c:	05400204 	movi	r21,8
  180d90:	00000f06 	br	180dd0 <___vfprintf_internal_r+0x228>
  180d94:	01001d44 	movi	r4,117
  180d98:	11000d26 	beq	r2,r4,180dd0 <___vfprintf_internal_r+0x228>
  180d9c:	01001e04 	movi	r4,120
  180da0:	11000a26 	beq	r2,r4,180dcc <___vfprintf_internal_r+0x224>
  180da4:	0000b906 	br	18108c <___vfprintf_internal_r+0x4e4>
  180da8:	d8c00a17 	ldw	r3,40(sp)
  180dac:	b7000104 	addi	fp,r22,4
  180db0:	18000726 	beq	r3,zero,180dd0 <___vfprintf_internal_r+0x228>
  180db4:	df000d15 	stw	fp,52(sp)
  180db8:	b5c00017 	ldw	r23,0(r22)
  180dbc:	b800080e 	bge	r23,zero,180de0 <___vfprintf_internal_r+0x238>
  180dc0:	05efc83a 	sub	r23,zero,r23
  180dc4:	02400044 	movi	r9,1
  180dc8:	00000606 	br	180de4 <___vfprintf_internal_r+0x23c>
  180dcc:	05400404 	movi	r21,16
  180dd0:	b0c00104 	addi	r3,r22,4
  180dd4:	d8c00d15 	stw	r3,52(sp)
  180dd8:	b5c00017 	ldw	r23,0(r22)
  180ddc:	d8000a15 	stw	zero,40(sp)
  180de0:	0013883a 	mov	r9,zero
  180de4:	d839883a 	mov	fp,sp
  180de8:	b8001726 	beq	r23,zero,180e48 <___vfprintf_internal_r+0x2a0>
  180dec:	a80b883a 	mov	r5,r21
  180df0:	b809883a 	mov	r4,r23
  180df4:	da401015 	stw	r9,64(sp)
  180df8:	01813a40 	call	1813a4 <__udivsi3>
  180dfc:	a80b883a 	mov	r5,r21
  180e00:	1009883a 	mov	r4,r2
  180e04:	102d883a 	mov	r22,r2
  180e08:	01814600 	call	181460 <__mulsi3>
  180e0c:	b885c83a 	sub	r2,r23,r2
  180e10:	00c00244 	movi	r3,9
  180e14:	da401017 	ldw	r9,64(sp)
  180e18:	18800216 	blt	r3,r2,180e24 <___vfprintf_internal_r+0x27c>
  180e1c:	10800c04 	addi	r2,r2,48
  180e20:	00000506 	br	180e38 <___vfprintf_internal_r+0x290>
  180e24:	d8c00e17 	ldw	r3,56(sp)
  180e28:	18000226 	beq	r3,zero,180e34 <___vfprintf_internal_r+0x28c>
  180e2c:	10800dc4 	addi	r2,r2,55
  180e30:	00000106 	br	180e38 <___vfprintf_internal_r+0x290>
  180e34:	108015c4 	addi	r2,r2,87
  180e38:	e0800005 	stb	r2,0(fp)
  180e3c:	b02f883a 	mov	r23,r22
  180e40:	e7000044 	addi	fp,fp,1
  180e44:	003fe806 	br	180de8 <___vfprintf_internal_r+0x240>
  180e48:	e6efc83a 	sub	r23,fp,sp
  180e4c:	9dc5c83a 	sub	r2,r19,r23
  180e50:	0080090e 	bge	zero,r2,180e78 <___vfprintf_internal_r+0x2d0>
  180e54:	e085883a 	add	r2,fp,r2
  180e58:	01400c04 	movi	r5,48
  180e5c:	d8c00917 	ldw	r3,36(sp)
  180e60:	e009883a 	mov	r4,fp
  180e64:	e0c0032e 	bgeu	fp,r3,180e74 <___vfprintf_internal_r+0x2cc>
  180e68:	e7000044 	addi	fp,fp,1
  180e6c:	21400005 	stb	r5,0(r4)
  180e70:	e0bffa1e 	bne	fp,r2,180e5c <___vfprintf_internal_r+0x2b4>
  180e74:	e6efc83a 	sub	r23,fp,sp
  180e78:	d8c00b17 	ldw	r3,44(sp)
  180e7c:	4dd1883a 	add	r8,r9,r23
  180e80:	922dc83a 	sub	r22,r18,r8
  180e84:	18001626 	beq	r3,zero,180ee0 <___vfprintf_internal_r+0x338>
  180e88:	48000a26 	beq	r9,zero,180eb4 <___vfprintf_internal_r+0x30c>
  180e8c:	00800b44 	movi	r2,45
  180e90:	d8800805 	stb	r2,32(sp)
  180e94:	88800117 	ldw	r2,4(r17)
  180e98:	01c00044 	movi	r7,1
  180e9c:	d9800804 	addi	r6,sp,32
  180ea0:	880b883a 	mov	r5,r17
  180ea4:	a009883a 	mov	r4,r20
  180ea8:	103ee83a 	callr	r2
  180eac:	10004a1e 	bne	r2,zero,180fd8 <___vfprintf_internal_r+0x430>
  180eb0:	84000044 	addi	r16,r16,1
  180eb4:	0580070e 	bge	zero,r22,180ed4 <___vfprintf_internal_r+0x32c>
  180eb8:	b00f883a 	mov	r7,r22
  180ebc:	01800c04 	movi	r6,48
  180ec0:	880b883a 	mov	r5,r17
  180ec4:	a009883a 	mov	r4,r20
  180ec8:	0180b3c0 	call	180b3c <print_repeat>
  180ecc:	1000421e 	bne	r2,zero,180fd8 <___vfprintf_internal_r+0x430>
  180ed0:	85a1883a 	add	r16,r16,r22
  180ed4:	e02d883a 	mov	r22,fp
  180ed8:	bf2fc83a 	sub	r23,r23,fp
  180edc:	00002006 	br	180f60 <___vfprintf_internal_r+0x3b8>
  180ee0:	0580090e 	bge	zero,r22,180f08 <___vfprintf_internal_r+0x360>
  180ee4:	b00f883a 	mov	r7,r22
  180ee8:	01800804 	movi	r6,32
  180eec:	880b883a 	mov	r5,r17
  180ef0:	a009883a 	mov	r4,r20
  180ef4:	da401015 	stw	r9,64(sp)
  180ef8:	0180b3c0 	call	180b3c <print_repeat>
  180efc:	da401017 	ldw	r9,64(sp)
  180f00:	1000351e 	bne	r2,zero,180fd8 <___vfprintf_internal_r+0x430>
  180f04:	85a1883a 	add	r16,r16,r22
  180f08:	483ff226 	beq	r9,zero,180ed4 <___vfprintf_internal_r+0x32c>
  180f0c:	00800b44 	movi	r2,45
  180f10:	d8800805 	stb	r2,32(sp)
  180f14:	88800117 	ldw	r2,4(r17)
  180f18:	01c00044 	movi	r7,1
  180f1c:	d9800804 	addi	r6,sp,32
  180f20:	880b883a 	mov	r5,r17
  180f24:	a009883a 	mov	r4,r20
  180f28:	103ee83a 	callr	r2
  180f2c:	10002a1e 	bne	r2,zero,180fd8 <___vfprintf_internal_r+0x430>
  180f30:	84000044 	addi	r16,r16,1
  180f34:	003fe706 	br	180ed4 <___vfprintf_internal_r+0x32c>
  180f38:	b5bfffc4 	addi	r22,r22,-1
  180f3c:	b0800003 	ldbu	r2,0(r22)
  180f40:	01c00044 	movi	r7,1
  180f44:	d9800804 	addi	r6,sp,32
  180f48:	d8800805 	stb	r2,32(sp)
  180f4c:	88800117 	ldw	r2,4(r17)
  180f50:	880b883a 	mov	r5,r17
  180f54:	a009883a 	mov	r4,r20
  180f58:	103ee83a 	callr	r2
  180f5c:	10001e1e 	bne	r2,zero,180fd8 <___vfprintf_internal_r+0x430>
  180f60:	8585c83a 	sub	r2,r16,r22
  180f64:	b5c9883a 	add	r4,r22,r23
  180f68:	e085883a 	add	r2,fp,r2
  180f6c:	013ff216 	blt	zero,r4,180f38 <___vfprintf_internal_r+0x390>
  180f70:	1021883a 	mov	r16,r2
  180f74:	dd800d17 	ldw	r22,52(sp)
  180f78:	00004406 	br	18108c <___vfprintf_internal_r+0x4e4>
  180f7c:	00800044 	movi	r2,1
  180f80:	1480080e 	bge	r2,r18,180fa4 <___vfprintf_internal_r+0x3fc>
  180f84:	95ffffc4 	addi	r23,r18,-1
  180f88:	b80f883a 	mov	r7,r23
  180f8c:	01800804 	movi	r6,32
  180f90:	880b883a 	mov	r5,r17
  180f94:	a009883a 	mov	r4,r20
  180f98:	0180b3c0 	call	180b3c <print_repeat>
  180f9c:	10000e1e 	bne	r2,zero,180fd8 <___vfprintf_internal_r+0x430>
  180fa0:	85e1883a 	add	r16,r16,r23
  180fa4:	b0800017 	ldw	r2,0(r22)
  180fa8:	01c00044 	movi	r7,1
  180fac:	d80d883a 	mov	r6,sp
  180fb0:	d8800005 	stb	r2,0(sp)
  180fb4:	88800117 	ldw	r2,4(r17)
  180fb8:	880b883a 	mov	r5,r17
  180fbc:	a009883a 	mov	r4,r20
  180fc0:	b5c00104 	addi	r23,r22,4
  180fc4:	103ee83a 	callr	r2
  180fc8:	1000031e 	bne	r2,zero,180fd8 <___vfprintf_internal_r+0x430>
  180fcc:	84000044 	addi	r16,r16,1
  180fd0:	b82d883a 	mov	r22,r23
  180fd4:	00002d06 	br	18108c <___vfprintf_internal_r+0x4e4>
  180fd8:	00bfffc4 	movi	r2,-1
  180fdc:	00003106 	br	1810a4 <___vfprintf_internal_r+0x4fc>
  180fe0:	b5c00017 	ldw	r23,0(r22)
  180fe4:	b7000104 	addi	fp,r22,4
  180fe8:	b809883a 	mov	r4,r23
  180fec:	0180b200 	call	180b20 <strlen>
  180ff0:	9091c83a 	sub	r8,r18,r2
  180ff4:	102d883a 	mov	r22,r2
  180ff8:	0200090e 	bge	zero,r8,181020 <___vfprintf_internal_r+0x478>
  180ffc:	400f883a 	mov	r7,r8
  181000:	01800804 	movi	r6,32
  181004:	880b883a 	mov	r5,r17
  181008:	a009883a 	mov	r4,r20
  18100c:	da001015 	stw	r8,64(sp)
  181010:	0180b3c0 	call	180b3c <print_repeat>
  181014:	da001017 	ldw	r8,64(sp)
  181018:	103fef1e 	bne	r2,zero,180fd8 <___vfprintf_internal_r+0x430>
  18101c:	8221883a 	add	r16,r16,r8
  181020:	88800117 	ldw	r2,4(r17)
  181024:	b00f883a 	mov	r7,r22
  181028:	b80d883a 	mov	r6,r23
  18102c:	880b883a 	mov	r5,r17
  181030:	a009883a 	mov	r4,r20
  181034:	103ee83a 	callr	r2
  181038:	103fe71e 	bne	r2,zero,180fd8 <___vfprintf_internal_r+0x430>
  18103c:	85a1883a 	add	r16,r16,r22
  181040:	e02d883a 	mov	r22,fp
  181044:	00001106 	br	18108c <___vfprintf_internal_r+0x4e4>
  181048:	00c00044 	movi	r3,1
  18104c:	04ffffc4 	movi	r19,-1
  181050:	d8000e15 	stw	zero,56(sp)
  181054:	d8c00a15 	stw	r3,40(sp)
  181058:	05400284 	movi	r21,10
  18105c:	9825883a 	mov	r18,r19
  181060:	d8000c15 	stw	zero,48(sp)
  181064:	d8000b15 	stw	zero,44(sp)
  181068:	182f883a 	mov	r23,r3
  18106c:	00000806 	br	181090 <___vfprintf_internal_r+0x4e8>
  181070:	ddc00b15 	stw	r23,44(sp)
  181074:	05c00084 	movi	r23,2
  181078:	00000506 	br	181090 <___vfprintf_internal_r+0x4e8>
  18107c:	00c00044 	movi	r3,1
  181080:	d8c00c15 	stw	r3,48(sp)
  181084:	05c000c4 	movi	r23,3
  181088:	00000106 	br	181090 <___vfprintf_internal_r+0x4e8>
  18108c:	002f883a 	mov	r23,zero
  181090:	d8c00f17 	ldw	r3,60(sp)
  181094:	18c00044 	addi	r3,r3,1
  181098:	d8c00f15 	stw	r3,60(sp)
  18109c:	003edc06 	br	180c10 <___vfprintf_internal_r+0x68>
  1810a0:	8005883a 	mov	r2,r16
  1810a4:	dfc01a17 	ldw	ra,104(sp)
  1810a8:	df001917 	ldw	fp,100(sp)
  1810ac:	ddc01817 	ldw	r23,96(sp)
  1810b0:	dd801717 	ldw	r22,92(sp)
  1810b4:	dd401617 	ldw	r21,88(sp)
  1810b8:	dd001517 	ldw	r20,84(sp)
  1810bc:	dcc01417 	ldw	r19,80(sp)
  1810c0:	dc801317 	ldw	r18,76(sp)
  1810c4:	dc401217 	ldw	r17,72(sp)
  1810c8:	dc001117 	ldw	r16,68(sp)
  1810cc:	dec01b04 	addi	sp,sp,108
  1810d0:	f800283a 	ret

001810d4 <__vfprintf_internal>:
  1810d4:	00800634 	movhi	r2,24
  1810d8:	108a9c04 	addi	r2,r2,10864
  1810dc:	300f883a 	mov	r7,r6
  1810e0:	280d883a 	mov	r6,r5
  1810e4:	200b883a 	mov	r5,r4
  1810e8:	11000017 	ldw	r4,0(r2)
  1810ec:	0180ba81 	jmpi	180ba8 <___vfprintf_internal_r>

001810f0 <__sfvwrite_small_dev>:
  1810f0:	2880000b 	ldhu	r2,0(r5)
  1810f4:	1080020c 	andi	r2,r2,8
  1810f8:	10002126 	beq	r2,zero,181180 <__sfvwrite_small_dev+0x90>
  1810fc:	2880008f 	ldh	r2,2(r5)
  181100:	defffa04 	addi	sp,sp,-24
  181104:	dc000015 	stw	r16,0(sp)
  181108:	dfc00515 	stw	ra,20(sp)
  18110c:	dd000415 	stw	r20,16(sp)
  181110:	dcc00315 	stw	r19,12(sp)
  181114:	dc800215 	stw	r18,8(sp)
  181118:	dc400115 	stw	r17,4(sp)
  18111c:	2821883a 	mov	r16,r5
  181120:	10001216 	blt	r2,zero,18116c <__sfvwrite_small_dev+0x7c>
  181124:	2027883a 	mov	r19,r4
  181128:	3025883a 	mov	r18,r6
  18112c:	3823883a 	mov	r17,r7
  181130:	05010004 	movi	r20,1024
  181134:	04400b0e 	bge	zero,r17,181164 <__sfvwrite_small_dev+0x74>
  181138:	880f883a 	mov	r7,r17
  18113c:	a440010e 	bge	r20,r17,181144 <__sfvwrite_small_dev+0x54>
  181140:	01c10004 	movi	r7,1024
  181144:	8140008f 	ldh	r5,2(r16)
  181148:	900d883a 	mov	r6,r18
  18114c:	9809883a 	mov	r4,r19
  181150:	01812540 	call	181254 <_write_r>
  181154:	0080050e 	bge	zero,r2,18116c <__sfvwrite_small_dev+0x7c>
  181158:	88a3c83a 	sub	r17,r17,r2
  18115c:	90a5883a 	add	r18,r18,r2
  181160:	003ff406 	br	181134 <__sfvwrite_small_dev+0x44>
  181164:	0005883a 	mov	r2,zero
  181168:	00000706 	br	181188 <__sfvwrite_small_dev+0x98>
  18116c:	8080000b 	ldhu	r2,0(r16)
  181170:	10801014 	ori	r2,r2,64
  181174:	8080000d 	sth	r2,0(r16)
  181178:	00bfffc4 	movi	r2,-1
  18117c:	00000206 	br	181188 <__sfvwrite_small_dev+0x98>
  181180:	00bfffc4 	movi	r2,-1
  181184:	f800283a 	ret
  181188:	dfc00517 	ldw	ra,20(sp)
  18118c:	dd000417 	ldw	r20,16(sp)
  181190:	dcc00317 	ldw	r19,12(sp)
  181194:	dc800217 	ldw	r18,8(sp)
  181198:	dc400117 	ldw	r17,4(sp)
  18119c:	dc000017 	ldw	r16,0(sp)
  1811a0:	dec00604 	addi	sp,sp,24
  1811a4:	f800283a 	ret

001811a8 <putc>:
  1811a8:	defffd04 	addi	sp,sp,-12
  1811ac:	00800634 	movhi	r2,24
  1811b0:	dc000115 	stw	r16,4(sp)
  1811b4:	dfc00215 	stw	ra,8(sp)
  1811b8:	10843c04 	addi	r2,r2,4336
  1811bc:	28800115 	stw	r2,4(r5)
  1811c0:	00800634 	movhi	r2,24
  1811c4:	108a9c04 	addi	r2,r2,10864
  1811c8:	d9000005 	stb	r4,0(sp)
  1811cc:	2021883a 	mov	r16,r4
  1811d0:	11000017 	ldw	r4,0(r2)
  1811d4:	01c00044 	movi	r7,1
  1811d8:	d80d883a 	mov	r6,sp
  1811dc:	01810f00 	call	1810f0 <__sfvwrite_small_dev>
  1811e0:	00ffffc4 	movi	r3,-1
  1811e4:	10c00126 	beq	r2,r3,1811ec <putc+0x44>
  1811e8:	8005883a 	mov	r2,r16
  1811ec:	dfc00217 	ldw	ra,8(sp)
  1811f0:	dc000117 	ldw	r16,4(sp)
  1811f4:	dec00304 	addi	sp,sp,12
  1811f8:	f800283a 	ret

001811fc <_putc_r>:
  1811fc:	defffd04 	addi	sp,sp,-12
  181200:	00800634 	movhi	r2,24
  181204:	dc000115 	stw	r16,4(sp)
  181208:	dfc00215 	stw	ra,8(sp)
  18120c:	10843c04 	addi	r2,r2,4336
  181210:	30800115 	stw	r2,4(r6)
  181214:	00800634 	movhi	r2,24
  181218:	108a9c04 	addi	r2,r2,10864
  18121c:	11000017 	ldw	r4,0(r2)
  181220:	2821883a 	mov	r16,r5
  181224:	01c00044 	movi	r7,1
  181228:	300b883a 	mov	r5,r6
  18122c:	d80d883a 	mov	r6,sp
  181230:	dc000005 	stb	r16,0(sp)
  181234:	01810f00 	call	1810f0 <__sfvwrite_small_dev>
  181238:	00ffffc4 	movi	r3,-1
  18123c:	10c00126 	beq	r2,r3,181244 <_putc_r+0x48>
  181240:	8005883a 	mov	r2,r16
  181244:	dfc00217 	ldw	ra,8(sp)
  181248:	dc000117 	ldw	r16,4(sp)
  18124c:	dec00304 	addi	sp,sp,12
  181250:	f800283a 	ret

00181254 <_write_r>:
  181254:	defffd04 	addi	sp,sp,-12
  181258:	dc000015 	stw	r16,0(sp)
  18125c:	04000634 	movhi	r16,24
  181260:	dc400115 	stw	r17,4(sp)
  181264:	840cd604 	addi	r16,r16,13144
  181268:	2023883a 	mov	r17,r4
  18126c:	2809883a 	mov	r4,r5
  181270:	300b883a 	mov	r5,r6
  181274:	380d883a 	mov	r6,r7
  181278:	dfc00215 	stw	ra,8(sp)
  18127c:	80000015 	stw	zero,0(r16)
  181280:	01817500 	call	181750 <write>
  181284:	00ffffc4 	movi	r3,-1
  181288:	10c0031e 	bne	r2,r3,181298 <_write_r+0x44>
  18128c:	80c00017 	ldw	r3,0(r16)
  181290:	18000126 	beq	r3,zero,181298 <_write_r+0x44>
  181294:	88c00015 	stw	r3,0(r17)
  181298:	dfc00217 	ldw	ra,8(sp)
  18129c:	dc400117 	ldw	r17,4(sp)
  1812a0:	dc000017 	ldw	r16,0(sp)
  1812a4:	dec00304 	addi	sp,sp,12
  1812a8:	f800283a 	ret

001812ac <__divsi3>:
  1812ac:	20001b16 	blt	r4,zero,18131c <__divsi3+0x70>
  1812b0:	000f883a 	mov	r7,zero
  1812b4:	28001616 	blt	r5,zero,181310 <__divsi3+0x64>
  1812b8:	200d883a 	mov	r6,r4
  1812bc:	29001a2e 	bgeu	r5,r4,181328 <__divsi3+0x7c>
  1812c0:	00800804 	movi	r2,32
  1812c4:	00c00044 	movi	r3,1
  1812c8:	00000106 	br	1812d0 <__divsi3+0x24>
  1812cc:	10000d26 	beq	r2,zero,181304 <__divsi3+0x58>
  1812d0:	294b883a 	add	r5,r5,r5
  1812d4:	10bfffc4 	addi	r2,r2,-1
  1812d8:	18c7883a 	add	r3,r3,r3
  1812dc:	293ffb36 	bltu	r5,r4,1812cc <__divsi3+0x20>
  1812e0:	0005883a 	mov	r2,zero
  1812e4:	18000726 	beq	r3,zero,181304 <__divsi3+0x58>
  1812e8:	0005883a 	mov	r2,zero
  1812ec:	31400236 	bltu	r6,r5,1812f8 <__divsi3+0x4c>
  1812f0:	314dc83a 	sub	r6,r6,r5
  1812f4:	10c4b03a 	or	r2,r2,r3
  1812f8:	1806d07a 	srli	r3,r3,1
  1812fc:	280ad07a 	srli	r5,r5,1
  181300:	183ffa1e 	bne	r3,zero,1812ec <__divsi3+0x40>
  181304:	38000126 	beq	r7,zero,18130c <__divsi3+0x60>
  181308:	0085c83a 	sub	r2,zero,r2
  18130c:	f800283a 	ret
  181310:	014bc83a 	sub	r5,zero,r5
  181314:	39c0005c 	xori	r7,r7,1
  181318:	003fe706 	br	1812b8 <__divsi3+0xc>
  18131c:	0109c83a 	sub	r4,zero,r4
  181320:	01c00044 	movi	r7,1
  181324:	003fe306 	br	1812b4 <__divsi3+0x8>
  181328:	00c00044 	movi	r3,1
  18132c:	003fee06 	br	1812e8 <__divsi3+0x3c>

00181330 <__modsi3>:
  181330:	20001716 	blt	r4,zero,181390 <__modsi3+0x60>
  181334:	000f883a 	mov	r7,zero
  181338:	2005883a 	mov	r2,r4
  18133c:	28001216 	blt	r5,zero,181388 <__modsi3+0x58>
  181340:	2900162e 	bgeu	r5,r4,18139c <__modsi3+0x6c>
  181344:	01800804 	movi	r6,32
  181348:	00c00044 	movi	r3,1
  18134c:	00000106 	br	181354 <__modsi3+0x24>
  181350:	30000a26 	beq	r6,zero,18137c <__modsi3+0x4c>
  181354:	294b883a 	add	r5,r5,r5
  181358:	31bfffc4 	addi	r6,r6,-1
  18135c:	18c7883a 	add	r3,r3,r3
  181360:	293ffb36 	bltu	r5,r4,181350 <__modsi3+0x20>
  181364:	18000526 	beq	r3,zero,18137c <__modsi3+0x4c>
  181368:	1806d07a 	srli	r3,r3,1
  18136c:	11400136 	bltu	r2,r5,181374 <__modsi3+0x44>
  181370:	1145c83a 	sub	r2,r2,r5
  181374:	280ad07a 	srli	r5,r5,1
  181378:	183ffb1e 	bne	r3,zero,181368 <__modsi3+0x38>
  18137c:	38000126 	beq	r7,zero,181384 <__modsi3+0x54>
  181380:	0085c83a 	sub	r2,zero,r2
  181384:	f800283a 	ret
  181388:	014bc83a 	sub	r5,zero,r5
  18138c:	003fec06 	br	181340 <__modsi3+0x10>
  181390:	0109c83a 	sub	r4,zero,r4
  181394:	01c00044 	movi	r7,1
  181398:	003fe706 	br	181338 <__modsi3+0x8>
  18139c:	00c00044 	movi	r3,1
  1813a0:	003ff106 	br	181368 <__modsi3+0x38>

001813a4 <__udivsi3>:
  1813a4:	200d883a 	mov	r6,r4
  1813a8:	2900152e 	bgeu	r5,r4,181400 <__udivsi3+0x5c>
  1813ac:	28001416 	blt	r5,zero,181400 <__udivsi3+0x5c>
  1813b0:	00800804 	movi	r2,32
  1813b4:	00c00044 	movi	r3,1
  1813b8:	00000206 	br	1813c4 <__udivsi3+0x20>
  1813bc:	10000e26 	beq	r2,zero,1813f8 <__udivsi3+0x54>
  1813c0:	28000516 	blt	r5,zero,1813d8 <__udivsi3+0x34>
  1813c4:	294b883a 	add	r5,r5,r5
  1813c8:	10bfffc4 	addi	r2,r2,-1
  1813cc:	18c7883a 	add	r3,r3,r3
  1813d0:	293ffa36 	bltu	r5,r4,1813bc <__udivsi3+0x18>
  1813d4:	18000826 	beq	r3,zero,1813f8 <__udivsi3+0x54>
  1813d8:	0005883a 	mov	r2,zero
  1813dc:	31400236 	bltu	r6,r5,1813e8 <__udivsi3+0x44>
  1813e0:	314dc83a 	sub	r6,r6,r5
  1813e4:	10c4b03a 	or	r2,r2,r3
  1813e8:	1806d07a 	srli	r3,r3,1
  1813ec:	280ad07a 	srli	r5,r5,1
  1813f0:	183ffa1e 	bne	r3,zero,1813dc <__udivsi3+0x38>
  1813f4:	f800283a 	ret
  1813f8:	0005883a 	mov	r2,zero
  1813fc:	f800283a 	ret
  181400:	00c00044 	movi	r3,1
  181404:	003ff406 	br	1813d8 <__udivsi3+0x34>

00181408 <__umodsi3>:
  181408:	2005883a 	mov	r2,r4
  18140c:	2900122e 	bgeu	r5,r4,181458 <__umodsi3+0x50>
  181410:	28001116 	blt	r5,zero,181458 <__umodsi3+0x50>
  181414:	01800804 	movi	r6,32
  181418:	00c00044 	movi	r3,1
  18141c:	00000206 	br	181428 <__umodsi3+0x20>
  181420:	30000c26 	beq	r6,zero,181454 <__umodsi3+0x4c>
  181424:	28000516 	blt	r5,zero,18143c <__umodsi3+0x34>
  181428:	294b883a 	add	r5,r5,r5
  18142c:	31bfffc4 	addi	r6,r6,-1
  181430:	18c7883a 	add	r3,r3,r3
  181434:	293ffa36 	bltu	r5,r4,181420 <__umodsi3+0x18>
  181438:	18000626 	beq	r3,zero,181454 <__umodsi3+0x4c>
  18143c:	1806d07a 	srli	r3,r3,1
  181440:	11400136 	bltu	r2,r5,181448 <__umodsi3+0x40>
  181444:	1145c83a 	sub	r2,r2,r5
  181448:	280ad07a 	srli	r5,r5,1
  18144c:	183ffb1e 	bne	r3,zero,18143c <__umodsi3+0x34>
  181450:	f800283a 	ret
  181454:	f800283a 	ret
  181458:	00c00044 	movi	r3,1
  18145c:	003ff706 	br	18143c <__umodsi3+0x34>

00181460 <__mulsi3>:
  181460:	0005883a 	mov	r2,zero
  181464:	20000726 	beq	r4,zero,181484 <__mulsi3+0x24>
  181468:	20c0004c 	andi	r3,r4,1
  18146c:	2008d07a 	srli	r4,r4,1
  181470:	18000126 	beq	r3,zero,181478 <__mulsi3+0x18>
  181474:	1145883a 	add	r2,r2,r5
  181478:	294b883a 	add	r5,r5,r5
  18147c:	203ffa1e 	bne	r4,zero,181468 <__mulsi3+0x8>
  181480:	f800283a 	ret
  181484:	f800283a 	ret

00181488 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
  181488:	deffff04 	addi	sp,sp,-4
  18148c:	01000634 	movhi	r4,24
  181490:	01400634 	movhi	r5,24
  181494:	dfc00015 	stw	ra,0(sp)
  181498:	21087304 	addi	r4,r4,8652
  18149c:	294aa204 	addi	r5,r5,10888

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  1814a0:	2140061e 	bne	r4,r5,1814bc <alt_load+0x34>
  1814a4:	01000634 	movhi	r4,24
  1814a8:	01400634 	movhi	r5,24
  1814ac:	21000804 	addi	r4,r4,32
  1814b0:	29400804 	addi	r5,r5,32
  1814b4:	2140121e 	bne	r4,r5,181500 <alt_load+0x78>
  1814b8:	00000b06 	br	1814e8 <alt_load+0x60>
  1814bc:	00c00634 	movhi	r3,24
  1814c0:	18caa204 	addi	r3,r3,10888
  1814c4:	1907c83a 	sub	r3,r3,r4
  1814c8:	0005883a 	mov	r2,zero
  {
    while( to != end )
  1814cc:	10fff526 	beq	r2,r3,1814a4 <alt_load+0x1c>
    {
      *to++ = *from++;
  1814d0:	114f883a 	add	r7,r2,r5
  1814d4:	39c00017 	ldw	r7,0(r7)
  1814d8:	110d883a 	add	r6,r2,r4
  1814dc:	10800104 	addi	r2,r2,4
  1814e0:	31c00015 	stw	r7,0(r6)
  1814e4:	003ff906 	br	1814cc <alt_load+0x44>
  1814e8:	01000634 	movhi	r4,24
  1814ec:	01400634 	movhi	r5,24
  1814f0:	21082804 	addi	r4,r4,8352
  1814f4:	29482804 	addi	r5,r5,8352

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  1814f8:	2140101e 	bne	r4,r5,18153c <alt_load+0xb4>
  1814fc:	00000b06 	br	18152c <alt_load+0xa4>
  181500:	00c00634 	movhi	r3,24
  181504:	18c05304 	addi	r3,r3,332
  181508:	1907c83a 	sub	r3,r3,r4
  18150c:	0005883a 	mov	r2,zero
  {
    while( to != end )
  181510:	10fff526 	beq	r2,r3,1814e8 <alt_load+0x60>
    {
      *to++ = *from++;
  181514:	114f883a 	add	r7,r2,r5
  181518:	39c00017 	ldw	r7,0(r7)
  18151c:	110d883a 	add	r6,r2,r4
  181520:	10800104 	addi	r2,r2,4
  181524:	31c00015 	stw	r7,0(r6)
  181528:	003ff906 	br	181510 <alt_load+0x88>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  18152c:	0181e8c0 	call	181e8c <alt_dcache_flush_all>
  alt_icache_flush_all();
}
  181530:	dfc00017 	ldw	ra,0(sp)
  181534:	dec00104 	addi	sp,sp,4
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  alt_icache_flush_all();
  181538:	0181f701 	jmpi	181f70 <alt_icache_flush_all>
  18153c:	00c00634 	movhi	r3,24
  181540:	18c87304 	addi	r3,r3,8652
  181544:	1907c83a 	sub	r3,r3,r4

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  181548:	0005883a 	mov	r2,zero
  {
    while( to != end )
  18154c:	18bff726 	beq	r3,r2,18152c <alt_load+0xa4>
    {
      *to++ = *from++;
  181550:	114f883a 	add	r7,r2,r5
  181554:	39c00017 	ldw	r7,0(r7)
  181558:	110d883a 	add	r6,r2,r4
  18155c:	10800104 	addi	r2,r2,4
  181560:	31c00015 	stw	r7,0(r6)
  181564:	003ff906 	br	18154c <alt_load+0xc4>

00181568 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
  181568:	deffff04 	addi	sp,sp,-4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
  18156c:	0009883a 	mov	r4,zero
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
  181570:	dfc00015 	stw	ra,0(sp)
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
  181574:	01817b00 	call	1817b0 <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
  181578:	01817d00 	call	1817d0 <alt_sys_init>
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
  18157c:	d1a23c17 	ldw	r6,-30480(gp)
  181580:	d1623d17 	ldw	r5,-30476(gp)
  181584:	d1223e17 	ldw	r4,-30472(gp)
  close(STDOUT_FILENO);
  exit (result);
#endif

  ALT_LOG_PRINT_BOOT("[alt_main.c] After main - we should not be here?.\r\n");
}
  181588:	dfc00017 	ldw	ra,0(sp)
  18158c:	dec00104 	addi	sp,sp,4
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
  181590:	01806a81 	jmpi	1806a8 <main>

00181594 <alt_printf>:
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
  181594:	defff204 	addi	sp,sp,-56
  181598:	2005883a 	mov	r2,r4
  18159c:	dfc00a15 	stw	ra,40(sp)
  1815a0:	df000915 	stw	fp,36(sp)
  1815a4:	ddc00815 	stw	r23,32(sp)
  1815a8:	dd800715 	stw	r22,28(sp)
  1815ac:	dd400615 	stw	r21,24(sp)
  1815b0:	dd000515 	stw	r20,20(sp)
  1815b4:	dcc00415 	stw	r19,16(sp)
  1815b8:	dc800315 	stw	r18,12(sp)
  1815bc:	dc400215 	stw	r17,8(sp)
  1815c0:	dc000115 	stw	r16,4(sp)
  1815c4:	d9400b15 	stw	r5,44(sp)
  1815c8:	d9800c15 	stw	r6,48(sp)
  1815cc:	d9c00d15 	stw	r7,52(sp)
    w = fmt;
    while ((c = *w++) != 0)
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
  1815d0:	04000944 	movi	r16,37
 */
void 
alt_printf(const char* fmt, ... )
{
	va_list args;
	va_start(args, fmt);
  1815d4:	dd400b04 	addi	r21,sp,44
                if (c == '%')
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
                } 
                else if (c == 'c')
  1815d8:	048018c4 	movi	r18,99
                {
                    int v = va_arg(args, int);
                    alt_putchar(v);
                }
                else if (c == 'x')
  1815dc:	04c01e04 	movi	r19,120
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
  1815e0:	05001cc4 	movi	r20,115
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
  1815e4:	11000007 	ldb	r4,0(r2)
  1815e8:	20003a26 	beq	r4,zero,1816d4 <alt_printf+0x140>
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
  1815ec:	24000226 	beq	r4,r16,1815f8 <alt_printf+0x64>
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
  1815f0:	14400044 	addi	r17,r2,1
  1815f4:	00001406 	br	181648 <alt_printf+0xb4>
        }
        else
        {
            /* Get format character.  If none     */
            /* available, processing is complete. */
            if ((c = *w++) != 0)
  1815f8:	14400084 	addi	r17,r2,2
  1815fc:	10800047 	ldb	r2,1(r2)
  181600:	10003426 	beq	r2,zero,1816d4 <alt_printf+0x140>
            {
                if (c == '%')
  181604:	1400021e 	bne	r2,r16,181610 <alt_printf+0x7c>
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
  181608:	8009883a 	mov	r4,r16
  18160c:	00000e06 	br	181648 <alt_printf+0xb4>
                } 
                else if (c == 'c')
  181610:	1480051e 	bne	r2,r18,181628 <alt_printf+0x94>
                {
                    int v = va_arg(args, int);
                    alt_putchar(v);
  181614:	a9000017 	ldw	r4,0(r21)
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
                } 
                else if (c == 'c')
                {
                    int v = va_arg(args, int);
  181618:	ad800104 	addi	r22,r21,4
  18161c:	b02b883a 	mov	r21,r22
                    alt_putchar(v);
  181620:	01817040 	call	181704 <alt_putchar>
  181624:	00002906 	br	1816cc <alt_printf+0x138>
                }
                else if (c == 'x')
  181628:	14c0201e 	bne	r2,r19,1816ac <alt_printf+0x118>
                {
                    /* Process hexadecimal number format. */
                    unsigned long v = va_arg(args, unsigned long);
  18162c:	adc00017 	ldw	r23,0(r21)
  181630:	ad400104 	addi	r21,r21,4
                    unsigned long digit;
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
  181634:	b8000326 	beq	r23,zero,181644 <alt_printf+0xb0>
  181638:	05800704 	movi	r22,28
                        continue;
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
  18163c:	00c003c4 	movi	r3,15
  181640:	00000306 	br	181650 <alt_printf+0xbc>
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
                    {
                        alt_putchar('0');
  181644:	01000c04 	movi	r4,48
  181648:	01817040 	call	181704 <alt_putchar>
                        continue;
  18164c:	00001f06 	br	1816cc <alt_printf+0x138>
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
  181650:	1d84983a 	sll	r2,r3,r22
  181654:	15c4703a 	and	r2,r2,r23
  181658:	1000021e 	bne	r2,zero,181664 <alt_printf+0xd0>
                        digit_shift -= 4;
  18165c:	b5bfff04 	addi	r22,r22,-4
  181660:	003ffb06 	br	181650 <alt_printf+0xbc>

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
  181664:	070003c4 	movi	fp,15
                        if (digit <= 9)
  181668:	00c00244 	movi	r3,9
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
  18166c:	b0001716 	blt	r22,zero,1816cc <alt_printf+0x138>
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
  181670:	e588983a 	sll	r4,fp,r22
  181674:	25c8703a 	and	r4,r4,r23
  181678:	2588d83a 	srl	r4,r4,r22
                        if (digit <= 9)
  18167c:	19000236 	bltu	r3,r4,181688 <alt_printf+0xf4>
                            c = '0' + digit;
  181680:	21000c04 	addi	r4,r4,48
  181684:	00000106 	br	18168c <alt_printf+0xf8>
                        else
                            c = 'a' + digit - 10;
  181688:	210015c4 	addi	r4,r4,87
                        alt_putchar(c);
  18168c:	21003fcc 	andi	r4,r4,255
  181690:	2100201c 	xori	r4,r4,128
  181694:	213fe004 	addi	r4,r4,-128
  181698:	d8c00015 	stw	r3,0(sp)
  18169c:	01817040 	call	181704 <alt_putchar>
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
  1816a0:	b5bfff04 	addi	r22,r22,-4
  1816a4:	d8c00017 	ldw	r3,0(sp)
  1816a8:	003ff006 	br	18166c <alt_printf+0xd8>
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
  1816ac:	1500071e 	bne	r2,r20,1816cc <alt_printf+0x138>
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);
  1816b0:	ad800017 	ldw	r22,0(r21)
  1816b4:	ad400104 	addi	r21,r21,4

                    while(*s)
  1816b8:	b1000007 	ldb	r4,0(r22)
  1816bc:	20000326 	beq	r4,zero,1816cc <alt_printf+0x138>
                      alt_putchar(*s++);
  1816c0:	b5800044 	addi	r22,r22,1
  1816c4:	01817040 	call	181704 <alt_putchar>
  1816c8:	003ffb06 	br	1816b8 <alt_printf+0x124>
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
                } 
                else if (c == 'c')
                {
                    int v = va_arg(args, int);
  1816cc:	8805883a 	mov	r2,r17
  1816d0:	003fc406 	br	1815e4 <alt_printf+0x50>
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
  1816d4:	dfc00a17 	ldw	ra,40(sp)
  1816d8:	df000917 	ldw	fp,36(sp)
  1816dc:	ddc00817 	ldw	r23,32(sp)
  1816e0:	dd800717 	ldw	r22,28(sp)
  1816e4:	dd400617 	ldw	r21,24(sp)
  1816e8:	dd000517 	ldw	r20,20(sp)
  1816ec:	dcc00417 	ldw	r19,16(sp)
  1816f0:	dc800317 	ldw	r18,12(sp)
  1816f4:	dc400217 	ldw	r17,8(sp)
  1816f8:	dc000117 	ldw	r16,4(sp)
  1816fc:	dec00e04 	addi	sp,sp,56
  181700:	f800283a 	ret

00181704 <alt_putchar>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
  181704:	defffd04 	addi	sp,sp,-12
  181708:	dc000115 	stw	r16,4(sp)
	char        c1 = (char)(c & 0xff);
    return write(STDOUT_FILENO,&c1,1);
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    char        c1 = (char)(c & 0xff);
  18170c:	d9000005 	stb	r4,0(sp)
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
  181710:	2021883a 	mov	r16,r4
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    char        c1 = (char)(c & 0xff);

    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
  181714:	01000634 	movhi	r4,24
  181718:	000f883a 	mov	r7,zero
  18171c:	01800044 	movi	r6,1
  181720:	d80b883a 	mov	r5,sp
  181724:	210a9d04 	addi	r4,r4,10868
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
  181728:	dfc00215 	stw	ra,8(sp)
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    char        c1 = (char)(c & 0xff);

    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
  18172c:	01818080 	call	181808 <altera_avalon_jtag_uart_write>
  181730:	00ffffc4 	movi	r3,-1
  181734:	10c00126 	beq	r2,r3,18173c <alt_putchar+0x38>
        return -1;
    }
    return c;
  181738:	8005883a 	mov	r2,r16
#else
    return putchar(c);
#endif
#endif
}
  18173c:	dfc00217 	ldw	ra,8(sp)
  181740:	dc000117 	ldw	r16,4(sp)
  181744:	dec00304 	addi	sp,sp,12
  181748:	f800283a 	ret

0018174c <usleep>:
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
  return alt_busy_sleep(us);
  18174c:	0181e001 	jmpi	181e00 <alt_busy_sleep>

00181750 <write>:
#if !defined(ALT_STDOUT_PRESENT) && !defined(ALT_STDERR_PRESENT)
    /* Generate a link time warning, should this function ever be called. */
    ALT_STUB_WARNING(write);
#endif

    switch (file) {
  181750:	00800044 	movi	r2,1
  181754:	20800226 	beq	r4,r2,181760 <write+0x10>
  181758:	00800084 	movi	r2,2
  18175c:	2080041e 	bne	r4,r2,181770 <write+0x20>
    case 1: /* stdout file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, ptr, len, 0);
#endif /* ALT_STDOUT_PRESENT */
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
  181760:	01000634 	movhi	r4,24
  181764:	000f883a 	mov	r7,zero
  181768:	210a9d04 	addi	r4,r4,10868
  18176c:	01818081 	jmpi	181808 <altera_avalon_jtag_uart_write>

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  return ((alt_errno) ? alt_errno() : &errno);
  181770:	d0a00517 	ldw	r2,-32748(gp)
  181774:	10000926 	beq	r2,zero,18179c <write+0x4c>
 * Provide minimal version that just writes to the stdout/stderr devices
 * when provided.
 */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
  181778:	deffff04 	addi	sp,sp,-4
  18177c:	dfc00015 	stw	ra,0(sp)
  181780:	103ee83a 	callr	r2
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
#endif /* ALT_STDERR_PRESENT */
    default:
        ALT_ERRNO = EBADFD;
  181784:	00c01444 	movi	r3,81
  181788:	10c00015 	stw	r3,0(r2)
        return -1;
    }
}
  18178c:	00bfffc4 	movi	r2,-1
  181790:	dfc00017 	ldw	ra,0(sp)
  181794:	dec00104 	addi	sp,sp,4
  181798:	f800283a 	ret
  18179c:	d0a23b04 	addi	r2,gp,-30484
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
#endif /* ALT_STDERR_PRESENT */
    default:
        ALT_ERRNO = EBADFD;
  1817a0:	00c01444 	movi	r3,81
  1817a4:	10c00015 	stw	r3,0(r2)
        return -1;
    }
}
  1817a8:	00bfffc4 	movi	r2,-1
  1817ac:	f800283a 	ret

001817b0 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
  1817b0:	deffff04 	addi	sp,sp,-4
  1817b4:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2, nios2);
  1817b8:	01820680 	call	182068 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
  1817bc:	00800044 	movi	r2,1
  1817c0:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
  1817c4:	dfc00017 	ldw	ra,0(sp)
  1817c8:	dec00104 	addi	sp,sp,4
  1817cc:	f800283a 	ret

001817d0 <alt_sys_init>:
 */

void alt_sys_init( void )
{
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_RX, sgdma_rx);
  1817d0:	01000634 	movhi	r4,24
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
  1817d4:	deffff04 	addi	sp,sp,-4
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_RX, sgdma_rx);
  1817d8:	000d883a 	mov	r6,zero
  1817dc:	000b883a 	mov	r5,zero
  1817e0:	210a8f04 	addi	r4,r4,10812
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
  1817e4:	dfc00015 	stw	ra,0(sp)
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_RX, sgdma_rx);
  1817e8:	0181d7c0 	call	181d7c <alt_avalon_sgdma_init>
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_TX, sgdma_tx);
  1817ec:	01000634 	movhi	r4,24
  1817f0:	01800044 	movi	r6,1
  1817f4:	000b883a 	mov	r5,zero
  1817f8:	210a8304 	addi	r4,r4,10764
    ALTERA_ETH_TSE_INIT ( ETH_TSE, eth_tse);
}
  1817fc:	dfc00017 	ldw	ra,0(sp)
  181800:	dec00104 	addi	sp,sp,4

void alt_sys_init( void )
{
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_RX, sgdma_rx);
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_TX, sgdma_tx);
  181804:	0181d7c1 	jmpi	181d7c <alt_avalon_sgdma_init>

00181808 <altera_avalon_jtag_uart_write>:
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  unsigned int base = sp->base;
  181808:	21000017 	ldw	r4,0(r4)
 * one FIFOs worth of data.  But you said you didn't want to use interrupts :-)
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  18180c:	3005883a 	mov	r2,r6
  unsigned int base = sp->base;

  const char * end = ptr + count;
  181810:	298d883a 	add	r6,r5,r6

  while (ptr < end)
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
  181814:	21c00104 	addi	r7,r4,4
{
  unsigned int base = sp->base;

  const char * end = ptr + count;

  while (ptr < end)
  181818:	2980072e 	bgeu	r5,r6,181838 <altera_avalon_jtag_uart_write+0x30>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
  18181c:	38c00037 	ldwio	r3,0(r7)
  181820:	18ffffec 	andhi	r3,r3,65535
  181824:	183ffc26 	beq	r3,zero,181818 <altera_avalon_jtag_uart_write+0x10>
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);
  181828:	28c00007 	ldb	r3,0(r5)
  18182c:	20c00035 	stwio	r3,0(r4)
  181830:	29400044 	addi	r5,r5,1
  181834:	003ff806 	br	181818 <altera_avalon_jtag_uart_write+0x10>

  return count;
}
  181838:	f800283a 	ret

0018183c <alt_avalon_sgdma_irq>:
   * Note: This is explicitly done before calling user interrupt-handling
   * code rather than after; if user ISR code initiates another SGDMA
   * transfer which completes quickly, reading the control register after
   * the callback routine may result in a lost interrupt.
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
  18183c:	20800317 	ldw	r2,12(r4)
  181840:	10800404 	addi	r2,r2,16
  181844:	10c00037 	ldwio	r3,0(r2)
  181848:	18e00034 	orhi	r3,r3,32768
  18184c:	10c00035 	stwio	r3,0(r2)
    IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) | 0x80000000);
  
  /* Dummy read to ensure IRQ is negated before the ISR returns */
  IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  181850:	20800317 	ldw	r2,12(r4)
  181854:	10800437 	ldwio	r2,16(r2)
   * Other interrupts are explicitly disabled if callbacks
   * are registered because there is no guarantee that they are 
   * preemption-safe. This allows the driver to support 
   * interrupt preemption.
   */
  if(dev->callback) {
  181858:	20c00917 	ldw	r3,36(r4)
  18185c:	18000d26 	beq	r3,zero,181894 <alt_avalon_sgdma_irq+0x58>
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_sgdma_irq(void *context)
#else
static void alt_avalon_sgdma_irq(void *context, alt_u32 id)
#endif
{
  181860:	defffe04 	addi	sp,sp,-8
  181864:	dfc00115 	stw	ra,4(sp)
  181868:	dc000015 	stw	r16,0(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  18186c:	0021303a 	rdctl	r16,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  181870:	00bfff84 	movi	r2,-2
  181874:	8084703a 	and	r2,r16,r2
  181878:	1001703a 	wrctl	status,r2
   * preemption-safe. This allows the driver to support 
   * interrupt preemption.
   */
  if(dev->callback) {
    cpu_sr = alt_irq_disable_all();
    (dev->callback)(dev->callback_context);
  18187c:	21000a17 	ldw	r4,40(r4)
  181880:	183ee83a 	callr	r3
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  181884:	8001703a 	wrctl	status,r16
    alt_irq_enable_all(cpu_sr);
  }
}
  181888:	dfc00117 	ldw	ra,4(sp)
  18188c:	dc000017 	ldw	r16,0(sp)
  181890:	dec00204 	addi	sp,sp,8
  181894:	f800283a 	ret

00181898 <alt_avalon_sgdma_do_async_transfer>:
  alt_sgdma_descriptor *desc)
{
  alt_u32 control;

  /* Return with error immediately if controller is busy */
  if( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
  181898:	20c00317 	ldw	r3,12(r4)
  18189c:	18800037 	ldwio	r2,0(r3)
  1818a0:	1080040c 	andi	r2,r2,16
  1818a4:	1000191e 	bne	r2,zero,18190c <alt_avalon_sgdma_do_async_transfer+0x74>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    return -EBUSY;
  }

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
  1818a8:	18c00404 	addi	r3,r3,16
  1818ac:	19c00037 	ldwio	r7,0(r3)
  1818b0:	01bff7c4 	movi	r6,-33
  1818b4:	398c703a 	and	r6,r7,r6
  1818b8:	19800035 	stwio	r6,0(r3)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
  1818bc:	20c00317 	ldw	r3,12(r4)
  1818c0:	01803fc4 	movi	r6,255
  1818c4:	19800035 	stwio	r6,0(r3)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
  1818c8:	20c00317 	ldw	r3,12(r4)
  1818cc:	19400835 	stwio	r5,32(r3)
  1818d0:	20c00317 	ldw	r3,12(r4)
   *  - Stop on an error with any particular descriptor
   *  - Include any control register bits registered with along with
   *    the callback routine (effectively, interrupts are controlled
   *    via the control bits set during callback-register time).
   */
  if(dev->callback) {
  1818d4:	21400917 	ldw	r5,36(r4)
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  1818d8:	18c00404 	addi	r3,r3,16
   *  - Stop on an error with any particular descriptor
   *  - Include any control register bits registered with along with
   *    the callback routine (effectively, interrupts are controlled
   *    via the control bits set during callback-register time).
   */
  if(dev->callback) {
  1818dc:	28000526 	beq	r5,zero,1818f4 <alt_avalon_sgdma_do_async_transfer+0x5c>
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  1818e0:	19400037 	ldwio	r5,0(r3)

    control |= (dev->chain_control                          |
                ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK  );

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
  1818e4:	21000b17 	ldw	r4,44(r4)
  1818e8:	21001814 	ori	r4,r4,96
  1818ec:	2148b03a 	or	r4,r4,r5
  1818f0:	00000406 	br	181904 <alt_avalon_sgdma_do_async_transfer+0x6c>
   *   - Run
   *   - Stop on an error with any particular descriptor
   *   - Disable interrupt generation
   */
  else {
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  1818f4:	19400037 	ldwio	r5,0(r3)
  1818f8:	013ffbc4 	movi	r4,-17
  1818fc:	2908703a 	and	r4,r5,r4

    control |= (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK );
    control &= ~ALTERA_AVALON_SGDMA_CONTROL_IE_GLOBAL_MSK;

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
  181900:	21001814 	ori	r4,r4,96
  181904:	19000035 	stwio	r4,0(r3)
  181908:	f800283a 	ret
  alt_u32 control;

  /* Return with error immediately if controller is busy */
  if( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    return -EBUSY;
  18190c:	00bffc04 	movi	r2,-16
  /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
  return 0;
}
  181910:	f800283a 	ret

00181914 <alt_avalon_sgdma_do_sync_transfer>:
  alt_sgdma_descriptor *desc)
{
  alt_u8 status;

  /* Wait for any pending transfers to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
  181914:	20c00317 	ldw	r3,12(r4)
  181918:	18800037 	ldwio	r2,0(r3)
  18191c:	1080040c 	andi	r2,r2,16
  181920:	103ffc1e 	bne	r2,zero,181914 <alt_avalon_sgdma_do_sync_transfer>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );


  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
  181924:	18c00404 	addi	r3,r3,16
  181928:	19800037 	ldwio	r6,0(r3)
  18192c:	00bff7c4 	movi	r2,-33
  181930:	308c703a 	and	r6,r6,r2
  181934:	19800035 	stwio	r6,0(r3)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
  181938:	20c00317 	ldw	r3,12(r4)
  18193c:	01803fc4 	movi	r6,255
  181940:	19800035 	stwio	r6,0(r3)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
  181944:	20c00317 	ldw	r3,12(r4)
  181948:	19400835 	stwio	r5,32(r3)
   * Set up SGDMA controller to:
   * - Disable interrupt generation
   * - Run once a valid descriptor is written to controller
   * - Stop on an error with any particular descriptor
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
  18194c:	20c00317 	ldw	r3,12(r4)
  181950:	18c00404 	addi	r3,r3,16
  181954:	19400037 	ldwio	r5,0(r3)
  181958:	29401814 	ori	r5,r5,96
  18195c:	19400035 	stwio	r5,0(r3)
    (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK |
     ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK | 
     IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base)) );

  /* Wait for the descriptor (chain) to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
  181960:	20c00317 	ldw	r3,12(r4)
  181964:	19400037 	ldwio	r5,0(r3)
  181968:	2940040c 	andi	r5,r5,16
  18196c:	283ffc1e 	bne	r5,zero,181960 <alt_avalon_sgdma_do_sync_transfer+0x4c>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
  181970:	18c00404 	addi	r3,r3,16
  181974:	19400037 	ldwio	r5,0(r3)
  181978:	2884703a 	and	r2,r5,r2
  18197c:	18800035 	stwio	r2,0(r3)
    (IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) &
     ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK) );

  /* Get & clear status register contents */
  status = IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base);
  181980:	20c00317 	ldw	r3,12(r4)
  181984:	18800037 	ldwio	r2,0(r3)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
  181988:	01003fc4 	movi	r4,255
  18198c:	19000035 	stwio	r4,0(r3)

  return status;
}
  181990:	f800283a 	ret

00181994 <alt_avalon_sgdma_register_callback>:
  alt_sgdma_dev *dev,
  alt_avalon_sgdma_callback callback,
  alt_u32 chain_control,
  void *context)
{
  dev->callback         = callback;
  181994:	21400915 	stw	r5,36(r4)
  dev->callback_context = context;
  181998:	21c00a15 	stw	r7,40(r4)
  dev->chain_control    = chain_control;
  18199c:	21800b15 	stw	r6,44(r4)
  1819a0:	f800283a 	ret

001819a4 <alt_avalon_sgdma_start>:
 */
void alt_avalon_sgdma_start(alt_sgdma_dev *dev)
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  1819a4:	20800317 	ldw	r2,12(r4)
  1819a8:	10800404 	addi	r2,r2,16
  1819ac:	10c00037 	ldwio	r3,0(r2)
  control |= ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
  1819b0:	18c00814 	ori	r3,r3,32
  1819b4:	10c00035 	stwio	r3,0(r2)
  1819b8:	f800283a 	ret

001819bc <alt_avalon_sgdma_stop>:
 */
void alt_avalon_sgdma_stop(alt_sgdma_dev *dev)
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  1819bc:	20800317 	ldw	r2,12(r4)
  1819c0:	10800404 	addi	r2,r2,16
  1819c4:	11000037 	ldwio	r4,0(r2)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
  1819c8:	00fff7c4 	movi	r3,-33
  1819cc:	20c6703a 	and	r3,r4,r3
  1819d0:	10c00035 	stwio	r3,0(r2)
  1819d4:	f800283a 	ret

001819d8 <alt_avalon_sgdma_check_descriptor_status>:
 *   normally. Or, various error conditions defined in <errno.h>
 */
int alt_avalon_sgdma_check_descriptor_status(alt_sgdma_descriptor *desc)
{
  /* Errors take precedence */
  if( IORD_8DIRECT(&desc->status, 0) &
  1819d8:	208007a3 	ldbuio	r2,30(r4)
  1819dc:	10801fcc 	andi	r2,r2,127
  1819e0:	1000041e 	bne	r2,zero,1819f4 <alt_avalon_sgdma_check_descriptor_status+0x1c>
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) {
    return -EIO;
  }

  if( IORD_8DIRECT(&desc->control, 0) &
  1819e4:	208007e3 	ldbuio	r2,31(r4)
  1819e8:	1080200c 	andi	r2,r2,128
  1819ec:	1000031e 	bne	r2,zero,1819fc <alt_avalon_sgdma_check_descriptor_status+0x24>
  1819f0:	f800283a 	ret
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_OVERFLOW_MSK |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) {
    return -EIO;
  1819f4:	00bffec4 	movi	r2,-5
  1819f8:	f800283a 	ret
  }

  if( IORD_8DIRECT(&desc->control, 0) &
      ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK) {
    return -EINPROGRESS;
  1819fc:	00bfe244 	movi	r2,-119
  }

    return 0;
}
  181a00:	f800283a 	ret

00181a04 <alt_avalon_sgdma_open>:
 * Returns:
 * - Pointer to SGDMA device instance struct, or null if the device
 *   could not be opened.
 */
alt_sgdma_dev* alt_avalon_sgdma_open (const char* name)
{
  181a04:	defffe04 	addi	sp,sp,-8
  alt_sgdma_dev* dev;

  dev = (alt_sgdma_dev*) alt_find_dev (name, &alt_sgdma_list);
  181a08:	d1600304 	addi	r5,gp,-32756
 * Returns:
 * - Pointer to SGDMA device instance struct, or null if the device
 *   could not be opened.
 */
alt_sgdma_dev* alt_avalon_sgdma_open (const char* name)
{
  181a0c:	dc000015 	stw	r16,0(sp)
  181a10:	dfc00115 	stw	ra,4(sp)
  alt_sgdma_dev* dev;

  dev = (alt_sgdma_dev*) alt_find_dev (name, &alt_sgdma_list);
  181a14:	0181efc0 	call	181efc <alt_find_dev>
  181a18:	1021883a 	mov	r16,r2

  if (NULL == dev) {
  181a1c:	1000071e 	bne	r2,zero,181a3c <alt_avalon_sgdma_open+0x38>
  181a20:	d0a00517 	ldw	r2,-32748(gp)
  181a24:	10000226 	beq	r2,zero,181a30 <alt_avalon_sgdma_open+0x2c>
  181a28:	103ee83a 	callr	r2
  181a2c:	00000106 	br	181a34 <alt_avalon_sgdma_open+0x30>
  181a30:	d0a23b04 	addi	r2,gp,-30484
    ALT_ERRNO = ENODEV;
  181a34:	00c004c4 	movi	r3,19
  181a38:	10c00015 	stw	r3,0(r2)
  }

  return dev;
}
  181a3c:	8005883a 	mov	r2,r16
  181a40:	dfc00117 	ldw	ra,4(sp)
  181a44:	dc000017 	ldw	r16,0(sp)
  181a48:	dec00204 	addi	sp,sp,8
  181a4c:	f800283a 	ret

00181a50 <alt_avalon_sgdma_enable_desc_poll>:
 */
void alt_avalon_sgdma_enable_desc_poll(alt_sgdma_dev *dev, alt_u32 frequency)
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  181a50:	20c00317 	ldw	r3,12(r4)
  181a54:	18c00404 	addi	r3,r3,16
  181a58:	19000037 	ldwio	r4,0(r3)
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
  181a5c:	00a00434 	movhi	r2,32784
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
            ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
  181a60:	280a953a 	slli	r5,r5,20
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
  181a64:	10bfffc4 	addi	r2,r2,-1
  181a68:	2084703a 	and	r2,r4,r2
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
            ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
  181a6c:	295ffc2c 	andhi	r5,r5,32752
  181a70:	29400134 	orhi	r5,r5,4
  181a74:	288ab03a 	or	r5,r5,r2
  181a78:	19400035 	stwio	r5,0(r3)
  181a7c:	f800283a 	ret

00181a80 <alt_avalon_sgdma_disable_desc_poll>:
 */
void alt_avalon_sgdma_disable_desc_poll(alt_sgdma_dev *dev)
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  181a80:	20800317 	ldw	r2,12(r4)
  181a84:	10800404 	addi	r2,r2,16
  181a88:	11000037 	ldwio	r4,0(r2)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK;

  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
  181a8c:	00ffff34 	movhi	r3,65532
  181a90:	18ffffc4 	addi	r3,r3,-1
  181a94:	20c6703a 	and	r3,r4,r3
  181a98:	10c00035 	stwio	r3,0(r2)
  181a9c:	f800283a 	ret

00181aa0 <alt_avalon_sgdma_construct_descriptor_burst>:
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
  181aa0:	288007c3 	ldbu	r2,31(r5)
  int                   read_fixed,
  int                   write_fixed_or_sop,
  int                   read_burst,
  int                   write_burst,
  alt_u8                atlantic_channel)
{
  181aa4:	d8c00617 	ldw	r3,24(sp)
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
  181aa8:	10801fcc 	andi	r2,r2,127
  181aac:	288007e5 	stbio	r2,31(r5)
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  181ab0:	3004d23a 	srli	r2,r6,8
  181ab4:	21800005 	stb	r6,0(r4)
  desc->write_addr               = write_addr;
  181ab8:	21c00205 	stb	r7,8(r4)
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  181abc:	20800045 	stb	r2,1(r4)
  181ac0:	3004d43a 	srli	r2,r6,16
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  181ac4:	21400405 	stb	r5,16(r4)
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  181ac8:	300cd63a 	srli	r6,r6,24
  181acc:	20800085 	stb	r2,2(r4)
  desc->write_addr               = write_addr;
  181ad0:	3804d23a 	srli	r2,r7,8
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  181ad4:	218000c5 	stb	r6,3(r4)
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
  181ad8:	20000105 	stb	zero,4(r4)
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  181adc:	20800245 	stb	r2,9(r4)
  181ae0:	3804d43a 	srli	r2,r7,16
  181ae4:	380ed63a 	srli	r7,r7,24
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
  181ae8:	20000145 	stb	zero,5(r4)
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  181aec:	20800285 	stb	r2,10(r4)
  desc->next                     = (alt_u32 *) next;
  181af0:	2804d23a 	srli	r2,r5,8
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  181af4:	21c002c5 	stb	r7,11(r4)
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
  181af8:	20000185 	stb	zero,6(r4)
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  181afc:	20800445 	stb	r2,17(r4)
  181b00:	2804d43a 	srli	r2,r5,16
  181b04:	280ad63a 	srli	r5,r5,24
  desc->read_addr_pad            = 0x0;
  181b08:	200001c5 	stb	zero,7(r4)
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  181b0c:	20800485 	stb	r2,18(r4)
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
  desc->next_pad                 = 0x0;
  desc->bytes_to_transfer        = length_or_eop;
  181b10:	d880000b 	ldhu	r2,0(sp)
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  181b14:	214004c5 	stb	r5,19(r4)
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
  181b18:	20000305 	stb	zero,12(r4)
  desc->next_pad                 = 0x0;
  desc->bytes_to_transfer        = length_or_eop;
  181b1c:	20800605 	stb	r2,24(r4)
  181b20:	1004d23a 	srli	r2,r2,8

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
  181b24:	20000345 	stb	zero,13(r4)
  181b28:	20000385 	stb	zero,14(r4)
  desc->next_pad                 = 0x0;
  desc->bytes_to_transfer        = length_or_eop;
  181b2c:	20800645 	stb	r2,25(r4)
  desc->actual_bytes_transferred = 0;
  desc->status                   = 0x0;

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
  181b30:	d8800417 	ldw	r2,16(sp)

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
  181b34:	200003c5 	stb	zero,15(r4)
  desc->next_pad                 = 0x0;
  181b38:	20000505 	stb	zero,20(r4)
  181b3c:	20000545 	stb	zero,21(r4)
  181b40:	20000585 	stb	zero,22(r4)
  181b44:	200005c5 	stb	zero,23(r4)
  desc->bytes_to_transfer        = length_or_eop;
  desc->actual_bytes_transferred = 0;
  181b48:	20000705 	stb	zero,28(r4)
  181b4c:	20000745 	stb	zero,29(r4)
  desc->status                   = 0x0;
  181b50:	20000785 	stb	zero,30(r4)

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
  181b54:	20800685 	stb	r2,26(r4)
  desc->write_burst              = write_burst;
  181b58:	d8800517 	ldw	r2,20(sp)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
  181b5c:	d9400117 	ldw	r5,4(sp)
  desc->actual_bytes_transferred = 0;
  desc->status                   = 0x0;

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
  desc->write_burst              = write_burst;
  181b60:	208006c5 	stb	r2,27(r4)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
  181b64:	d8800217 	ldw	r2,8(sp)
  181b68:	280ac03a 	cmpne	r5,r5,zero
  181b6c:	297fe004 	addi	r5,r5,-128
  181b70:	1004c03a 	cmpne	r2,r2,zero
  181b74:	1004907a 	slli	r2,r2,1
  181b78:	2884b03a 	or	r2,r5,r2
  181b7c:	d9400317 	ldw	r5,12(sp)
  181b80:	280ac03a 	cmpne	r5,r5,zero
  181b84:	280a90ba 	slli	r5,r5,2
  181b88:	114ab03a 	or	r5,r2,r5
  181b8c:	18803fcc 	andi	r2,r3,255
  181b90:	10000326 	beq	r2,zero,181ba0 <alt_avalon_sgdma_construct_descriptor_burst+0x100>
  181b94:	18c003cc 	andi	r3,r3,15
  181b98:	180490fa 	slli	r2,r3,3
  181b9c:	00000106 	br	181ba4 <alt_avalon_sgdma_construct_descriptor_burst+0x104>
  181ba0:	0005883a 	mov	r2,zero
  181ba4:	2884b03a 	or	r2,r5,r2
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to.
   */
  alt_dcache_flush(desc, sizeof(alt_sgdma_descriptor));
  181ba8:	01400804 	movi	r5,32
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
  181bac:	208007c5 	stb	r2,31(r4)
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to.
   */
  alt_dcache_flush(desc, sizeof(alt_sgdma_descriptor));
  181bb0:	0181e881 	jmpi	181e88 <alt_dcache_flush>

00181bb4 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>:
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed,
  int                   read_burst,
  int                   write_burst)
{
  181bb4:	defff804 	addi	sp,sp,-32
  alt_avalon_sgdma_construct_descriptor_burst(
  181bb8:	d8800c17 	ldw	r2,48(sp)
  181bbc:	d8000615 	stw	zero,24(sp)
  181bc0:	d8000115 	stw	zero,4(sp)
  181bc4:	d8800515 	stw	r2,20(sp)
  181bc8:	d8800b17 	ldw	r2,44(sp)
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed,
  int                   read_burst,
  int                   write_burst)
{
  181bcc:	dfc00715 	stw	ra,28(sp)
  alt_avalon_sgdma_construct_descriptor_burst(
  181bd0:	d8800415 	stw	r2,16(sp)
  181bd4:	d8800a17 	ldw	r2,40(sp)
  181bd8:	d8800315 	stw	r2,12(sp)
  181bdc:	d8800917 	ldw	r2,36(sp)
  181be0:	d8800215 	stw	r2,8(sp)
  181be4:	d880080b 	ldhu	r2,32(sp)
  181be8:	d8800015 	stw	r2,0(sp)
  181bec:	0181aa00 	call	181aa0 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    write_fixed,
    read_burst,
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in mem-to-mem mode
}
  181bf0:	dfc00717 	ldw	ra,28(sp)
  181bf4:	dec00804 	addi	sp,sp,32
  181bf8:	f800283a 	ret

00181bfc <alt_avalon_sgdma_construct_mem_to_mem_desc>:
  alt_u32              *read_addr,
  alt_u32              *write_addr,
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed)
{
  181bfc:	defffa04 	addi	sp,sp,-24
  alt_avalon_sgdma_construct_mem_to_mem_desc_burst(desc, next, read_addr, 
  181c00:	d8800817 	ldw	r2,32(sp)
  181c04:	d8000415 	stw	zero,16(sp)
  181c08:	d8000315 	stw	zero,12(sp)
  181c0c:	d8800215 	stw	r2,8(sp)
  181c10:	d8800717 	ldw	r2,28(sp)
  alt_u32              *read_addr,
  alt_u32              *write_addr,
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed)
{
  181c14:	dfc00515 	stw	ra,20(sp)
  alt_avalon_sgdma_construct_mem_to_mem_desc_burst(desc, next, read_addr, 
  181c18:	d8800115 	stw	r2,4(sp)
  181c1c:	d880060b 	ldhu	r2,24(sp)
  181c20:	d8800015 	stw	r2,0(sp)
  181c24:	0181bb40 	call	181bb4 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>
    write_addr, length, read_fixed, write_fixed, 0, 0);
}
  181c28:	dfc00517 	ldw	ra,20(sp)
  181c2c:	dec00604 	addi	sp,sp,24
  181c30:	f800283a 	ret

00181c34 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>:
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed,
  int                   write_burst)
{
  181c34:	defff804 	addi	sp,sp,-32
  alt_avalon_sgdma_construct_descriptor_burst(
  181c38:	d8800917 	ldw	r2,36(sp)
  181c3c:	39ffffcc 	andi	r7,r7,65535
  181c40:	d9c00015 	stw	r7,0(sp)
  181c44:	d8800515 	stw	r2,20(sp)
  181c48:	d8800817 	ldw	r2,32(sp)
  181c4c:	300f883a 	mov	r7,r6
  181c50:	d8000615 	stw	zero,24(sp)
  181c54:	d8000415 	stw	zero,16(sp)
  181c58:	d8800315 	stw	r2,12(sp)
  181c5c:	d8000215 	stw	zero,8(sp)
  181c60:	d8000115 	stw	zero,4(sp)
  181c64:	000d883a 	mov	r6,zero
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed,
  int                   write_burst)
{
  181c68:	dfc00715 	stw	ra,28(sp)
  alt_avalon_sgdma_construct_descriptor_burst(
  181c6c:	0181aa00 	call	181aa0 <alt_avalon_sgdma_construct_descriptor_burst>
    0x0,            // Read fixed: N/A in stream-to-mem mode
    write_fixed,
    0,              // Read_burst : N/A in stream-to-mem mode
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in stream-to-mem mode
}
  181c70:	dfc00717 	ldw	ra,28(sp)
  181c74:	dec00804 	addi	sp,sp,32
  181c78:	f800283a 	ret

00181c7c <alt_avalon_sgdma_construct_stream_to_mem_desc>:
  alt_sgdma_descriptor *desc,
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed)
{
  181c7c:	defffd04 	addi	sp,sp,-12
  alt_avalon_sgdma_construct_stream_to_mem_desc_burst(desc, next, write_addr, 
  181c80:	d8800317 	ldw	r2,12(sp)
  181c84:	d8000115 	stw	zero,4(sp)
  181c88:	39ffffcc 	andi	r7,r7,65535
  181c8c:	d8800015 	stw	r2,0(sp)
  alt_sgdma_descriptor *desc,
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed)
{
  181c90:	dfc00215 	stw	ra,8(sp)
  alt_avalon_sgdma_construct_stream_to_mem_desc_burst(desc, next, write_addr, 
  181c94:	0181c340 	call	181c34 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>
    length_or_eop, write_fixed, 0);
}
  181c98:	dfc00217 	ldw	ra,8(sp)
  181c9c:	dec00304 	addi	sp,sp,12
  181ca0:	f800283a 	ret

00181ca4 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>:
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  int                   read_burst,
  alt_u8                atlantic_channel)
{
  181ca4:	defff804 	addi	sp,sp,-32
  alt_avalon_sgdma_construct_descriptor_burst(
  181ca8:	d8800c03 	ldbu	r2,48(sp)
  181cac:	39ffffcc 	andi	r7,r7,65535
  181cb0:	d9c00015 	stw	r7,0(sp)
  181cb4:	d8800615 	stw	r2,24(sp)
  181cb8:	d8800b17 	ldw	r2,44(sp)
  181cbc:	d8000515 	stw	zero,20(sp)
  181cc0:	000f883a 	mov	r7,zero
  181cc4:	d8800415 	stw	r2,16(sp)
  181cc8:	d8800917 	ldw	r2,36(sp)
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  int                   read_burst,
  alt_u8                atlantic_channel)
{
  181ccc:	dfc00715 	stw	ra,28(sp)
  alt_avalon_sgdma_construct_descriptor_burst(
  181cd0:	d8800315 	stw	r2,12(sp)
  181cd4:	d8800817 	ldw	r2,32(sp)
  181cd8:	d8800215 	stw	r2,8(sp)
  181cdc:	d8800a17 	ldw	r2,40(sp)
  181ce0:	d8800115 	stw	r2,4(sp)
  181ce4:	0181aa00 	call	181aa0 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    generate_sop,
    read_burst,
    0,                 // Write_burst : N/A in mem-to-stream mode
    atlantic_channel);
}
  181ce8:	dfc00717 	ldw	ra,28(sp)
  181cec:	dec00804 	addi	sp,sp,32
  181cf0:	f800283a 	ret

00181cf4 <alt_avalon_sgdma_construct_mem_to_stream_desc>:
  alt_u16               length,
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  alt_u8                atlantic_channel)
{
  181cf4:	defffa04 	addi	sp,sp,-24
  alt_avalon_sgdma_construct_mem_to_stream_desc_burst(desc, next, read_addr, 
  181cf8:	d8800903 	ldbu	r2,36(sp)
  181cfc:	d8000315 	stw	zero,12(sp)
  181d00:	39ffffcc 	andi	r7,r7,65535
  181d04:	d8800415 	stw	r2,16(sp)
  181d08:	d8800817 	ldw	r2,32(sp)
  alt_u16               length,
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  alt_u8                atlantic_channel)
{
  181d0c:	dfc00515 	stw	ra,20(sp)
  alt_avalon_sgdma_construct_mem_to_stream_desc_burst(desc, next, read_addr, 
  181d10:	d8800215 	stw	r2,8(sp)
  181d14:	d8800717 	ldw	r2,28(sp)
  181d18:	d8800115 	stw	r2,4(sp)
  181d1c:	d8800617 	ldw	r2,24(sp)
  181d20:	d8800015 	stw	r2,0(sp)
  181d24:	0181ca40 	call	181ca4 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>
    length, read_fixed, generate_sop, generate_eop, 0, atlantic_channel);

}
  181d28:	dfc00517 	ldw	ra,20(sp)
  181d2c:	dec00604 	addi	sp,sp,24
  181d30:	f800283a 	ret

00181d34 <alt_avalon_sgdma_construct_descriptor>:
  alt_u16               length_or_eop,
  int                   generate_eop,
  int                   read_fixed,
  int                   write_fixed_or_sop,
  alt_u8                atlantic_channel)
{
  181d34:	defff804 	addi	sp,sp,-32
  alt_avalon_sgdma_construct_descriptor_burst(desc, next, read_addr, 
  181d38:	d8800c03 	ldbu	r2,48(sp)
  181d3c:	d8000515 	stw	zero,20(sp)
  181d40:	d8000415 	stw	zero,16(sp)
  181d44:	d8800615 	stw	r2,24(sp)
  181d48:	d8800b17 	ldw	r2,44(sp)
  alt_u16               length_or_eop,
  int                   generate_eop,
  int                   read_fixed,
  int                   write_fixed_or_sop,
  alt_u8                atlantic_channel)
{
  181d4c:	dfc00715 	stw	ra,28(sp)
  alt_avalon_sgdma_construct_descriptor_burst(desc, next, read_addr, 
  181d50:	d8800315 	stw	r2,12(sp)
  181d54:	d8800a17 	ldw	r2,40(sp)
  181d58:	d8800215 	stw	r2,8(sp)
  181d5c:	d8800917 	ldw	r2,36(sp)
  181d60:	d8800115 	stw	r2,4(sp)
  181d64:	d880080b 	ldhu	r2,32(sp)
  181d68:	d8800015 	stw	r2,0(sp)
  181d6c:	0181aa00 	call	181aa0 <alt_avalon_sgdma_construct_descriptor_burst>
    write_addr, length_or_eop, generate_eop, read_fixed, write_fixed_or_sop, 
    0, 0, atlantic_channel);
}
  181d70:	dfc00717 	ldw	ra,28(sp)
  181d74:	dec00804 	addi	sp,sp,32
  181d78:	f800283a 	ret

00181d7c <alt_avalon_sgdma_init>:

  /* 
   * Halt any current transactions (reset the device)
   * SW reset is written twice per SGDMA documentation 
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
  181d7c:	20c00317 	ldw	r3,12(r4)
 * This routine disables interrupts, future descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_avalon_sgdma_init (alt_sgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
  181d80:	defffb04 	addi	sp,sp,-20
  181d84:	dc800315 	stw	r18,12(sp)
  181d88:	dc400215 	stw	r17,8(sp)
  181d8c:	dc000115 	stw	r16,4(sp)
  181d90:	dfc00415 	stw	ra,16(sp)
  181d94:	2021883a 	mov	r16,r4
  181d98:	2823883a 	mov	r17,r5
  181d9c:	3025883a 	mov	r18,r6

  /* 
   * Halt any current transactions (reset the device)
   * SW reset is written twice per SGDMA documentation 
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
  181da0:	00800074 	movhi	r2,1
  181da4:	18800435 	stwio	r2,16(r3)
    ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
  181da8:	20c00317 	ldw	r3,12(r4)
  181dac:	18800435 	stwio	r2,16(r3)

  /*
   * Disable interrupts, halt future descriptor processing,
   * and clear status register content
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 0x0);
  181db0:	20800317 	ldw	r2,12(r4)
  181db4:	10000435 	stwio	zero,16(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
  181db8:	20800317 	ldw	r2,12(r4)
  181dbc:	00c03fc4 	movi	r3,255
  181dc0:	10c00035 	stwio	r3,0(r2)

  /* Register this instance of the SGDMA controller with HAL */
  alt_dev_llist_insert((alt_dev_llist*) dev, &alt_sgdma_list);
  181dc4:	d1600304 	addi	r5,gp,-32756
  181dc8:	0181e900 	call	181e90 <alt_dev_llist_insert>

  /* Install IRQ handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(ic_id, irq, alt_avalon_sgdma_irq, dev, 0x0);
  181dcc:	01800634 	movhi	r6,24
  181dd0:	d8000015 	stw	zero,0(sp)
  181dd4:	800f883a 	mov	r7,r16
  181dd8:	31860f04 	addi	r6,r6,6204
  181ddc:	900b883a 	mov	r5,r18
  181de0:	8809883a 	mov	r4,r17
  181de4:	0181f740 	call	181f74 <alt_ic_isr_register>
#else
  alt_irq_register(irq, dev, alt_avalon_sgdma_irq);
#endif  
}
  181de8:	dfc00417 	ldw	ra,16(sp)
  181dec:	dc800317 	ldw	r18,12(sp)
  181df0:	dc400217 	ldw	r17,8(sp)
  181df4:	dc000117 	ldw	r16,4(sp)
  181df8:	dec00504 	addi	sp,sp,20
  181dfc:	f800283a 	ret

00181e00 <alt_busy_sleep>:
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
  181e00:	014666b4 	movhi	r5,6554
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
  181e04:	defffe04 	addi	sp,sp,-8
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
  181e08:	29666644 	addi	r5,r5,-26215
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
  181e0c:	dc000015 	stw	r16,0(sp)
  181e10:	dfc00115 	stw	ra,4(sp)
  181e14:	2021883a 	mov	r16,r4
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
  181e18:	01813a40 	call	1813a4 <__udivsi3>
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  181e1c:	10001026 	beq	r2,zero,181e60 <alt_busy_sleep+0x60>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
  181e20:	01600034 	movhi	r5,32768
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
  181e24:	013999b4 	movhi	r4,58982
  181e28:	0007883a 	mov	r3,zero
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
  181e2c:	297fffc4 	addi	r5,r5,-1
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
  181e30:	211999c4 	addi	r4,r4,26215
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
  181e34:	297fffc4 	addi	r5,r5,-1
  181e38:	283ffe1e 	bne	r5,zero,181e34 <alt_busy_sleep+0x34>
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
  181e3c:	18c00044 	addi	r3,r3,1
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
  181e40:	8121883a 	add	r16,r16,r4
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
  181e44:	18bffb16 	blt	r3,r2,181e34 <alt_busy_sleep+0x34>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
  181e48:	01400144 	movi	r5,5
  181e4c:	8009883a 	mov	r4,r16
  181e50:	01814600 	call	181460 <__mulsi3>
  181e54:	10bfffc4 	addi	r2,r2,-1
  181e58:	103ffe1e 	bne	r2,zero,181e54 <alt_busy_sleep+0x54>
  181e5c:	00000506 	br	181e74 <alt_busy_sleep+0x74>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
  181e60:	01400144 	movi	r5,5
  181e64:	8009883a 	mov	r4,r16
  181e68:	01814600 	call	181460 <__mulsi3>
  181e6c:	10bfffc4 	addi	r2,r2,-1
  181e70:	00bffe16 	blt	zero,r2,181e6c <alt_busy_sleep+0x6c>
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
}
  181e74:	0005883a 	mov	r2,zero
  181e78:	dfc00117 	ldw	ra,4(sp)
  181e7c:	dc000017 	ldw	r16,0(sp)
  181e80:	dec00204 	addi	sp,sp,8
  181e84:	f800283a 	ret

00181e88 <alt_dcache_flush>:
 *
 * Any dirty lines in the data cache are written back to memory.
 */

void alt_dcache_flush (void* start, alt_u32 len)
{
  181e88:	f800283a 	ret

00181e8c <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
  181e8c:	f800283a 	ret

00181e90 <alt_dev_llist_insert>:
{
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  181e90:	20000226 	beq	r4,zero,181e9c <alt_dev_llist_insert+0xc>
  181e94:	20800217 	ldw	r2,8(r4)
  181e98:	1000101e 	bne	r2,zero,181edc <alt_dev_llist_insert+0x4c>
  181e9c:	d0a00517 	ldw	r2,-32748(gp)
  181ea0:	10000926 	beq	r2,zero,181ec8 <alt_dev_llist_insert+0x38>
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
  181ea4:	deffff04 	addi	sp,sp,-4
  181ea8:	dfc00015 	stw	ra,0(sp)
  181eac:	103ee83a 	callr	r2
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  {
    ALT_ERRNO = EINVAL;
  181eb0:	00c00584 	movi	r3,22
  181eb4:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
  181eb8:	00bffa84 	movi	r2,-22
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
}
  181ebc:	dfc00017 	ldw	ra,0(sp)
  181ec0:	dec00104 	addi	sp,sp,4
  181ec4:	f800283a 	ret
  181ec8:	d0a23b04 	addi	r2,gp,-30484
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  {
    ALT_ERRNO = EINVAL;
  181ecc:	00c00584 	movi	r3,22
  181ed0:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
  181ed4:	00bffa84 	movi	r2,-22
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
}
  181ed8:	f800283a 	ret

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  entry->next     = list->next;
  181edc:	28800017 	ldw	r2,0(r5)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  181ee0:	21400115 	stw	r5,4(r4)
  entry->next     = list->next;
  181ee4:	20800015 	stw	r2,0(r4)

  list->next->previous = entry;
  181ee8:	28800017 	ldw	r2,0(r5)
  181eec:	11000115 	stw	r4,4(r2)
  list->next           = entry;
  181ef0:	29000015 	stw	r4,0(r5)
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
  181ef4:	0005883a 	mov	r2,zero
  181ef8:	f800283a 	ret

00181efc <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
  181efc:	defffb04 	addi	sp,sp,-20
  181f00:	dcc00315 	stw	r19,12(sp)
  181f04:	dc800215 	stw	r18,8(sp)
  181f08:	dc400115 	stw	r17,4(sp)
  181f0c:	dc000015 	stw	r16,0(sp)
  181f10:	dfc00415 	stw	ra,16(sp)
  181f14:	2027883a 	mov	r19,r4
  181f18:	2823883a 	mov	r17,r5
  alt_dev* next = (alt_dev*) llist->next;
  181f1c:	2c000017 	ldw	r16,0(r5)
  alt_32 len;

  len  = strlen(name) + 1;
  181f20:	0180b200 	call	180b20 <strlen>
  181f24:	14800044 	addi	r18,r2,1
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
  181f28:	84400726 	beq	r16,r17,181f48 <alt_find_dev+0x4c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
  181f2c:	81000217 	ldw	r4,8(r16)
  181f30:	900d883a 	mov	r6,r18
  181f34:	980b883a 	mov	r5,r19
  181f38:	01820700 	call	182070 <memcmp>
  181f3c:	10000426 	beq	r2,zero,181f50 <alt_find_dev+0x54>
    {
      /* match found */

      return next;
    }
    next = (alt_dev*) next->llist.next;
  181f40:	84000017 	ldw	r16,0(r16)
  181f44:	003ff806 	br	181f28 <alt_find_dev+0x2c>
  }
  
  /* No match found */
  
  return NULL;
  181f48:	0005883a 	mov	r2,zero
  181f4c:	00000106 	br	181f54 <alt_find_dev+0x58>
  181f50:	8005883a 	mov	r2,r16
}
  181f54:	dfc00417 	ldw	ra,16(sp)
  181f58:	dcc00317 	ldw	r19,12(sp)
  181f5c:	dc800217 	ldw	r18,8(sp)
  181f60:	dc400117 	ldw	r17,4(sp)
  181f64:	dc000017 	ldw	r16,0(sp)
  181f68:	dec00504 	addi	sp,sp,20
  181f6c:	f800283a 	ret

00181f70 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
  181f70:	f800283a 	ret

00181f74 <alt_ic_isr_register>:
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
  181f74:	01820001 	jmpi	182000 <alt_iic_isr_register>

00181f78 <alt_ic_irq_enable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  181f78:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  181f7c:	00bfff84 	movi	r2,-2
  181f80:	2084703a 	and	r2,r4,r2
  181f84:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active |= (1 << id);
  181f88:	00c00044 	movi	r3,1
  181f8c:	d0a23f17 	ldw	r2,-30468(gp)
  181f90:	194a983a 	sll	r5,r3,r5
  181f94:	288ab03a 	or	r5,r5,r2
  181f98:	d1623f15 	stw	r5,-30468(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  181f9c:	d0a23f17 	ldw	r2,-30468(gp)
  181fa0:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  181fa4:	2001703a 	wrctl	status,r4
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_enable(irq);
}
  181fa8:	0005883a 	mov	r2,zero
  181fac:	f800283a 	ret

00181fb0 <alt_ic_irq_disable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  181fb0:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  181fb4:	00bfff84 	movi	r2,-2
  181fb8:	2084703a 	and	r2,r4,r2
  181fbc:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active &= ~(1 << id);
  181fc0:	00ffff84 	movi	r3,-2
  181fc4:	d0a23f17 	ldw	r2,-30468(gp)
  181fc8:	194a183a 	rol	r5,r3,r5
  181fcc:	288a703a 	and	r5,r5,r2
  181fd0:	d1623f15 	stw	r5,-30468(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  181fd4:	d0a23f17 	ldw	r2,-30468(gp)
  181fd8:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  181fdc:	2001703a 	wrctl	status,r4
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_disable(irq);
}
  181fe0:	0005883a 	mov	r2,zero
  181fe4:	f800283a 	ret

00181fe8 <alt_ic_irq_enabled>:
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
  181fe8:	000730fa 	rdctl	r3,ienable

    return (irq_enabled & (1 << irq)) ? 1: 0;
  181fec:	00800044 	movi	r2,1
  181ff0:	1144983a 	sll	r2,r2,r5
  181ff4:	10c4703a 	and	r2,r2,r3
}
  181ff8:	1004c03a 	cmpne	r2,r2,zero
  181ffc:	f800283a 	ret

00182000 <alt_iic_isr_register>:
{
  int rc = -EINVAL;  
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  alt_irq_context status;

  if (id < ALT_NIRQ)
  182000:	00c007c4 	movi	r3,31
  182004:	19401616 	blt	r3,r5,182060 <alt_iic_isr_register+0x60>
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  182008:	defffe04 	addi	sp,sp,-8
  18200c:	dfc00115 	stw	ra,4(sp)
  182010:	dc000015 	stw	r16,0(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  182014:	0021303a 	rdctl	r16,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  182018:	00ffff84 	movi	r3,-2
  18201c:	80c6703a 	and	r3,r16,r3
  182020:	1801703a 	wrctl	status,r3
     * state.
     */

    status = alt_irq_disable_all();

    alt_irq[id].handler = isr;
  182024:	280490fa 	slli	r2,r5,3
  182028:	00c00634 	movhi	r3,24
  18202c:	18ce1b04 	addi	r3,r3,14444
  182030:	1885883a 	add	r2,r3,r2
  182034:	11800015 	stw	r6,0(r2)
    alt_irq[id].context = isr_context;
  182038:	11c00115 	stw	r7,4(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
  18203c:	30000226 	beq	r6,zero,182048 <alt_iic_isr_register+0x48>
  182040:	0181f780 	call	181f78 <alt_ic_irq_enable>
  182044:	00000106 	br	18204c <alt_iic_isr_register+0x4c>
  182048:	0181fb00 	call	181fb0 <alt_ic_irq_disable>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  18204c:	8001703a 	wrctl	status,r16

    alt_irq_enable_all(status);
  }

  return rc; 
}
  182050:	dfc00117 	ldw	ra,4(sp)
  182054:	dc000017 	ldw	r16,0(sp)
  182058:	dec00204 	addi	sp,sp,8
  18205c:	f800283a 	ret
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  int rc = -EINVAL;  
  182060:	00bffa84 	movi	r2,-22
  182064:	f800283a 	ret

00182068 <altera_nios2_gen2_irq_init>:
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
  182068:	000170fa 	wrctl	ienable,zero
  18206c:	f800283a 	ret

00182070 <memcmp>:
  182070:	218d883a 	add	r6,r4,r6
  182074:	21800826 	beq	r4,r6,182098 <memcmp+0x28>
  182078:	20800003 	ldbu	r2,0(r4)
  18207c:	28c00003 	ldbu	r3,0(r5)
  182080:	10c00226 	beq	r2,r3,18208c <memcmp+0x1c>
  182084:	10c5c83a 	sub	r2,r2,r3
  182088:	f800283a 	ret
  18208c:	21000044 	addi	r4,r4,1
  182090:	29400044 	addi	r5,r5,1
  182094:	003ff706 	br	182074 <memcmp+0x4>
  182098:	0005883a 	mov	r2,zero
  18209c:	f800283a 	ret
