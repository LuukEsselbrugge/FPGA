
barcode.elf:     file format elf32-littlenios2
barcode.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x0008014c

Program Header:
    LOAD off    0x00001000 vaddr 0x00080000 paddr 0x00080000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00080020 paddr 0x00080020 align 2**12
         filesz 0x000014b8 memsz 0x000014b8 flags r-x
    LOAD off    0x000024d8 vaddr 0x000814d8 paddr 0x0008194c align 2**12
         filesz 0x00000474 memsz 0x00000474 flags rw-
    LOAD off    0x00002dc0 vaddr 0x00081dc0 paddr 0x00081dc0 align 2**12
         filesz 0x00000000 memsz 0x00000528 flags rw-
    LOAD off    0x00003000 vaddr 0x00100000 paddr 0x000822e8 align 2**12
         filesz 0x00000080 memsz 0x00000080 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00080000  00080000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   0000012c  00080020  00080020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00001294  0008014c  0008014c  0000114c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000000f8  000813e0  000813e0  000023e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00000474  000814d8  0008194c  000024d8  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00000528  00081dc0  00081dc0  00002dc0  2**2
                  ALLOC, SMALL_DATA
  6 .VideoRAM     00000000  00000000  00000000  00003080  2**0
                  CONTENTS
  7 .onchip_memory 00000000  000822e8  000822e8  00003080  2**0
                  CONTENTS
  8 .descriptor_memory 00000080  00100000  000822e8  00003000  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  9 .comment      00000023  00000000  00000000  00003080  2**0
                  CONTENTS, READONLY
 10 .debug_aranges 00000440  00000000  00000000  000030a8  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   0000416b  00000000  00000000  000034e8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 00001a85  00000000  00000000  00007653  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00001a62  00000000  00000000  000090d8  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00000710  00000000  00000000  0000ab3c  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00001507  00000000  00000000  0000b24c  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    00001a9b  00000000  00000000  0000c753  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_alt_sim_info 00000050  00000000  00000000  0000e1f0  2**2
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_ranges 000001f0  00000000  00000000  0000e240  2**3
                  CONTENTS, READONLY, DEBUGGING
 19 .thread_model 00000003  00000000  00000000  0000fe36  2**0
                  CONTENTS, READONLY
 20 .cpu          00000005  00000000  00000000  0000fe39  2**0
                  CONTENTS, READONLY
 21 .qsys         00000001  00000000  00000000  0000fe3e  2**0
                  CONTENTS, READONLY
 22 .simulation_enabled 00000001  00000000  00000000  0000fe3f  2**0
                  CONTENTS, READONLY
 23 .stderr_dev   00000009  00000000  00000000  0000fe40  2**0
                  CONTENTS, READONLY
 24 .stdin_dev    00000009  00000000  00000000  0000fe49  2**0
                  CONTENTS, READONLY
 25 .stdout_dev   00000009  00000000  00000000  0000fe52  2**0
                  CONTENTS, READONLY
 26 .sopc_system_name 00000013  00000000  00000000  0000fe5b  2**0
                  CONTENTS, READONLY
 27 .quartus_project_dir 0000001e  00000000  00000000  0000fe6e  2**0
                  CONTENTS, READONLY
 28 .jdi          00005e13  00000000  00000000  0000fe8c  2**0
                  CONTENTS, READONLY
 29 .sopcinfo     00069c69  00000000  00000000  00015c9f  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00080000 l    d  .entry	00000000 .entry
00080020 l    d  .exceptions	00000000 .exceptions
0008014c l    d  .text	00000000 .text
000813e0 l    d  .rodata	00000000 .rodata
000814d8 l    d  .rwdata	00000000 .rwdata
00081dc0 l    d  .bss	00000000 .bss
00000000 l    d  .VideoRAM	00000000 .VideoRAM
000822e8 l    d  .onchip_memory	00000000 .onchip_memory
00100000 l    d  .descriptor_memory	00000000 .descriptor_memory
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../barcode_bsp//obj/HAL/src/crt0.o
00080184 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_exception_entry.o
00080094 l       .exceptions	00000000 alt_exception_unknown
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 main.c
00000000 l    df *ABS*	00000000 network.c
00000000 l    df *ABS*	00000000 video.c
00000000 l    df *ABS*	00000000 rand.c
00081dcc l     O .bss	00000008 _randbits
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 alt_load.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_printf.c
00000000 l    df *ABS*	00000000 alt_putchar.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
00081908 l     O .rwdata	00000030 sgdma_rx
000818d8 l     O .rwdata	00000030 sgdma_tx
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_sgdma.c
0008097c l     F .text	0000005c alt_avalon_sgdma_irq
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_dcache_flush.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 altera_nios2_qsys_irq.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00080708 g     F .text	0000002c alt_main
0008019c g     F .text	00000068 rx_ethernet_isr
000821e8 g     O .bss	00000100 alt_irq
0008194c g       *ABS*	00000000 __flash_rwdata_start
00080a54 g     F .text	00000080 alt_avalon_sgdma_do_sync_transfer
00080be0 g     F .text	00000114 alt_avalon_sgdma_construct_descriptor_burst
00081938 g     O .rwdata	00000004 jtag_uart
00080000 g     F .entry	0000001c __reset
00080d74 g     F .text	00000048 alt_avalon_sgdma_construct_stream_to_mem_desc_burst
00080020 g       *ABS*	00000000 __flash_exceptions_start
00081de4 g     O .bss	00000004 errno
00081dd8 g     O .bss	00000004 alt_argv
00089938 g       *ABS*	00000000 _gp
000808ec g     F .text	00000004 usleep
00000000 g       *ABS*	00000000 __alt_mem_VideoRAM
0008102c g     F .text	00000074 alt_find_dev
00080de4 g     F .text	00000050 alt_avalon_sgdma_construct_mem_to_stream_desc_burst
00081324 g     F .text	00000064 .hidden __udivsi3
000811a8 g     F .text	00000038 alt_icache_flush
00080afc g     F .text	0000001c alt_avalon_sgdma_stop
00080fb8 g     F .text	00000004 alt_dcache_flush
000822e8 g       *ABS*	00000000 __bss_end
00081138 g     F .text	00000068 alt_iic_isr_register
000809d8 g     F .text	0000007c alt_avalon_sgdma_do_async_transfer
00080490 g     F .text	00000030 drawColor
00100000 g     O .descriptor_memory	00000020 rx_descriptor_end
00081120 g     F .text	00000018 alt_ic_irq_enabled
00100000 g       *ABS*	00000000 __alt_mem_descriptor_memory
00081de0 g     O .bss	00000004 alt_irq_active
000814d8 g     O .rwdata	00000400 tx_frame
000800ec g     F .exceptions	00000060 alt_irq_handler
00080b18 g     F .text	0000002c alt_avalon_sgdma_check_descriptor_status
00080fbc g     F .text	00000004 alt_dcache_flush_all
00100020 g     O .descriptor_memory	00000020 rx_descriptor
0008194c g       *ABS*	00000000 __ram_rwdata_end
00080000 g       *ABS*	00000000 __alt_mem_onchip_memory
00080b90 g     F .text	00000030 alt_avalon_sgdma_enable_desc_poll
000814d8 g       *ABS*	00000000 __ram_rodata_end
00081388 g     F .text	00000058 .hidden __umodsi3
00080e34 g     F .text	00000040 alt_avalon_sgdma_construct_mem_to_stream_desc
00080ad4 g     F .text	00000010 alt_avalon_sgdma_register_callback
000822e8 g       *ABS*	00000000 end
000cb000 g       *ABS*	00000000 __alt_stack_pointer
00080bc0 g     F .text	00000020 alt_avalon_sgdma_disable_desc_poll
00080948 g     F .text	00000034 altera_avalon_jtag_uart_write
00080d3c g     F .text	00000038 alt_avalon_sgdma_construct_mem_to_mem_desc
00080dbc g     F .text	00000028 alt_avalon_sgdma_construct_stream_to_mem_desc
00080734 g     F .text	00000170 alt_printf
000803c0 g     F .text	00000048 refresh_ethernet
0008014c g     F .text	0000003c _start
00081dc0 g     O .bss	00000004 sgdma_tx_dev
00080b44 g     F .text	0000004c alt_avalon_sgdma_open
00080568 g     F .text	00000060 rand
00081dc4 g     O .bss	00000004 text_length
00080910 g     F .text	00000038 alt_sys_init
000814d8 g       *ABS*	00000000 __ram_rwdata_start
000813e0 g       *ABS*	00000000 __ram_rodata_start
00080f40 g     F .text	00000078 alt_busy_sleep
000811e0 g     F .text	00000030 memcmp
000822e8 g       *ABS*	00000000 __alt_stack_base
00080fc0 g     F .text	0000006c alt_dev_llist_insert
00080ae4 g     F .text	00000018 alt_avalon_sgdma_start
00081dc0 g       *ABS*	00000000 __bss_start
00080188 g     F .text	00000014 main
00081dd4 g     O .bss	00000004 alt_envp
00080554 g     F .text	00000014 srand
0008193c g     O .rwdata	00000008 alt_sgdma_list
00081944 g     O .rwdata	00000004 alt_errno
00100060 g     O .descriptor_memory	00000020 tx_descriptor
00081de8 g     O .bss	00000400 rx_frame
0008122c g     F .text	00000084 .hidden __divsi3
000813e0 g       *ABS*	00000000 __flash_rodata_start
000808f0 g     F .text	00000020 alt_irq_init
00081ddc g     O .bss	00000004 alt_argc
00080020 g       .exceptions	00000000 alt_irq_entry
00080204 g     F .text	000001bc setup
00080020 g       *ABS*	00000000 __ram_exceptions_start
000810ac g     F .text	00000004 alt_ic_isr_register
0008194c g       *ABS*	00000000 _edata
000822e8 g       *ABS*	00000000 _end
000804c0 g     F .text	00000094 video
0008014c g       *ABS*	00000000 __ram_exceptions_end
00080408 g     F .text	00000088 tx_ethernet_isr
000810e8 g     F .text	00000038 alt_ic_irq_disable
00100040 g     O .descriptor_memory	00000020 tx_descriptor_end
00080e74 g     F .text	00000048 alt_avalon_sgdma_construct_descriptor
000811a0 g     F .text	00000008 altera_nios2_qsys_irq_init
000812b0 g     F .text	00000074 .hidden __modsi3
000cb000 g       *ABS*	00000000 __alt_data_end
00080020 g     F .exceptions	00000000 alt_exception
00081dc8 g     O .bss	00000004 sgdma_rx_dev
0008001c g       .entry	00000000 _exit
000805c8 g     F .text	00000060 .hidden __muldi3
00081210 g     F .text	0000001c strlen
000808a4 g     F .text	00000048 alt_putchar
000810a0 g     F .text	0000000c alt_icache_flush_all
00081948 g     O .rwdata	00000004 alt_priority_mask
000810b0 g     F .text	00000038 alt_ic_irq_enable
00080cf4 g     F .text	00000048 alt_avalon_sgdma_construct_mem_to_mem_desc_burst
00080628 g     F .text	000000e0 alt_load
00080ebc g     F .text	00000084 alt_avalon_sgdma_init



Disassembly of section .entry:

00080000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && !defined(ALT_SIM_OPTIMIZE)
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
   80000:	00840014 	movui	r2,4096
#endif

0:
    initi r2
   80004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
   80008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
   8000c:	00bffd16 	blt	zero,r2,80004 <__reset+0x4>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
   80010:	00400234 	movhi	at,8
    ori r1, r1, %lo(_start)
   80014:	08405314 	ori	at,at,332
    jmp r1
   80018:	0800683a 	jmp	at

0008001c <_exit>:
   8001c:	00000000 	call	0 <__alt_mem_VideoRAM>

Disassembly of section .exceptions:

00080020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
   80020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
   80024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
   80028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
   8002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
   80030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
   80034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
   80038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
   8003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
   80040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
   80044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
   80048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
   8004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
   80050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
   80054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
   80058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
   8005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
   80060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
   80064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
   80068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
   8006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
   80070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
   80074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
   80078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
   8007c:	10000326 	beq	r2,zero,8008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
   80080:	20000226 	beq	r4,zero,8008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
   80084:	00800ec0 	call	800ec <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
   80088:	00000306 	br	80098 <alt_exception_unknown+0x4>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
   8008c:	df401215 	stw	ea,72(sp)
        ldw   r2, -4(ea)   /* Instruction that caused exception */
   80090:	e8bfff17 	ldw	r2,-4(ea)

00080094 <alt_exception_unknown>:
#ifdef NIOS2_HAS_DEBUG_STUB
       /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
   80094:	003da03a 	break	0
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
   80098:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
   8009c:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
   800a0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
   800a4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
   800a8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
   800ac:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
   800b0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
   800b4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
   800b8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
   800bc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
   800c0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
   800c4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
   800c8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
   800cc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
   800d0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
   800d4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
   800d8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
   800dc:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
   800e0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
   800e4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
   800e8:	ef80083a 	eret

000800ec <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
   800ec:	defffe04 	addi	sp,sp,-8
   800f0:	dfc00115 	stw	ra,4(sp)
   800f4:	dc000015 	stw	r16,0(sp)
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
   800f8:	0009313a 	rdctl	r4,ipending
    do
    {
      if (active & mask)
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
   800fc:	04000234 	movhi	r16,8
   80100:	84087a04 	addi	r16,r16,8680

  active = alt_irq_pending ();

  do
  {
    i = 0;
   80104:	0005883a 	mov	r2,zero
    mask = 1;
   80108:	00c00044 	movi	r3,1
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
   8010c:	20ca703a 	and	r5,r4,r3
   80110:	28000b26 	beq	r5,zero,80140 <alt_irq_handler+0x54>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
   80114:	100490fa 	slli	r2,r2,3
   80118:	8085883a 	add	r2,r16,r2
   8011c:	10c00017 	ldw	r3,0(r2)
   80120:	11000117 	ldw	r4,4(r2)
   80124:	183ee83a 	callr	r3
   80128:	0009313a 	rdctl	r4,ipending

    } while (1);

    active = alt_irq_pending ();
    
  } while (active);
   8012c:	203ff51e 	bne	r4,zero,80104 <alt_irq_handler+0x18>
  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
}
   80130:	dfc00117 	ldw	ra,4(sp)
   80134:	dc000017 	ldw	r16,0(sp)
   80138:	dec00204 	addi	sp,sp,8
   8013c:	f800283a 	ret
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
   80140:	18c7883a 	add	r3,r3,r3
      i++;
   80144:	10800044 	addi	r2,r2,1

    } while (1);
   80148:	003ff006 	br	8010c <alt_irq_handler+0x20>

Disassembly of section .text:

0008014c <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
   8014c:	06c00334 	movhi	sp,12
    ori sp, sp, %lo(__alt_stack_pointer)
   80150:	deec0014 	ori	sp,sp,45056
    movhi gp, %hi(_gp)
   80154:	06800234 	movhi	gp,8
    ori gp, gp, %lo(_gp)
   80158:	d6a64e14 	ori	gp,gp,39224
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
   8015c:	00800234 	movhi	r2,8
    ori r2, r2, %lo(__bss_start)
   80160:	10877014 	ori	r2,r2,7616

    movhi r3, %hi(__bss_end)
   80164:	00c00234 	movhi	r3,8
    ori r3, r3, %lo(__bss_end)
   80168:	18c8ba14 	ori	r3,r3,8936

    beq r2, r3, 1f
   8016c:	10c00326 	beq	r2,r3,8017c <_start+0x30>

0:
    stw zero, (r2)
   80170:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
   80174:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
   80178:	10fffd36 	bltu	r2,r3,80170 <_start+0x24>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
   8017c:	00806280 	call	80628 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
   80180:	00807080 	call	80708 <alt_main>

00080184 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
   80184:	003fff06 	br	80184 <alt_after_alt_main>

00080188 <main>:
#include "network.h"

int main(void){
   80188:	deffff04 	addi	sp,sp,-4
   8018c:	dfc00015 	stw	ra,0(sp)

	setup();
   80190:	00802040 	call	80204 <setup>
	//

	while(1){
		//tx_ethernet_isr("Hello");
		refresh_ethernet();
   80194:	00803c00 	call	803c0 <refresh_ethernet>
   80198:	003ffe06 	br	80194 <main+0xc>

0008019c <rx_ethernet_isr>:
	// Create transmit sgdma descriptor
	alt_avalon_sgdma_construct_mem_to_stream_desc( &tx_descriptor, &tx_descriptor_end, (alt_u32 *)tx_frame, 62, 0, 1, 1, 0 );
}

void rx_ethernet_isr (void *context)
{
   8019c:	defffe04 	addi	sp,sp,-8
   801a0:	dfc00115 	stw	ra,4(sp)
	// Wait until receive descriptor transfer is complete
	while (alt_avalon_sgdma_check_descriptor_status(&rx_descriptor) != 0);
   801a4:	01000434 	movhi	r4,16
   801a8:	21000804 	addi	r4,r4,32
   801ac:	0080b180 	call	80b18 <alt_avalon_sgdma_check_descriptor_status>
   801b0:	103ffc1e 	bne	r2,zero,801a4 <rx_ethernet_isr+0x8>

	// Output received text
	alt_printf( " %s\n", rx_frame + 44);
   801b4:	01400234 	movhi	r5,8
   801b8:	01000234 	movhi	r4,8
   801bc:	29478504 	addi	r5,r5,7700
   801c0:	2104f804 	addi	r4,r4,5088
   801c4:	00807340 	call	80734 <alt_printf>

	// Create new receive sgdma descriptor
	alt_avalon_sgdma_construct_stream_to_mem_desc( &rx_descriptor, &rx_descriptor_end, (alt_u32 *)rx_frame, 0, 0 );
   801c8:	01800234 	movhi	r6,8
   801cc:	01400434 	movhi	r5,16
   801d0:	01000434 	movhi	r4,16
   801d4:	d8000015 	stw	zero,0(sp)
   801d8:	000f883a 	mov	r7,zero
   801dc:	31877a04 	addi	r6,r6,7656
   801e0:	29400004 	addi	r5,r5,0
   801e4:	21000804 	addi	r4,r4,32
   801e8:	0080dbc0 	call	80dbc <alt_avalon_sgdma_construct_stream_to_mem_desc>
	// Set up non-blocking transfer of sgdma receive descriptor
	alt_avalon_sgdma_do_async_transfer( sgdma_rx_dev, &rx_descriptor );
   801ec:	d1212417 	ldw	r4,-31600(gp)
   801f0:	01400434 	movhi	r5,16
   801f4:	29400804 	addi	r5,r5,32
}
   801f8:	dfc00117 	ldw	ra,4(sp)
   801fc:	dec00204 	addi	sp,sp,8
	alt_printf( " %s\n", rx_frame + 44);

	// Create new receive sgdma descriptor
	alt_avalon_sgdma_construct_stream_to_mem_desc( &rx_descriptor, &rx_descriptor_end, (alt_u32 *)rx_frame, 0, 0 );
	// Set up non-blocking transfer of sgdma receive descriptor
	alt_avalon_sgdma_do_async_transfer( sgdma_rx_dev, &rx_descriptor );
   80200:	00809d81 	jmpi	809d8 <alt_avalon_sgdma_do_async_transfer>

00080204 <setup>:
alt_sgdma_descriptor rx_descriptor_end  __attribute__ (( section ( ".descriptor_memory" )));

void setup(void)
{
	// Open the sgdma transmit device
	sgdma_tx_dev = alt_avalon_sgdma_open ("/dev/sgdma_tx");
   80204:	01000234 	movhi	r4,8

alt_sgdma_descriptor rx_descriptor  	__attribute__ (( section ( ".descriptor_memory" )));
alt_sgdma_descriptor rx_descriptor_end  __attribute__ (( section ( ".descriptor_memory" )));

void setup(void)
{
   80208:	defffb04 	addi	sp,sp,-20
	// Open the sgdma transmit device
	sgdma_tx_dev = alt_avalon_sgdma_open ("/dev/sgdma_tx");
   8020c:	2104fa04 	addi	r4,r4,5096

alt_sgdma_descriptor rx_descriptor  	__attribute__ (( section ( ".descriptor_memory" )));
alt_sgdma_descriptor rx_descriptor_end  __attribute__ (( section ( ".descriptor_memory" )));

void setup(void)
{
   80210:	dfc00415 	stw	ra,16(sp)
	// Open the sgdma transmit device
	sgdma_tx_dev = alt_avalon_sgdma_open ("/dev/sgdma_tx");
   80214:	0080b440 	call	80b44 <alt_avalon_sgdma_open>
   80218:	d0a12215 	stw	r2,-31608(gp)
	if (sgdma_tx_dev == NULL) {
   8021c:	1000031e 	bne	r2,zero,8022c <setup+0x28>
		alt_printf ("Error: could not open scatter-gather dma transmit device\n");
   80220:	01000234 	movhi	r4,8
   80224:	2104fe04 	addi	r4,r4,5112
   80228:	00000206 	br	80234 <setup+0x30>
	} else alt_printf ("Opened scatter-gather dma transmit device\n");
   8022c:	01000234 	movhi	r4,8
   80230:	21050d04 	addi	r4,r4,5172
   80234:	00807340 	call	80734 <alt_printf>

	// Open the sgdma receive device
	sgdma_rx_dev = alt_avalon_sgdma_open ("/dev/sgdma_rx");
   80238:	01000234 	movhi	r4,8
   8023c:	21051804 	addi	r4,r4,5216
   80240:	0080b440 	call	80b44 <alt_avalon_sgdma_open>
   80244:	d0a12415 	stw	r2,-31600(gp)
	if (sgdma_rx_dev == NULL) {
   80248:	1000031e 	bne	r2,zero,80258 <setup+0x54>
		alt_printf ("Error: could not open scatter-gather dma receive device\n");
   8024c:	01000234 	movhi	r4,8
   80250:	21051c04 	addi	r4,r4,5232
   80254:	00000206 	br	80260 <setup+0x5c>
	} else alt_printf ("Opened scatter-gather dma receive device\n");
   80258:	01000234 	movhi	r4,8
   8025c:	21052b04 	addi	r4,r4,5292
   80260:	00807340 	call	80734 <alt_printf>

	// Set interrupts for the sgdma receive device
	alt_avalon_sgdma_register_callback( sgdma_rx_dev, (alt_avalon_sgdma_callback) rx_ethernet_isr, 0x00000014, NULL );
   80264:	d1212417 	ldw	r4,-31600(gp)
   80268:	01400234 	movhi	r5,8
   8026c:	000f883a 	mov	r7,zero
   80270:	01800504 	movi	r6,20
   80274:	29406704 	addi	r5,r5,412
   80278:	0080ad40 	call	80ad4 <alt_avalon_sgdma_register_callback>

	// Create sgdma receive descriptor
	alt_avalon_sgdma_construct_stream_to_mem_desc( &rx_descriptor, &rx_descriptor_end, (alt_u32 *)rx_frame, 0, 0 );
   8027c:	01800234 	movhi	r6,8
   80280:	01400434 	movhi	r5,16
   80284:	01000434 	movhi	r4,16
   80288:	000f883a 	mov	r7,zero
   8028c:	31877a04 	addi	r6,r6,7656
   80290:	29400004 	addi	r5,r5,0
   80294:	21000804 	addi	r4,r4,32
   80298:	d8000015 	stw	zero,0(sp)
   8029c:	0080dbc0 	call	80dbc <alt_avalon_sgdma_construct_stream_to_mem_desc>

	// Set up non-blocking transfer of sgdma receive descriptor
	alt_avalon_sgdma_do_async_transfer( sgdma_rx_dev, &rx_descriptor );
   802a0:	d1212417 	ldw	r4,-31600(gp)
   802a4:	01400434 	movhi	r5,16
   802a8:	29400804 	addi	r5,r5,32
   802ac:	00809d80 	call	809d8 <alt_avalon_sgdma_do_async_transfer>

	// Triple-speed Ethernet MegaCore base address
	volatile int * tse = (int *) 0x00102000;

	// Initialize the MAC address
	*(tse + 3) = 0x116E6001;
   802b0:	00800434 	movhi	r2,16
   802b4:	00c45bb4 	movhi	r3,4462
   802b8:	18d80044 	addi	r3,r3,24577
   802bc:	10880304 	addi	r2,r2,8204
   802c0:	10c00015 	stw	r3,0(r2)
	*(tse + 4) = 0x00000F02;
   802c4:	00800434 	movhi	r2,16
   802c8:	00c3c084 	movi	r3,3842
   802cc:	10880404 	addi	r2,r2,8208
   802d0:	10c00015 	stw	r3,0(r2)

	// Specify the addresses of the PHY devices to be accessed through MDIO interface
	*(tse + 0x0F) = 0x10;
   802d4:	00800434 	movhi	r2,16
   802d8:	00c00404 	movi	r3,16
   802dc:	10880f04 	addi	r2,r2,8252
   802e0:	10c00015 	stw	r3,0(r2)
	*(tse + 0x10) = 0x11;
   802e4:	00800434 	movhi	r2,16
   802e8:	00c00444 	movi	r3,17
   802ec:	10881004 	addi	r2,r2,8256
   802f0:	10c00015 	stw	r3,0(r2)

	// Write to register 20 of the PHY chip for Ethernet port 0 to set up line loopback
	*(tse + 0x94) = 0x4000;
   802f4:	00800434 	movhi	r2,16
   802f8:	00d00004 	movi	r3,16384
   802fc:	10889404 	addi	r2,r2,8784
   80300:	10c00015 	stw	r3,0(r2)

	// Write to register 16 of the PHY chip for Ethernet port 1 to enable automatic crossover for all modes
	*(tse + 0xB0) = *(tse + 0xB0) | 0x0060;
   80304:	00c00434 	movhi	r3,16
   80308:	18c8b004 	addi	r3,r3,8896
   8030c:	18800017 	ldw	r2,0(r3)
   80310:	10801814 	ori	r2,r2,96
   80314:	18800015 	stw	r2,0(r3)

	// Write to register 20 of the PHY chip for Ethernet port 2 to set up delay for input/output clk
	*(tse + 0xB4) = *(tse + 0xB4) | 0x0082;
   80318:	00c00434 	movhi	r3,16
   8031c:	18c8b404 	addi	r3,r3,8912
   80320:	18800017 	ldw	r2,0(r3)
   80324:	10802094 	ori	r2,r2,130
   80328:	18800015 	stw	r2,0(r3)

	// Software reset the second PHY chip and wait
	*(tse + 0xA0) = *(tse + 0xA0) | 0x8000;
   8032c:	00800434 	movhi	r2,16
   80330:	1088a004 	addi	r2,r2,8832
   80334:	10c00017 	ldw	r3,0(r2)
   80338:	18e00014 	ori	r3,r3,32768
   8033c:	10c00015 	stw	r3,0(r2)
	while ( *(tse + 0xA0) & 0x8000  )
   80340:	10c00017 	ldw	r3,0(r2)
   80344:	18e0000c 	andi	r3,r3,32768
   80348:	183ffd1e 	bne	r3,zero,80340 <setup+0x13c>
		;

	// Enable read and write transfers, gigabit Ethernet operation, and CRC forwarding
	*(tse + 2) = *(tse + 2) | 0x00000043;
   8034c:	00c00434 	movhi	r3,16
   80350:	18c80204 	addi	r3,r3,8200
   80354:	18800017 	ldw	r2,0(r3)

	// Create transmit sgdma descriptor
	alt_avalon_sgdma_construct_mem_to_stream_desc( &tx_descriptor, &tx_descriptor_end, (alt_u32 *)tx_frame, 62, 0, 1, 1, 0 );
   80358:	01800234 	movhi	r6,8
   8035c:	01400434 	movhi	r5,16
	*(tse + 0xA0) = *(tse + 0xA0) | 0x8000;
	while ( *(tse + 0xA0) & 0x8000  )
		;

	// Enable read and write transfers, gigabit Ethernet operation, and CRC forwarding
	*(tse + 2) = *(tse + 2) | 0x00000043;
   80360:	108010d4 	ori	r2,r2,67
   80364:	18800015 	stw	r2,0(r3)

	// Create transmit sgdma descriptor
	alt_avalon_sgdma_construct_mem_to_stream_desc( &tx_descriptor, &tx_descriptor_end, (alt_u32 *)tx_frame, 62, 0, 1, 1, 0 );
   80368:	01000434 	movhi	r4,16
   8036c:	00800044 	movi	r2,1
   80370:	29401004 	addi	r5,r5,64
   80374:	21001804 	addi	r4,r4,96
   80378:	d8000315 	stw	zero,12(sp)
   8037c:	d8800215 	stw	r2,8(sp)
   80380:	d8800115 	stw	r2,4(sp)
   80384:	d8000015 	stw	zero,0(sp)
   80388:	01c00f84 	movi	r7,62
   8038c:	31853604 	addi	r6,r6,5336
   80390:	0080e340 	call	80e34 <alt_avalon_sgdma_construct_mem_to_stream_desc>
	// Set up non-blocking transfer of sgdma transmit descriptor
	alt_avalon_sgdma_do_async_transfer( sgdma_tx_dev, &tx_descriptor );
   80394:	d1212217 	ldw	r4,-31608(gp)
   80398:	01400434 	movhi	r5,16
   8039c:	29401804 	addi	r5,r5,96
   803a0:	00809d80 	call	809d8 <alt_avalon_sgdma_do_async_transfer>
	// Wait until transmit descriptor transfer is complete
	while (alt_avalon_sgdma_check_descriptor_status(&tx_descriptor) != 0);
   803a4:	01000434 	movhi	r4,16
   803a8:	21001804 	addi	r4,r4,96
   803ac:	0080b180 	call	80b18 <alt_avalon_sgdma_check_descriptor_status>
   803b0:	103ffc1e 	bne	r2,zero,803a4 <setup+0x1a0>
}
   803b4:	dfc00417 	ldw	ra,16(sp)
   803b8:	dec00504 	addi	sp,sp,20
   803bc:	f800283a 	ret

000803c0 <refresh_ethernet>:

void refresh_ethernet(){
   803c0:	defffb04 	addi	sp,sp,-20
	// Create transmit sgdma descriptor
	alt_avalon_sgdma_construct_mem_to_stream_desc( &tx_descriptor, &tx_descriptor_end, (alt_u32 *)tx_frame, 62, 0, 1, 1, 0 );
   803c4:	00800044 	movi	r2,1
   803c8:	01800234 	movhi	r6,8
   803cc:	01400434 	movhi	r5,16
   803d0:	01000434 	movhi	r4,16
   803d4:	d8000315 	stw	zero,12(sp)
   803d8:	d8800215 	stw	r2,8(sp)
   803dc:	d8800115 	stw	r2,4(sp)
   803e0:	d8000015 	stw	zero,0(sp)
   803e4:	01c00f84 	movi	r7,62
   803e8:	31853604 	addi	r6,r6,5336
   803ec:	29401004 	addi	r5,r5,64
   803f0:	21001804 	addi	r4,r4,96
	alt_avalon_sgdma_do_async_transfer( sgdma_tx_dev, &tx_descriptor );
	// Wait until transmit descriptor transfer is complete
	while (alt_avalon_sgdma_check_descriptor_status(&tx_descriptor) != 0);
}

void refresh_ethernet(){
   803f4:	dfc00415 	stw	ra,16(sp)
	// Create transmit sgdma descriptor
	alt_avalon_sgdma_construct_mem_to_stream_desc( &tx_descriptor, &tx_descriptor_end, (alt_u32 *)tx_frame, 62, 0, 1, 1, 0 );
   803f8:	0080e340 	call	80e34 <alt_avalon_sgdma_construct_mem_to_stream_desc>
}
   803fc:	dfc00417 	ldw	ra,16(sp)
   80400:	dec00504 	addi	sp,sp,20
   80404:	f800283a 	ret

00080408 <tx_ethernet_isr>:
	alt_avalon_sgdma_construct_stream_to_mem_desc( &rx_descriptor, &rx_descriptor_end, (alt_u32 *)rx_frame, 0, 0 );
	// Set up non-blocking transfer of sgdma receive descriptor
	alt_avalon_sgdma_do_async_transfer( sgdma_rx_dev, &rx_descriptor );
}

void tx_ethernet_isr(char *chars){
   80408:	00800234 	movhi	r2,8
   8040c:	10853a04 	addi	r2,r2,5352
   80410:	20c00184 	addi	r3,r4,6
			for(int x = 0; x < 6; x++){
				tx_frame[16 + x] = chars[x];
   80414:	21400003 	ldbu	r5,0(r4)
   80418:	21000044 	addi	r4,r4,1
   8041c:	10800044 	addi	r2,r2,1
   80420:	117fffc5 	stb	r5,-1(r2)
	// Set up non-blocking transfer of sgdma receive descriptor
	alt_avalon_sgdma_do_async_transfer( sgdma_rx_dev, &rx_descriptor );
}

void tx_ethernet_isr(char *chars){
			for(int x = 0; x < 6; x++){
   80424:	20fffb1e 	bne	r4,r3,80414 <tx_ethernet_isr+0xc>
	alt_avalon_sgdma_construct_stream_to_mem_desc( &rx_descriptor, &rx_descriptor_end, (alt_u32 *)rx_frame, 0, 0 );
	// Set up non-blocking transfer of sgdma receive descriptor
	alt_avalon_sgdma_do_async_transfer( sgdma_rx_dev, &rx_descriptor );
}

void tx_ethernet_isr(char *chars){
   80428:	defffb04 	addi	sp,sp,-20
			for(int x = 0; x < 6; x++){
				tx_frame[16 + x] = chars[x];
			}
			// Create transmit sgdma descriptor
			alt_avalon_sgdma_construct_mem_to_stream_desc( &tx_descriptor, &tx_descriptor_end, (alt_u32 *)tx_frame, 62, 0, 1, 1, 0 );
   8042c:	00800044 	movi	r2,1
   80430:	01800234 	movhi	r6,8
   80434:	01400434 	movhi	r5,16
   80438:	01000434 	movhi	r4,16
   8043c:	29401004 	addi	r5,r5,64
   80440:	21001804 	addi	r4,r4,96
   80444:	d8000315 	stw	zero,12(sp)
   80448:	d8800215 	stw	r2,8(sp)
   8044c:	d8800115 	stw	r2,4(sp)
   80450:	d8000015 	stw	zero,0(sp)
   80454:	01c00f84 	movi	r7,62
   80458:	31853604 	addi	r6,r6,5336
	alt_avalon_sgdma_construct_stream_to_mem_desc( &rx_descriptor, &rx_descriptor_end, (alt_u32 *)rx_frame, 0, 0 );
	// Set up non-blocking transfer of sgdma receive descriptor
	alt_avalon_sgdma_do_async_transfer( sgdma_rx_dev, &rx_descriptor );
}

void tx_ethernet_isr(char *chars){
   8045c:	dfc00415 	stw	ra,16(sp)
			for(int x = 0; x < 6; x++){
				tx_frame[16 + x] = chars[x];
			}
			// Create transmit sgdma descriptor
			alt_avalon_sgdma_construct_mem_to_stream_desc( &tx_descriptor, &tx_descriptor_end, (alt_u32 *)tx_frame, 62, 0, 1, 1, 0 );
   80460:	0080e340 	call	80e34 <alt_avalon_sgdma_construct_mem_to_stream_desc>
			// Set up non-blocking transfer of sgdma transmit descriptor
			alt_avalon_sgdma_do_async_transfer( sgdma_tx_dev, &tx_descriptor );
   80464:	d1212217 	ldw	r4,-31608(gp)
   80468:	01400434 	movhi	r5,16
   8046c:	29401804 	addi	r5,r5,96
   80470:	00809d80 	call	809d8 <alt_avalon_sgdma_do_async_transfer>
			// Wait until transmit descriptor transfer is complete
			while (alt_avalon_sgdma_check_descriptor_status(&tx_descriptor) != 0);
   80474:	01000434 	movhi	r4,16
   80478:	21001804 	addi	r4,r4,96
   8047c:	0080b180 	call	80b18 <alt_avalon_sgdma_check_descriptor_status>
   80480:	103ffc1e 	bne	r2,zero,80474 <tx_ethernet_isr+0x6c>

}
   80484:	dfc00417 	ldw	ra,16(sp)
   80488:	dec00504 	addi	sp,sp,20
   8048c:	f800283a 	ret

00080490 <drawColor>:
	  int b = rand()%(255-0 + 1) + 0;
	  drawColor((r<<16)| (g<<8) | b);
  }
}

void drawColor(int hex){
   80490:	defffe04 	addi	sp,sp,-8
   80494:	dc000015 	stw	r16,0(sp)
   80498:	dfc00115 	stw	ra,4(sp)
   8049c:	04027104 	movi	r16,2500
	int x = 0;
	while(x < width * height * 4){
		//Draw single pixel to video memory used by VGA controller
		//IOWR_ALTERA_AVALON_PIO_DATA(x ,hex);
		//Delay voor leuk effect
		usleep(500);
   804a0:	01007d04 	movi	r4,500
   804a4:	843fffc4 	addi	r16,r16,-1
   804a8:	00808ec0 	call	808ec <usleep>
void drawColor(int hex){
	int width = 50;
	int height = 50;

	int x = 0;
	while(x < width * height * 4){
   804ac:	803ffc1e 	bne	r16,zero,804a0 <drawColor+0x10>
		//IOWR_ALTERA_AVALON_PIO_DATA(x ,hex);
		//Delay voor leuk effect
		usleep(500);
		x+=4;
	}
}
   804b0:	dfc00117 	ldw	ra,4(sp)
   804b4:	dc000017 	ldw	r16,0(sp)
   804b8:	dec00204 	addi	sp,sp,8
   804bc:	f800283a 	ret

000804c0 <video>:
#include "system.h"
//#include "altera_avalon_pio_regs.h"


void video()
{
   804c0:	defffa04 	addi	sp,sp,-24
   804c4:	dc800215 	stw	r18,8(sp)
  {
	  //Random RGB kleur
	  int r = rand()%(255-0 + 1) + 0;
	  int g = rand()%(255-0 + 1) + 0;
	  int b = rand()%(255-0 + 1) + 0;
	  drawColor((r<<16)| (g<<8) | b);
   804c8:	04a00034 	movhi	r18,32768
   804cc:	94803fc4 	addi	r18,r18,255
#include "system.h"
//#include "altera_avalon_pio_regs.h"


void video()
{
   804d0:	dd000415 	stw	r20,16(sp)
   804d4:	dcc00315 	stw	r19,12(sp)
   804d8:	dfc00515 	stw	ra,20(sp)
   804dc:	dc400115 	stw	r17,4(sp)
   804e0:	dc000015 	stw	r16,0(sp)
   804e4:	9027883a 	mov	r19,r18
  {
	  //Random RGB kleur
	  int r = rand()%(255-0 + 1) + 0;
	  int g = rand()%(255-0 + 1) + 0;
	  int b = rand()%(255-0 + 1) + 0;
	  drawColor((r<<16)| (g<<8) | b);
   804e8:	053fc004 	movi	r20,-256
{

  while (1)
  {
	  //Random RGB kleur
	  int r = rand()%(255-0 + 1) + 0;
   804ec:	00805680 	call	80568 <rand>
   804f0:	1023883a 	mov	r17,r2
	  int g = rand()%(255-0 + 1) + 0;
   804f4:	00805680 	call	80568 <rand>
   804f8:	1021883a 	mov	r16,r2
	  int b = rand()%(255-0 + 1) + 0;
   804fc:	00805680 	call	80568 <rand>
	  drawColor((r<<16)| (g<<8) | b);
   80500:	8c86703a 	and	r3,r17,r18
   80504:	1800030e 	bge	r3,zero,80514 <video+0x54>
   80508:	18ffffc4 	addi	r3,r3,-1
   8050c:	1d06b03a 	or	r3,r3,r20
   80510:	18c00044 	addi	r3,r3,1
   80514:	1808943a 	slli	r4,r3,16
   80518:	84c6703a 	and	r3,r16,r19
   8051c:	1800030e 	bge	r3,zero,8052c <video+0x6c>
   80520:	18ffffc4 	addi	r3,r3,-1
   80524:	1d06b03a 	or	r3,r3,r20
   80528:	18c00044 	addi	r3,r3,1
   8052c:	1806923a 	slli	r3,r3,8
   80530:	20c6b03a 	or	r3,r4,r3
   80534:	14c8703a 	and	r4,r2,r19
   80538:	2000030e 	bge	r4,zero,80548 <video+0x88>
   8053c:	213fffc4 	addi	r4,r4,-1
   80540:	2508b03a 	or	r4,r4,r20
   80544:	21000044 	addi	r4,r4,1
   80548:	1908b03a 	or	r4,r3,r4
   8054c:	00804900 	call	80490 <drawColor>
   80550:	003fe606 	br	804ec <video+0x2c>

00080554 <srand>:
   80554:	00800234 	movhi	r2,8
   80558:	10877304 	addi	r2,r2,7628
   8055c:	11000015 	stw	r4,0(r2)
   80560:	10000115 	stw	zero,4(r2)
   80564:	f800283a 	ret

00080568 <rand>:
   80568:	defffe04 	addi	sp,sp,-8
   8056c:	dc000015 	stw	r16,0(sp)
   80570:	04000234 	movhi	r16,8
   80574:	84077304 	addi	r16,r16,7628
   80578:	81000017 	ldw	r4,0(r16)
   8057c:	81400117 	ldw	r5,4(r16)
   80580:	01932574 	movhi	r6,19605
   80584:	01d614b4 	movhi	r7,22610
   80588:	319fcb44 	addi	r6,r6,32557
   8058c:	39fd0b44 	addi	r7,r7,-3027
   80590:	dfc00115 	stw	ra,4(sp)
   80594:	00805c80 	call	805c8 <__muldi3>
   80598:	11000044 	addi	r4,r2,1
   8059c:	2085803a 	cmpltu	r2,r4,r2
   805a0:	10c7883a 	add	r3,r2,r3
   805a4:	00a00034 	movhi	r2,32768
   805a8:	10bfffc4 	addi	r2,r2,-1
   805ac:	1884703a 	and	r2,r3,r2
   805b0:	81000015 	stw	r4,0(r16)
   805b4:	80c00115 	stw	r3,4(r16)
   805b8:	dfc00117 	ldw	ra,4(sp)
   805bc:	dc000017 	ldw	r16,0(sp)
   805c0:	dec00204 	addi	sp,sp,8
   805c4:	f800283a 	ret

000805c8 <__muldi3>:
   805c8:	223fffcc 	andi	r8,r4,65535
   805cc:	2006d43a 	srli	r3,r4,16
   805d0:	32bfffcc 	andi	r10,r6,65535
   805d4:	3012d43a 	srli	r9,r6,16
   805d8:	4297383a 	mul	r11,r8,r10
   805dc:	1a95383a 	mul	r10,r3,r10
   805e0:	4251383a 	mul	r8,r8,r9
   805e4:	5804d43a 	srli	r2,r11,16
   805e8:	4291883a 	add	r8,r8,r10
   805ec:	1205883a 	add	r2,r2,r8
   805f0:	1a51383a 	mul	r8,r3,r9
   805f4:	1280022e 	bgeu	r2,r10,80600 <__muldi3+0x38>
   805f8:	00c00074 	movhi	r3,1
   805fc:	40d1883a 	add	r8,r8,r3
   80600:	1006d43a 	srli	r3,r2,16
   80604:	21cf383a 	mul	r7,r4,r7
   80608:	314b383a 	mul	r5,r6,r5
   8060c:	1004943a 	slli	r2,r2,16
   80610:	1a11883a 	add	r8,r3,r8
   80614:	5affffcc 	andi	r11,r11,65535
   80618:	3947883a 	add	r3,r7,r5
   8061c:	12c5883a 	add	r2,r2,r11
   80620:	1a07883a 	add	r3,r3,r8
   80624:	f800283a 	ret

00080628 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
   80628:	deffff04 	addi	sp,sp,-4
   8062c:	01000234 	movhi	r4,8
   80630:	01400234 	movhi	r5,8
   80634:	dfc00015 	stw	ra,0(sp)
   80638:	21053604 	addi	r4,r4,5336
   8063c:	29465304 	addi	r5,r5,6476

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
   80640:	2140061e 	bne	r4,r5,8065c <alt_load+0x34>
   80644:	01000234 	movhi	r4,8
   80648:	01400234 	movhi	r5,8
   8064c:	21000804 	addi	r4,r4,32
   80650:	29400804 	addi	r5,r5,32
   80654:	2140121e 	bne	r4,r5,806a0 <alt_load+0x78>
   80658:	00000b06 	br	80688 <alt_load+0x60>
   8065c:	00c00234 	movhi	r3,8
   80660:	18c65304 	addi	r3,r3,6476
   80664:	1907c83a 	sub	r3,r3,r4
   80668:	0005883a 	mov	r2,zero
  {
    while( to != end )
   8066c:	10fff526 	beq	r2,r3,80644 <alt_load+0x1c>
    {
      *to++ = *from++;
   80670:	114f883a 	add	r7,r2,r5
   80674:	39c00017 	ldw	r7,0(r7)
   80678:	110d883a 	add	r6,r2,r4
   8067c:	10800104 	addi	r2,r2,4
   80680:	31c00015 	stw	r7,0(r6)
   80684:	003ff906 	br	8066c <alt_load+0x44>
   80688:	01000234 	movhi	r4,8
   8068c:	01400234 	movhi	r5,8
   80690:	2104f804 	addi	r4,r4,5088
   80694:	2944f804 	addi	r5,r5,5088

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
   80698:	2140101e 	bne	r4,r5,806dc <alt_load+0xb4>
   8069c:	00000b06 	br	806cc <alt_load+0xa4>
   806a0:	00c00234 	movhi	r3,8
   806a4:	18c05304 	addi	r3,r3,332
   806a8:	1907c83a 	sub	r3,r3,r4
   806ac:	0005883a 	mov	r2,zero
  {
    while( to != end )
   806b0:	10fff526 	beq	r2,r3,80688 <alt_load+0x60>
    {
      *to++ = *from++;
   806b4:	114f883a 	add	r7,r2,r5
   806b8:	39c00017 	ldw	r7,0(r7)
   806bc:	110d883a 	add	r6,r2,r4
   806c0:	10800104 	addi	r2,r2,4
   806c4:	31c00015 	stw	r7,0(r6)
   806c8:	003ff906 	br	806b0 <alt_load+0x88>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
   806cc:	0080fbc0 	call	80fbc <alt_dcache_flush_all>
  alt_icache_flush_all();
}
   806d0:	dfc00017 	ldw	ra,0(sp)
   806d4:	dec00104 	addi	sp,sp,4
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  alt_icache_flush_all();
   806d8:	00810a01 	jmpi	810a0 <alt_icache_flush_all>
   806dc:	00c00234 	movhi	r3,8
   806e0:	18c53604 	addi	r3,r3,5336
   806e4:	1907c83a 	sub	r3,r3,r4

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
   806e8:	0005883a 	mov	r2,zero
  {
    while( to != end )
   806ec:	18bff726 	beq	r3,r2,806cc <alt_load+0xa4>
    {
      *to++ = *from++;
   806f0:	114f883a 	add	r7,r2,r5
   806f4:	39c00017 	ldw	r7,0(r7)
   806f8:	110d883a 	add	r6,r2,r4
   806fc:	10800104 	addi	r2,r2,4
   80700:	31c00015 	stw	r7,0(r6)
   80704:	003ff906 	br	806ec <alt_load+0xc4>

00080708 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
   80708:	deffff04 	addi	sp,sp,-4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
   8070c:	0009883a 	mov	r4,zero
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
   80710:	dfc00015 	stw	ra,0(sp)
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
   80714:	00808f00 	call	808f0 <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
   80718:	00809100 	call	80910 <alt_sys_init>
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
   8071c:	d1a12717 	ldw	r6,-31588(gp)
   80720:	d1612817 	ldw	r5,-31584(gp)
   80724:	d1212917 	ldw	r4,-31580(gp)
  close(STDOUT_FILENO);
  exit (result);
#endif

  ALT_LOG_PRINT_BOOT("[alt_main.c] After main - we should not be here?.\r\n");
}
   80728:	dfc00017 	ldw	ra,0(sp)
   8072c:	dec00104 	addi	sp,sp,4
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
   80730:	00801881 	jmpi	80188 <main>

00080734 <alt_printf>:
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
   80734:	defff204 	addi	sp,sp,-56
   80738:	2005883a 	mov	r2,r4
   8073c:	dfc00a15 	stw	ra,40(sp)
   80740:	df000915 	stw	fp,36(sp)
   80744:	ddc00815 	stw	r23,32(sp)
   80748:	dd800715 	stw	r22,28(sp)
   8074c:	dd400615 	stw	r21,24(sp)
   80750:	dd000515 	stw	r20,20(sp)
   80754:	dcc00415 	stw	r19,16(sp)
   80758:	dc800315 	stw	r18,12(sp)
   8075c:	dc400215 	stw	r17,8(sp)
   80760:	dc000115 	stw	r16,4(sp)
   80764:	d9400b15 	stw	r5,44(sp)
   80768:	d9800c15 	stw	r6,48(sp)
   8076c:	d9c00d15 	stw	r7,52(sp)
    w = fmt;
    while ((c = *w++) != 0)
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
   80770:	04000944 	movi	r16,37
 */
void 
alt_printf(const char* fmt, ... )
{
	va_list args;
	va_start(args, fmt);
   80774:	dd400b04 	addi	r21,sp,44
                if (c == '%')
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
                } 
                else if (c == 'c')
   80778:	048018c4 	movi	r18,99
                {
                    int v = va_arg(args, int);
                    alt_putchar(v);
                }
                else if (c == 'x')
   8077c:	04c01e04 	movi	r19,120
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
   80780:	05001cc4 	movi	r20,115
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
   80784:	11000007 	ldb	r4,0(r2)
   80788:	20003a26 	beq	r4,zero,80874 <alt_printf+0x140>
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
   8078c:	24000226 	beq	r4,r16,80798 <alt_printf+0x64>
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
   80790:	14400044 	addi	r17,r2,1
   80794:	00001406 	br	807e8 <alt_printf+0xb4>
        }
        else
        {
            /* Get format character.  If none     */
            /* available, processing is complete. */
            if ((c = *w++) != 0)
   80798:	14400084 	addi	r17,r2,2
   8079c:	10800047 	ldb	r2,1(r2)
   807a0:	10003426 	beq	r2,zero,80874 <alt_printf+0x140>
            {
                if (c == '%')
   807a4:	1400021e 	bne	r2,r16,807b0 <alt_printf+0x7c>
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
   807a8:	8009883a 	mov	r4,r16
   807ac:	00000e06 	br	807e8 <alt_printf+0xb4>
                } 
                else if (c == 'c')
   807b0:	1480051e 	bne	r2,r18,807c8 <alt_printf+0x94>
                {
                    int v = va_arg(args, int);
                    alt_putchar(v);
   807b4:	a9000017 	ldw	r4,0(r21)
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
                } 
                else if (c == 'c')
                {
                    int v = va_arg(args, int);
   807b8:	ad800104 	addi	r22,r21,4
   807bc:	b02b883a 	mov	r21,r22
                    alt_putchar(v);
   807c0:	00808a40 	call	808a4 <alt_putchar>
   807c4:	00002906 	br	8086c <alt_printf+0x138>
                }
                else if (c == 'x')
   807c8:	14c0201e 	bne	r2,r19,8084c <alt_printf+0x118>
                {
                    /* Process hexadecimal number format. */
                    unsigned long v = va_arg(args, unsigned long);
   807cc:	adc00017 	ldw	r23,0(r21)
   807d0:	ad400104 	addi	r21,r21,4
                    unsigned long digit;
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
   807d4:	b8000326 	beq	r23,zero,807e4 <alt_printf+0xb0>
   807d8:	05800704 	movi	r22,28
                        continue;
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
   807dc:	00c003c4 	movi	r3,15
   807e0:	00000306 	br	807f0 <alt_printf+0xbc>
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
                    {
                        alt_putchar('0');
   807e4:	01000c04 	movi	r4,48
   807e8:	00808a40 	call	808a4 <alt_putchar>
                        continue;
   807ec:	00001f06 	br	8086c <alt_printf+0x138>
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
   807f0:	1d84983a 	sll	r2,r3,r22
   807f4:	15c4703a 	and	r2,r2,r23
   807f8:	1000021e 	bne	r2,zero,80804 <alt_printf+0xd0>
                        digit_shift -= 4;
   807fc:	b5bfff04 	addi	r22,r22,-4
   80800:	003ffb06 	br	807f0 <alt_printf+0xbc>

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
   80804:	070003c4 	movi	fp,15
                        if (digit <= 9)
   80808:	00c00244 	movi	r3,9
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
   8080c:	b0001716 	blt	r22,zero,8086c <alt_printf+0x138>
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
   80810:	e588983a 	sll	r4,fp,r22
   80814:	25c8703a 	and	r4,r4,r23
   80818:	2588d83a 	srl	r4,r4,r22
                        if (digit <= 9)
   8081c:	19000236 	bltu	r3,r4,80828 <alt_printf+0xf4>
                            c = '0' + digit;
   80820:	21000c04 	addi	r4,r4,48
   80824:	00000106 	br	8082c <alt_printf+0xf8>
                        else
                            c = 'a' + digit - 10;
   80828:	210015c4 	addi	r4,r4,87
                        alt_putchar(c);
   8082c:	21003fcc 	andi	r4,r4,255
   80830:	2100201c 	xori	r4,r4,128
   80834:	213fe004 	addi	r4,r4,-128
   80838:	d8c00015 	stw	r3,0(sp)
   8083c:	00808a40 	call	808a4 <alt_putchar>
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
   80840:	b5bfff04 	addi	r22,r22,-4
   80844:	d8c00017 	ldw	r3,0(sp)
   80848:	003ff006 	br	8080c <alt_printf+0xd8>
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
   8084c:	1500071e 	bne	r2,r20,8086c <alt_printf+0x138>
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);
   80850:	ad800017 	ldw	r22,0(r21)
   80854:	ad400104 	addi	r21,r21,4

                    while(*s)
   80858:	b1000007 	ldb	r4,0(r22)
   8085c:	20000326 	beq	r4,zero,8086c <alt_printf+0x138>
                      alt_putchar(*s++);
   80860:	b5800044 	addi	r22,r22,1
   80864:	00808a40 	call	808a4 <alt_putchar>
   80868:	003ffb06 	br	80858 <alt_printf+0x124>
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
                } 
                else if (c == 'c')
                {
                    int v = va_arg(args, int);
   8086c:	8805883a 	mov	r2,r17
   80870:	003fc406 	br	80784 <alt_printf+0x50>
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
   80874:	dfc00a17 	ldw	ra,40(sp)
   80878:	df000917 	ldw	fp,36(sp)
   8087c:	ddc00817 	ldw	r23,32(sp)
   80880:	dd800717 	ldw	r22,28(sp)
   80884:	dd400617 	ldw	r21,24(sp)
   80888:	dd000517 	ldw	r20,20(sp)
   8088c:	dcc00417 	ldw	r19,16(sp)
   80890:	dc800317 	ldw	r18,12(sp)
   80894:	dc400217 	ldw	r17,8(sp)
   80898:	dc000117 	ldw	r16,4(sp)
   8089c:	dec00e04 	addi	sp,sp,56
   808a0:	f800283a 	ret

000808a4 <alt_putchar>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
   808a4:	defffd04 	addi	sp,sp,-12
   808a8:	dc000115 	stw	r16,4(sp)
	char        c1 = (char)(c & 0xff);
    return write(STDOUT_FILENO,&c1,1);
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    char        c1 = (char)(c & 0xff);
   808ac:	d9000005 	stb	r4,0(sp)
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
   808b0:	2021883a 	mov	r16,r4
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    char        c1 = (char)(c & 0xff);

    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
   808b4:	01000234 	movhi	r4,8
   808b8:	000f883a 	mov	r7,zero
   808bc:	01800044 	movi	r6,1
   808c0:	d80b883a 	mov	r5,sp
   808c4:	21064e04 	addi	r4,r4,6456
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
   808c8:	dfc00215 	stw	ra,8(sp)
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    char        c1 = (char)(c & 0xff);

    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
   808cc:	00809480 	call	80948 <altera_avalon_jtag_uart_write>
   808d0:	00ffffc4 	movi	r3,-1
   808d4:	10c00126 	beq	r2,r3,808dc <alt_putchar+0x38>
        return -1;
    }
    return c;
   808d8:	8005883a 	mov	r2,r16
#else
    return putchar(c);
#endif
#endif
}
   808dc:	dfc00217 	ldw	ra,8(sp)
   808e0:	dc000117 	ldw	r16,4(sp)
   808e4:	dec00304 	addi	sp,sp,12
   808e8:	f800283a 	ret

000808ec <usleep>:
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
  return alt_busy_sleep(us);
   808ec:	0080f401 	jmpi	80f40 <alt_busy_sleep>

000808f0 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
   808f0:	deffff04 	addi	sp,sp,-4
   808f4:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_QSYS_IRQ_INIT ( NIOS2, nios2);
   808f8:	00811a00 	call	811a0 <altera_nios2_qsys_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
   808fc:	00800044 	movi	r2,1
   80900:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
   80904:	dfc00017 	ldw	ra,0(sp)
   80908:	dec00104 	addi	sp,sp,4
   8090c:	f800283a 	ret

00080910 <alt_sys_init>:
 */

void alt_sys_init( void )
{
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_RX, sgdma_rx);
   80910:	01000234 	movhi	r4,8
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
   80914:	deffff04 	addi	sp,sp,-4
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_RX, sgdma_rx);
   80918:	01800044 	movi	r6,1
   8091c:	000b883a 	mov	r5,zero
   80920:	21064204 	addi	r4,r4,6408
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
   80924:	dfc00015 	stw	ra,0(sp)
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_RX, sgdma_rx);
   80928:	0080ebc0 	call	80ebc <alt_avalon_sgdma_init>
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_TX, sgdma_tx);
   8092c:	01000234 	movhi	r4,8
   80930:	01800084 	movi	r6,2
   80934:	000b883a 	mov	r5,zero
   80938:	21063604 	addi	r4,r4,6360
    ALTERA_ETH_TSE_INIT ( ETH_TSE, eth_tse);
}
   8093c:	dfc00017 	ldw	ra,0(sp)
   80940:	dec00104 	addi	sp,sp,4

void alt_sys_init( void )
{
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_RX, sgdma_rx);
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_TX, sgdma_tx);
   80944:	0080ebc1 	jmpi	80ebc <alt_avalon_sgdma_init>

00080948 <altera_avalon_jtag_uart_write>:
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  unsigned int base = sp->base;
   80948:	21000017 	ldw	r4,0(r4)
 * one FIFOs worth of data.  But you said you didn't want to use interrupts :-)
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
   8094c:	3005883a 	mov	r2,r6
  unsigned int base = sp->base;

  const char * end = ptr + count;
   80950:	298d883a 	add	r6,r5,r6

  while (ptr < end)
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
   80954:	21c00104 	addi	r7,r4,4
{
  unsigned int base = sp->base;

  const char * end = ptr + count;

  while (ptr < end)
   80958:	2980072e 	bgeu	r5,r6,80978 <altera_avalon_jtag_uart_write+0x30>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
   8095c:	38c00037 	ldwio	r3,0(r7)
   80960:	18ffffec 	andhi	r3,r3,65535
   80964:	183ffc26 	beq	r3,zero,80958 <altera_avalon_jtag_uart_write+0x10>
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);
   80968:	28c00007 	ldb	r3,0(r5)
   8096c:	20c00035 	stwio	r3,0(r4)
   80970:	29400044 	addi	r5,r5,1
   80974:	003ff806 	br	80958 <altera_avalon_jtag_uart_write+0x10>

  return count;
}
   80978:	f800283a 	ret

0008097c <alt_avalon_sgdma_irq>:
   * Note: This is explicitly done before calling user interrupt-handling
   * code rather than after; if user ISR code initiates another SGDMA
   * transfer which completes quickly, reading the control register after
   * the callback routine may result in a lost interrupt.
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
   8097c:	20800317 	ldw	r2,12(r4)
   80980:	10800404 	addi	r2,r2,16
   80984:	10c00037 	ldwio	r3,0(r2)
   80988:	18e00034 	orhi	r3,r3,32768
   8098c:	10c00035 	stwio	r3,0(r2)
    IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) | 0x80000000);
  
  /* Dummy read to ensure IRQ is negated before the ISR returns */
  IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
   80990:	20800317 	ldw	r2,12(r4)
   80994:	10800437 	ldwio	r2,16(r2)
   * Other interrupts are explicitly disabled if callbacks
   * are registered because there is no guarantee that they are 
   * preemption-safe. This allows the driver to support 
   * interrupt preemption.
   */
  if(dev->callback) {
   80998:	20c00917 	ldw	r3,36(r4)
   8099c:	18000d26 	beq	r3,zero,809d4 <alt_avalon_sgdma_irq+0x58>
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_sgdma_irq(void *context)
#else
static void alt_avalon_sgdma_irq(void *context, alt_u32 id)
#endif
{
   809a0:	defffe04 	addi	sp,sp,-8
   809a4:	dfc00115 	stw	ra,4(sp)
   809a8:	dc000015 	stw	r16,0(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   809ac:	0021303a 	rdctl	r16,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   809b0:	00bfff84 	movi	r2,-2
   809b4:	8084703a 	and	r2,r16,r2
   809b8:	1001703a 	wrctl	status,r2
   * preemption-safe. This allows the driver to support 
   * interrupt preemption.
   */
  if(dev->callback) {
    cpu_sr = alt_irq_disable_all();
    (dev->callback)(dev->callback_context);
   809bc:	21000a17 	ldw	r4,40(r4)
   809c0:	183ee83a 	callr	r3
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   809c4:	8001703a 	wrctl	status,r16
    alt_irq_enable_all(cpu_sr);
  }
}
   809c8:	dfc00117 	ldw	ra,4(sp)
   809cc:	dc000017 	ldw	r16,0(sp)
   809d0:	dec00204 	addi	sp,sp,8
   809d4:	f800283a 	ret

000809d8 <alt_avalon_sgdma_do_async_transfer>:
  alt_sgdma_descriptor *desc)
{
  alt_u32 control;

  /* Return with error immediately if controller is busy */
  if( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
   809d8:	20c00317 	ldw	r3,12(r4)
   809dc:	18800037 	ldwio	r2,0(r3)
   809e0:	1080040c 	andi	r2,r2,16
   809e4:	1000191e 	bne	r2,zero,80a4c <alt_avalon_sgdma_do_async_transfer+0x74>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    return -EBUSY;
  }

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
   809e8:	18c00404 	addi	r3,r3,16
   809ec:	19c00037 	ldwio	r7,0(r3)
   809f0:	01bff7c4 	movi	r6,-33
   809f4:	398c703a 	and	r6,r7,r6
   809f8:	19800035 	stwio	r6,0(r3)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
   809fc:	20c00317 	ldw	r3,12(r4)
   80a00:	01803fc4 	movi	r6,255
   80a04:	19800035 	stwio	r6,0(r3)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
   80a08:	20c00317 	ldw	r3,12(r4)
   80a0c:	19400835 	stwio	r5,32(r3)
   80a10:	20c00317 	ldw	r3,12(r4)
   *  - Stop on an error with any particular descriptor
   *  - Include any control register bits registered with along with
   *    the callback routine (effectively, interrupts are controlled
   *    via the control bits set during callback-register time).
   */
  if(dev->callback) {
   80a14:	21400917 	ldw	r5,36(r4)
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
   80a18:	18c00404 	addi	r3,r3,16
   *  - Stop on an error with any particular descriptor
   *  - Include any control register bits registered with along with
   *    the callback routine (effectively, interrupts are controlled
   *    via the control bits set during callback-register time).
   */
  if(dev->callback) {
   80a1c:	28000526 	beq	r5,zero,80a34 <alt_avalon_sgdma_do_async_transfer+0x5c>
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
   80a20:	19400037 	ldwio	r5,0(r3)

    control |= (dev->chain_control                          |
                ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK  );

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
   80a24:	21000b17 	ldw	r4,44(r4)
   80a28:	21001814 	ori	r4,r4,96
   80a2c:	2148b03a 	or	r4,r4,r5
   80a30:	00000406 	br	80a44 <alt_avalon_sgdma_do_async_transfer+0x6c>
   *   - Run
   *   - Stop on an error with any particular descriptor
   *   - Disable interrupt generation
   */
  else {
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
   80a34:	19400037 	ldwio	r5,0(r3)
   80a38:	013ffbc4 	movi	r4,-17
   80a3c:	2908703a 	and	r4,r5,r4

    control |= (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK );
    control &= ~ALTERA_AVALON_SGDMA_CONTROL_IE_GLOBAL_MSK;

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
   80a40:	21001814 	ori	r4,r4,96
   80a44:	19000035 	stwio	r4,0(r3)
   80a48:	f800283a 	ret
  alt_u32 control;

  /* Return with error immediately if controller is busy */
  if( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    return -EBUSY;
   80a4c:	00bffc04 	movi	r2,-16
  /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
  return 0;
}
   80a50:	f800283a 	ret

00080a54 <alt_avalon_sgdma_do_sync_transfer>:
  alt_sgdma_descriptor *desc)
{
  alt_u8 status;

  /* Wait for any pending transfers to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
   80a54:	20c00317 	ldw	r3,12(r4)
   80a58:	18800037 	ldwio	r2,0(r3)
   80a5c:	1080040c 	andi	r2,r2,16
   80a60:	103ffc1e 	bne	r2,zero,80a54 <alt_avalon_sgdma_do_sync_transfer>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );


  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
   80a64:	18c00404 	addi	r3,r3,16
   80a68:	19800037 	ldwio	r6,0(r3)
   80a6c:	00bff7c4 	movi	r2,-33
   80a70:	308c703a 	and	r6,r6,r2
   80a74:	19800035 	stwio	r6,0(r3)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
   80a78:	20c00317 	ldw	r3,12(r4)
   80a7c:	01803fc4 	movi	r6,255
   80a80:	19800035 	stwio	r6,0(r3)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
   80a84:	20c00317 	ldw	r3,12(r4)
   80a88:	19400835 	stwio	r5,32(r3)
   * Set up SGDMA controller to:
   * - Disable interrupt generation
   * - Run once a valid descriptor is written to controller
   * - Stop on an error with any particular descriptor
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
   80a8c:	20c00317 	ldw	r3,12(r4)
   80a90:	18c00404 	addi	r3,r3,16
   80a94:	19400037 	ldwio	r5,0(r3)
   80a98:	29401814 	ori	r5,r5,96
   80a9c:	19400035 	stwio	r5,0(r3)
    (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK |
     ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK | 
     IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base)) );

  /* Wait for the descriptor (chain) to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
   80aa0:	20c00317 	ldw	r3,12(r4)
   80aa4:	19400037 	ldwio	r5,0(r3)
   80aa8:	2940040c 	andi	r5,r5,16
   80aac:	283ffc1e 	bne	r5,zero,80aa0 <alt_avalon_sgdma_do_sync_transfer+0x4c>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
   80ab0:	18c00404 	addi	r3,r3,16
   80ab4:	19400037 	ldwio	r5,0(r3)
   80ab8:	2884703a 	and	r2,r5,r2
   80abc:	18800035 	stwio	r2,0(r3)
    (IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) &
     ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK) );

  /* Get & clear status register contents */
  status = IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base);
   80ac0:	20c00317 	ldw	r3,12(r4)
   80ac4:	18800037 	ldwio	r2,0(r3)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
   80ac8:	01003fc4 	movi	r4,255
   80acc:	19000035 	stwio	r4,0(r3)

  return status;
}
   80ad0:	f800283a 	ret

00080ad4 <alt_avalon_sgdma_register_callback>:
  alt_sgdma_dev *dev,
  alt_avalon_sgdma_callback callback,
  alt_u32 chain_control,
  void *context)
{
  dev->callback         = callback;
   80ad4:	21400915 	stw	r5,36(r4)
  dev->callback_context = context;
   80ad8:	21c00a15 	stw	r7,40(r4)
  dev->chain_control    = chain_control;
   80adc:	21800b15 	stw	r6,44(r4)
   80ae0:	f800283a 	ret

00080ae4 <alt_avalon_sgdma_start>:
 */
void alt_avalon_sgdma_start(alt_sgdma_dev *dev)
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
   80ae4:	20800317 	ldw	r2,12(r4)
   80ae8:	10800404 	addi	r2,r2,16
   80aec:	10c00037 	ldwio	r3,0(r2)
  control |= ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
   80af0:	18c00814 	ori	r3,r3,32
   80af4:	10c00035 	stwio	r3,0(r2)
   80af8:	f800283a 	ret

00080afc <alt_avalon_sgdma_stop>:
 */
void alt_avalon_sgdma_stop(alt_sgdma_dev *dev)
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
   80afc:	20800317 	ldw	r2,12(r4)
   80b00:	10800404 	addi	r2,r2,16
   80b04:	11000037 	ldwio	r4,0(r2)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
   80b08:	00fff7c4 	movi	r3,-33
   80b0c:	20c6703a 	and	r3,r4,r3
   80b10:	10c00035 	stwio	r3,0(r2)
   80b14:	f800283a 	ret

00080b18 <alt_avalon_sgdma_check_descriptor_status>:
 *   normally. Or, various error conditions defined in <errno.h>
 */
int alt_avalon_sgdma_check_descriptor_status(alt_sgdma_descriptor *desc)
{
  /* Errors take precedence */
  if( IORD_8DIRECT(&desc->status, 0) &
   80b18:	208007a3 	ldbuio	r2,30(r4)
   80b1c:	10801fcc 	andi	r2,r2,127
   80b20:	1000041e 	bne	r2,zero,80b34 <alt_avalon_sgdma_check_descriptor_status+0x1c>
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) {
    return -EIO;
  }

  if( IORD_8DIRECT(&desc->control, 0) &
   80b24:	208007e3 	ldbuio	r2,31(r4)
   80b28:	1080200c 	andi	r2,r2,128
   80b2c:	1000031e 	bne	r2,zero,80b3c <alt_avalon_sgdma_check_descriptor_status+0x24>
   80b30:	f800283a 	ret
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_OVERFLOW_MSK |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) {
    return -EIO;
   80b34:	00bffec4 	movi	r2,-5
   80b38:	f800283a 	ret
  }

  if( IORD_8DIRECT(&desc->control, 0) &
      ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK) {
    return -EINPROGRESS;
   80b3c:	00bfe244 	movi	r2,-119
  }

    return 0;
}
   80b40:	f800283a 	ret

00080b44 <alt_avalon_sgdma_open>:
 * Returns:
 * - Pointer to SGDMA device instance struct, or null if the device
 *   could not be opened.
 */
alt_sgdma_dev* alt_avalon_sgdma_open (const char* name)
{
   80b44:	defffe04 	addi	sp,sp,-8
  alt_sgdma_dev* dev;

  dev = (alt_sgdma_dev*) alt_find_dev (name, &alt_sgdma_list);
   80b48:	d1600104 	addi	r5,gp,-32764
 * Returns:
 * - Pointer to SGDMA device instance struct, or null if the device
 *   could not be opened.
 */
alt_sgdma_dev* alt_avalon_sgdma_open (const char* name)
{
   80b4c:	dc000015 	stw	r16,0(sp)
   80b50:	dfc00115 	stw	ra,4(sp)
  alt_sgdma_dev* dev;

  dev = (alt_sgdma_dev*) alt_find_dev (name, &alt_sgdma_list);
   80b54:	008102c0 	call	8102c <alt_find_dev>
   80b58:	1021883a 	mov	r16,r2

  if (NULL == dev) {
   80b5c:	1000071e 	bne	r2,zero,80b7c <alt_avalon_sgdma_open+0x38>

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  return ((alt_errno) ? alt_errno() : &errno);
   80b60:	d0a00317 	ldw	r2,-32756(gp)
   80b64:	10000226 	beq	r2,zero,80b70 <alt_avalon_sgdma_open+0x2c>
   80b68:	103ee83a 	callr	r2
   80b6c:	00000106 	br	80b74 <alt_avalon_sgdma_open+0x30>
   80b70:	d0a12b04 	addi	r2,gp,-31572
    ALT_ERRNO = ENODEV;
   80b74:	00c004c4 	movi	r3,19
   80b78:	10c00015 	stw	r3,0(r2)
  }

  return dev;
}
   80b7c:	8005883a 	mov	r2,r16
   80b80:	dfc00117 	ldw	ra,4(sp)
   80b84:	dc000017 	ldw	r16,0(sp)
   80b88:	dec00204 	addi	sp,sp,8
   80b8c:	f800283a 	ret

00080b90 <alt_avalon_sgdma_enable_desc_poll>:
 */
void alt_avalon_sgdma_enable_desc_poll(alt_sgdma_dev *dev, alt_u32 frequency)
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
   80b90:	20c00317 	ldw	r3,12(r4)
   80b94:	18c00404 	addi	r3,r3,16
   80b98:	19000037 	ldwio	r4,0(r3)
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
   80b9c:	00a00434 	movhi	r2,32784
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
            ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
   80ba0:	280a953a 	slli	r5,r5,20
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
   80ba4:	10bfffc4 	addi	r2,r2,-1
   80ba8:	2084703a 	and	r2,r4,r2
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
            ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
   80bac:	295ffc2c 	andhi	r5,r5,32752
   80bb0:	29400134 	orhi	r5,r5,4
   80bb4:	288ab03a 	or	r5,r5,r2
   80bb8:	19400035 	stwio	r5,0(r3)
   80bbc:	f800283a 	ret

00080bc0 <alt_avalon_sgdma_disable_desc_poll>:
 */
void alt_avalon_sgdma_disable_desc_poll(alt_sgdma_dev *dev)
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
   80bc0:	20800317 	ldw	r2,12(r4)
   80bc4:	10800404 	addi	r2,r2,16
   80bc8:	11000037 	ldwio	r4,0(r2)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK;

  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
   80bcc:	00ffff34 	movhi	r3,65532
   80bd0:	18ffffc4 	addi	r3,r3,-1
   80bd4:	20c6703a 	and	r3,r4,r3
   80bd8:	10c00035 	stwio	r3,0(r2)
   80bdc:	f800283a 	ret

00080be0 <alt_avalon_sgdma_construct_descriptor_burst>:
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
   80be0:	288007c3 	ldbu	r2,31(r5)
  int                   read_fixed,
  int                   write_fixed_or_sop,
  int                   read_burst,
  int                   write_burst,
  alt_u8                atlantic_channel)
{
   80be4:	d8c00617 	ldw	r3,24(sp)
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
   80be8:	10801fcc 	andi	r2,r2,127
   80bec:	288007e5 	stbio	r2,31(r5)
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
   80bf0:	3004d23a 	srli	r2,r6,8
   80bf4:	21800005 	stb	r6,0(r4)
  desc->write_addr               = write_addr;
   80bf8:	21c00205 	stb	r7,8(r4)
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
   80bfc:	20800045 	stb	r2,1(r4)
   80c00:	3004d43a 	srli	r2,r6,16
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
   80c04:	21400405 	stb	r5,16(r4)
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
   80c08:	300cd63a 	srli	r6,r6,24
   80c0c:	20800085 	stb	r2,2(r4)
  desc->write_addr               = write_addr;
   80c10:	3804d23a 	srli	r2,r7,8
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
   80c14:	218000c5 	stb	r6,3(r4)
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
   80c18:	20000105 	stb	zero,4(r4)
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
   80c1c:	20800245 	stb	r2,9(r4)
   80c20:	3804d43a 	srli	r2,r7,16
   80c24:	380ed63a 	srli	r7,r7,24
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
   80c28:	20000145 	stb	zero,5(r4)
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
   80c2c:	20800285 	stb	r2,10(r4)
  desc->next                     = (alt_u32 *) next;
   80c30:	2804d23a 	srli	r2,r5,8
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
   80c34:	21c002c5 	stb	r7,11(r4)
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
   80c38:	20000185 	stb	zero,6(r4)
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
   80c3c:	20800445 	stb	r2,17(r4)
   80c40:	2804d43a 	srli	r2,r5,16
   80c44:	280ad63a 	srli	r5,r5,24
  desc->read_addr_pad            = 0x0;
   80c48:	200001c5 	stb	zero,7(r4)
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
   80c4c:	20800485 	stb	r2,18(r4)
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
  desc->next_pad                 = 0x0;
  desc->bytes_to_transfer        = length_or_eop;
   80c50:	d880000b 	ldhu	r2,0(sp)
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
   80c54:	214004c5 	stb	r5,19(r4)
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
   80c58:	20000305 	stb	zero,12(r4)
  desc->next_pad                 = 0x0;
  desc->bytes_to_transfer        = length_or_eop;
   80c5c:	20800605 	stb	r2,24(r4)
   80c60:	1004d23a 	srli	r2,r2,8

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
   80c64:	20000345 	stb	zero,13(r4)
   80c68:	20000385 	stb	zero,14(r4)
  desc->next_pad                 = 0x0;
  desc->bytes_to_transfer        = length_or_eop;
   80c6c:	20800645 	stb	r2,25(r4)
  desc->actual_bytes_transferred = 0;
  desc->status                   = 0x0;

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
   80c70:	d8800417 	ldw	r2,16(sp)

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
   80c74:	200003c5 	stb	zero,15(r4)
  desc->next_pad                 = 0x0;
   80c78:	20000505 	stb	zero,20(r4)
   80c7c:	20000545 	stb	zero,21(r4)
   80c80:	20000585 	stb	zero,22(r4)
   80c84:	200005c5 	stb	zero,23(r4)
  desc->bytes_to_transfer        = length_or_eop;
  desc->actual_bytes_transferred = 0;
   80c88:	20000705 	stb	zero,28(r4)
   80c8c:	20000745 	stb	zero,29(r4)
  desc->status                   = 0x0;
   80c90:	20000785 	stb	zero,30(r4)

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
   80c94:	20800685 	stb	r2,26(r4)
  desc->write_burst              = write_burst;
   80c98:	d8800517 	ldw	r2,20(sp)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
   80c9c:	d9400117 	ldw	r5,4(sp)
  desc->actual_bytes_transferred = 0;
  desc->status                   = 0x0;

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
  desc->write_burst              = write_burst;
   80ca0:	208006c5 	stb	r2,27(r4)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
   80ca4:	d8800217 	ldw	r2,8(sp)
   80ca8:	280ac03a 	cmpne	r5,r5,zero
   80cac:	297fe004 	addi	r5,r5,-128
   80cb0:	1004c03a 	cmpne	r2,r2,zero
   80cb4:	1004907a 	slli	r2,r2,1
   80cb8:	2884b03a 	or	r2,r5,r2
   80cbc:	d9400317 	ldw	r5,12(sp)
   80cc0:	280ac03a 	cmpne	r5,r5,zero
   80cc4:	280a90ba 	slli	r5,r5,2
   80cc8:	114ab03a 	or	r5,r2,r5
   80ccc:	18803fcc 	andi	r2,r3,255
   80cd0:	10000326 	beq	r2,zero,80ce0 <alt_avalon_sgdma_construct_descriptor_burst+0x100>
   80cd4:	18c003cc 	andi	r3,r3,15
   80cd8:	180490fa 	slli	r2,r3,3
   80cdc:	00000106 	br	80ce4 <alt_avalon_sgdma_construct_descriptor_burst+0x104>
   80ce0:	0005883a 	mov	r2,zero
   80ce4:	2884b03a 	or	r2,r5,r2
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to.
   */
  alt_dcache_flush(desc, sizeof(alt_sgdma_descriptor));
   80ce8:	01400804 	movi	r5,32
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
   80cec:	208007c5 	stb	r2,31(r4)
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to.
   */
  alt_dcache_flush(desc, sizeof(alt_sgdma_descriptor));
   80cf0:	0080fb81 	jmpi	80fb8 <alt_dcache_flush>

00080cf4 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>:
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed,
  int                   read_burst,
  int                   write_burst)
{
   80cf4:	defff804 	addi	sp,sp,-32
  alt_avalon_sgdma_construct_descriptor_burst(
   80cf8:	d8800c17 	ldw	r2,48(sp)
   80cfc:	d8000615 	stw	zero,24(sp)
   80d00:	d8000115 	stw	zero,4(sp)
   80d04:	d8800515 	stw	r2,20(sp)
   80d08:	d8800b17 	ldw	r2,44(sp)
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed,
  int                   read_burst,
  int                   write_burst)
{
   80d0c:	dfc00715 	stw	ra,28(sp)
  alt_avalon_sgdma_construct_descriptor_burst(
   80d10:	d8800415 	stw	r2,16(sp)
   80d14:	d8800a17 	ldw	r2,40(sp)
   80d18:	d8800315 	stw	r2,12(sp)
   80d1c:	d8800917 	ldw	r2,36(sp)
   80d20:	d8800215 	stw	r2,8(sp)
   80d24:	d880080b 	ldhu	r2,32(sp)
   80d28:	d8800015 	stw	r2,0(sp)
   80d2c:	0080be00 	call	80be0 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    write_fixed,
    read_burst,
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in mem-to-mem mode
}
   80d30:	dfc00717 	ldw	ra,28(sp)
   80d34:	dec00804 	addi	sp,sp,32
   80d38:	f800283a 	ret

00080d3c <alt_avalon_sgdma_construct_mem_to_mem_desc>:
  alt_u32              *read_addr,
  alt_u32              *write_addr,
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed)
{
   80d3c:	defffa04 	addi	sp,sp,-24
  alt_avalon_sgdma_construct_mem_to_mem_desc_burst(desc, next, read_addr, 
   80d40:	d8800817 	ldw	r2,32(sp)
   80d44:	d8000415 	stw	zero,16(sp)
   80d48:	d8000315 	stw	zero,12(sp)
   80d4c:	d8800215 	stw	r2,8(sp)
   80d50:	d8800717 	ldw	r2,28(sp)
  alt_u32              *read_addr,
  alt_u32              *write_addr,
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed)
{
   80d54:	dfc00515 	stw	ra,20(sp)
  alt_avalon_sgdma_construct_mem_to_mem_desc_burst(desc, next, read_addr, 
   80d58:	d8800115 	stw	r2,4(sp)
   80d5c:	d880060b 	ldhu	r2,24(sp)
   80d60:	d8800015 	stw	r2,0(sp)
   80d64:	0080cf40 	call	80cf4 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>
    write_addr, length, read_fixed, write_fixed, 0, 0);
}
   80d68:	dfc00517 	ldw	ra,20(sp)
   80d6c:	dec00604 	addi	sp,sp,24
   80d70:	f800283a 	ret

00080d74 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>:
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed,
  int                   write_burst)
{
   80d74:	defff804 	addi	sp,sp,-32
  alt_avalon_sgdma_construct_descriptor_burst(
   80d78:	d8800917 	ldw	r2,36(sp)
   80d7c:	39ffffcc 	andi	r7,r7,65535
   80d80:	d9c00015 	stw	r7,0(sp)
   80d84:	d8800515 	stw	r2,20(sp)
   80d88:	d8800817 	ldw	r2,32(sp)
   80d8c:	300f883a 	mov	r7,r6
   80d90:	d8000615 	stw	zero,24(sp)
   80d94:	d8000415 	stw	zero,16(sp)
   80d98:	d8800315 	stw	r2,12(sp)
   80d9c:	d8000215 	stw	zero,8(sp)
   80da0:	d8000115 	stw	zero,4(sp)
   80da4:	000d883a 	mov	r6,zero
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed,
  int                   write_burst)
{
   80da8:	dfc00715 	stw	ra,28(sp)
  alt_avalon_sgdma_construct_descriptor_burst(
   80dac:	0080be00 	call	80be0 <alt_avalon_sgdma_construct_descriptor_burst>
    0x0,            // Read fixed: N/A in stream-to-mem mode
    write_fixed,
    0,              // Read_burst : N/A in stream-to-mem mode
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in stream-to-mem mode
}
   80db0:	dfc00717 	ldw	ra,28(sp)
   80db4:	dec00804 	addi	sp,sp,32
   80db8:	f800283a 	ret

00080dbc <alt_avalon_sgdma_construct_stream_to_mem_desc>:
  alt_sgdma_descriptor *desc,
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed)
{
   80dbc:	defffd04 	addi	sp,sp,-12
  alt_avalon_sgdma_construct_stream_to_mem_desc_burst(desc, next, write_addr, 
   80dc0:	d8800317 	ldw	r2,12(sp)
   80dc4:	d8000115 	stw	zero,4(sp)
   80dc8:	39ffffcc 	andi	r7,r7,65535
   80dcc:	d8800015 	stw	r2,0(sp)
  alt_sgdma_descriptor *desc,
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed)
{
   80dd0:	dfc00215 	stw	ra,8(sp)
  alt_avalon_sgdma_construct_stream_to_mem_desc_burst(desc, next, write_addr, 
   80dd4:	0080d740 	call	80d74 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>
    length_or_eop, write_fixed, 0);
}
   80dd8:	dfc00217 	ldw	ra,8(sp)
   80ddc:	dec00304 	addi	sp,sp,12
   80de0:	f800283a 	ret

00080de4 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>:
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  int                   read_burst,
  alt_u8                atlantic_channel)
{
   80de4:	defff804 	addi	sp,sp,-32
  alt_avalon_sgdma_construct_descriptor_burst(
   80de8:	d8800c03 	ldbu	r2,48(sp)
   80dec:	39ffffcc 	andi	r7,r7,65535
   80df0:	d9c00015 	stw	r7,0(sp)
   80df4:	d8800615 	stw	r2,24(sp)
   80df8:	d8800b17 	ldw	r2,44(sp)
   80dfc:	d8000515 	stw	zero,20(sp)
   80e00:	000f883a 	mov	r7,zero
   80e04:	d8800415 	stw	r2,16(sp)
   80e08:	d8800917 	ldw	r2,36(sp)
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  int                   read_burst,
  alt_u8                atlantic_channel)
{
   80e0c:	dfc00715 	stw	ra,28(sp)
  alt_avalon_sgdma_construct_descriptor_burst(
   80e10:	d8800315 	stw	r2,12(sp)
   80e14:	d8800817 	ldw	r2,32(sp)
   80e18:	d8800215 	stw	r2,8(sp)
   80e1c:	d8800a17 	ldw	r2,40(sp)
   80e20:	d8800115 	stw	r2,4(sp)
   80e24:	0080be00 	call	80be0 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    generate_sop,
    read_burst,
    0,                 // Write_burst : N/A in mem-to-stream mode
    atlantic_channel);
}
   80e28:	dfc00717 	ldw	ra,28(sp)
   80e2c:	dec00804 	addi	sp,sp,32
   80e30:	f800283a 	ret

00080e34 <alt_avalon_sgdma_construct_mem_to_stream_desc>:
  alt_u16               length,
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  alt_u8                atlantic_channel)
{
   80e34:	defffa04 	addi	sp,sp,-24
  alt_avalon_sgdma_construct_mem_to_stream_desc_burst(desc, next, read_addr, 
   80e38:	d8800903 	ldbu	r2,36(sp)
   80e3c:	d8000315 	stw	zero,12(sp)
   80e40:	39ffffcc 	andi	r7,r7,65535
   80e44:	d8800415 	stw	r2,16(sp)
   80e48:	d8800817 	ldw	r2,32(sp)
  alt_u16               length,
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  alt_u8                atlantic_channel)
{
   80e4c:	dfc00515 	stw	ra,20(sp)
  alt_avalon_sgdma_construct_mem_to_stream_desc_burst(desc, next, read_addr, 
   80e50:	d8800215 	stw	r2,8(sp)
   80e54:	d8800717 	ldw	r2,28(sp)
   80e58:	d8800115 	stw	r2,4(sp)
   80e5c:	d8800617 	ldw	r2,24(sp)
   80e60:	d8800015 	stw	r2,0(sp)
   80e64:	0080de40 	call	80de4 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>
    length, read_fixed, generate_sop, generate_eop, 0, atlantic_channel);

}
   80e68:	dfc00517 	ldw	ra,20(sp)
   80e6c:	dec00604 	addi	sp,sp,24
   80e70:	f800283a 	ret

00080e74 <alt_avalon_sgdma_construct_descriptor>:
  alt_u16               length_or_eop,
  int                   generate_eop,
  int                   read_fixed,
  int                   write_fixed_or_sop,
  alt_u8                atlantic_channel)
{
   80e74:	defff804 	addi	sp,sp,-32
  alt_avalon_sgdma_construct_descriptor_burst(desc, next, read_addr, 
   80e78:	d8800c03 	ldbu	r2,48(sp)
   80e7c:	d8000515 	stw	zero,20(sp)
   80e80:	d8000415 	stw	zero,16(sp)
   80e84:	d8800615 	stw	r2,24(sp)
   80e88:	d8800b17 	ldw	r2,44(sp)
  alt_u16               length_or_eop,
  int                   generate_eop,
  int                   read_fixed,
  int                   write_fixed_or_sop,
  alt_u8                atlantic_channel)
{
   80e8c:	dfc00715 	stw	ra,28(sp)
  alt_avalon_sgdma_construct_descriptor_burst(desc, next, read_addr, 
   80e90:	d8800315 	stw	r2,12(sp)
   80e94:	d8800a17 	ldw	r2,40(sp)
   80e98:	d8800215 	stw	r2,8(sp)
   80e9c:	d8800917 	ldw	r2,36(sp)
   80ea0:	d8800115 	stw	r2,4(sp)
   80ea4:	d880080b 	ldhu	r2,32(sp)
   80ea8:	d8800015 	stw	r2,0(sp)
   80eac:	0080be00 	call	80be0 <alt_avalon_sgdma_construct_descriptor_burst>
    write_addr, length_or_eop, generate_eop, read_fixed, write_fixed_or_sop, 
    0, 0, atlantic_channel);
}
   80eb0:	dfc00717 	ldw	ra,28(sp)
   80eb4:	dec00804 	addi	sp,sp,32
   80eb8:	f800283a 	ret

00080ebc <alt_avalon_sgdma_init>:

  /* 
   * Halt any current transactions (reset the device)
   * SW reset is written twice per SGDMA documentation 
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
   80ebc:	20c00317 	ldw	r3,12(r4)
 * This routine disables interrupts, future descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_avalon_sgdma_init (alt_sgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
   80ec0:	defffb04 	addi	sp,sp,-20
   80ec4:	dc800315 	stw	r18,12(sp)
   80ec8:	dc400215 	stw	r17,8(sp)
   80ecc:	dc000115 	stw	r16,4(sp)
   80ed0:	dfc00415 	stw	ra,16(sp)
   80ed4:	2021883a 	mov	r16,r4
   80ed8:	2823883a 	mov	r17,r5
   80edc:	3025883a 	mov	r18,r6

  /* 
   * Halt any current transactions (reset the device)
   * SW reset is written twice per SGDMA documentation 
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
   80ee0:	00800074 	movhi	r2,1
   80ee4:	18800435 	stwio	r2,16(r3)
    ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
   80ee8:	20c00317 	ldw	r3,12(r4)
   80eec:	18800435 	stwio	r2,16(r3)

  /*
   * Disable interrupts, halt future descriptor processing,
   * and clear status register content
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 0x0);
   80ef0:	20800317 	ldw	r2,12(r4)
   80ef4:	10000435 	stwio	zero,16(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
   80ef8:	20800317 	ldw	r2,12(r4)
   80efc:	00c03fc4 	movi	r3,255
   80f00:	10c00035 	stwio	r3,0(r2)

  /* Register this instance of the SGDMA controller with HAL */
  alt_dev_llist_insert((alt_dev_llist*) dev, &alt_sgdma_list);
   80f04:	d1600104 	addi	r5,gp,-32764
   80f08:	0080fc00 	call	80fc0 <alt_dev_llist_insert>

  /* Install IRQ handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(ic_id, irq, alt_avalon_sgdma_irq, dev, 0x0);
   80f0c:	01800234 	movhi	r6,8
   80f10:	d8000015 	stw	zero,0(sp)
   80f14:	800f883a 	mov	r7,r16
   80f18:	31825f04 	addi	r6,r6,2428
   80f1c:	900b883a 	mov	r5,r18
   80f20:	8809883a 	mov	r4,r17
   80f24:	00810ac0 	call	810ac <alt_ic_isr_register>
#else
  alt_irq_register(irq, dev, alt_avalon_sgdma_irq);
#endif  
}
   80f28:	dfc00417 	ldw	ra,16(sp)
   80f2c:	dc800317 	ldw	r18,12(sp)
   80f30:	dc400217 	ldw	r17,8(sp)
   80f34:	dc000117 	ldw	r16,4(sp)
   80f38:	dec00504 	addi	sp,sp,20
   80f3c:	f800283a 	ret

00080f40 <alt_busy_sleep>:
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
   80f40:	0140f874 	movhi	r5,993
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
   80f44:	defffe04 	addi	sp,sp,-8
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
   80f48:	297e0f84 	addi	r5,r5,-1986
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
   80f4c:	dc000015 	stw	r16,0(sp)
   80f50:	dfc00115 	stw	ra,4(sp)
   80f54:	2021883a 	mov	r16,r4
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
   80f58:	00813240 	call	81324 <__udivsi3>
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
   80f5c:	10000e26 	beq	r2,zero,80f98 <alt_busy_sleep+0x58>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
   80f60:	01600034 	movhi	r5,32768
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
   80f64:	013f07f4 	movhi	r4,64543
   80f68:	0007883a 	mov	r3,zero
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
   80f6c:	297fffc4 	addi	r5,r5,-1
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
   80f70:	2101f084 	addi	r4,r4,1986
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
   80f74:	297fffc4 	addi	r5,r5,-1
   80f78:	283ffe1e 	bne	r5,zero,80f74 <alt_busy_sleep+0x34>
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
   80f7c:	18c00044 	addi	r3,r3,1
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
   80f80:	8121883a 	add	r16,r16,r4
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
   80f84:	18bffb16 	blt	r3,r2,80f74 <alt_busy_sleep+0x34>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
   80f88:	84000864 	muli	r16,r16,33
   80f8c:	843fffc4 	addi	r16,r16,-1
   80f90:	803ffe1e 	bne	r16,zero,80f8c <alt_busy_sleep+0x4c>
   80f94:	00000306 	br	80fa4 <alt_busy_sleep+0x64>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
   80f98:	84000864 	muli	r16,r16,33
   80f9c:	843fffc4 	addi	r16,r16,-1
   80fa0:	043ffe16 	blt	zero,r16,80f9c <alt_busy_sleep+0x5c>
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
}
   80fa4:	0005883a 	mov	r2,zero
   80fa8:	dfc00117 	ldw	ra,4(sp)
   80fac:	dc000017 	ldw	r16,0(sp)
   80fb0:	dec00204 	addi	sp,sp,8
   80fb4:	f800283a 	ret

00080fb8 <alt_dcache_flush>:
 *
 * Any dirty lines in the data cache are written back to memory.
 */

void alt_dcache_flush (void* start, alt_u32 len)
{
   80fb8:	f800283a 	ret

00080fbc <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
   80fbc:	f800283a 	ret

00080fc0 <alt_dev_llist_insert>:
{
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
   80fc0:	20000226 	beq	r4,zero,80fcc <alt_dev_llist_insert+0xc>
   80fc4:	20800217 	ldw	r2,8(r4)
   80fc8:	1000101e 	bne	r2,zero,8100c <alt_dev_llist_insert+0x4c>
   80fcc:	d0a00317 	ldw	r2,-32756(gp)
   80fd0:	10000926 	beq	r2,zero,80ff8 <alt_dev_llist_insert+0x38>
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
   80fd4:	deffff04 	addi	sp,sp,-4
   80fd8:	dfc00015 	stw	ra,0(sp)
   80fdc:	103ee83a 	callr	r2
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  {
    ALT_ERRNO = EINVAL;
   80fe0:	00c00584 	movi	r3,22
   80fe4:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
   80fe8:	00bffa84 	movi	r2,-22
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
}
   80fec:	dfc00017 	ldw	ra,0(sp)
   80ff0:	dec00104 	addi	sp,sp,4
   80ff4:	f800283a 	ret
   80ff8:	d0a12b04 	addi	r2,gp,-31572
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  {
    ALT_ERRNO = EINVAL;
   80ffc:	00c00584 	movi	r3,22
   81000:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
   81004:	00bffa84 	movi	r2,-22
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
}
   81008:	f800283a 	ret

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  entry->next     = list->next;
   8100c:	28800017 	ldw	r2,0(r5)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
   81010:	21400115 	stw	r5,4(r4)
  entry->next     = list->next;
   81014:	20800015 	stw	r2,0(r4)

  list->next->previous = entry;
   81018:	28800017 	ldw	r2,0(r5)
   8101c:	11000115 	stw	r4,4(r2)
  list->next           = entry;
   81020:	29000015 	stw	r4,0(r5)
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
   81024:	0005883a 	mov	r2,zero
   81028:	f800283a 	ret

0008102c <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
   8102c:	defffb04 	addi	sp,sp,-20
   81030:	dcc00315 	stw	r19,12(sp)
   81034:	dc800215 	stw	r18,8(sp)
   81038:	dc400115 	stw	r17,4(sp)
   8103c:	dc000015 	stw	r16,0(sp)
   81040:	dfc00415 	stw	ra,16(sp)
   81044:	2027883a 	mov	r19,r4
   81048:	2823883a 	mov	r17,r5
  alt_dev* next = (alt_dev*) llist->next;
   8104c:	2c000017 	ldw	r16,0(r5)
  alt_32 len;

  len  = strlen(name) + 1;
   81050:	00812100 	call	81210 <strlen>
   81054:	14800044 	addi	r18,r2,1
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
   81058:	84400726 	beq	r16,r17,81078 <alt_find_dev+0x4c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
   8105c:	81000217 	ldw	r4,8(r16)
   81060:	900d883a 	mov	r6,r18
   81064:	980b883a 	mov	r5,r19
   81068:	00811e00 	call	811e0 <memcmp>
   8106c:	10000426 	beq	r2,zero,81080 <alt_find_dev+0x54>
    {
      /* match found */

      return next;
    }
    next = (alt_dev*) next->llist.next;
   81070:	84000017 	ldw	r16,0(r16)
   81074:	003ff806 	br	81058 <alt_find_dev+0x2c>
  }
  
  /* No match found */
  
  return NULL;
   81078:	0005883a 	mov	r2,zero
   8107c:	00000106 	br	81084 <alt_find_dev+0x58>
   81080:	8005883a 	mov	r2,r16
}
   81084:	dfc00417 	ldw	ra,16(sp)
   81088:	dcc00317 	ldw	r19,12(sp)
   8108c:	dc800217 	ldw	r18,8(sp)
   81090:	dc400117 	ldw	r17,4(sp)
   81094:	dc000017 	ldw	r16,0(sp)
   81098:	dec00504 	addi	sp,sp,20
   8109c:	f800283a 	ret

000810a0 <alt_icache_flush_all>:
 */

void alt_icache_flush_all (void)
{
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
   810a0:	01440004 	movi	r5,4096
   810a4:	0009883a 	mov	r4,zero
   810a8:	00811a81 	jmpi	811a8 <alt_icache_flush>

000810ac <alt_ic_isr_register>:
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
   810ac:	00811381 	jmpi	81138 <alt_iic_isr_register>

000810b0 <alt_ic_irq_enable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   810b0:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   810b4:	00bfff84 	movi	r2,-2
   810b8:	2084703a 	and	r2,r4,r2
   810bc:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active |= (1 << id);
   810c0:	00c00044 	movi	r3,1
   810c4:	d0a12a17 	ldw	r2,-31576(gp)
   810c8:	194a983a 	sll	r5,r3,r5
   810cc:	288ab03a 	or	r5,r5,r2
   810d0:	d1612a15 	stw	r5,-31576(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
   810d4:	d0a12a17 	ldw	r2,-31576(gp)
   810d8:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   810dc:	2001703a 	wrctl	status,r4
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_enable(irq);
}
   810e0:	0005883a 	mov	r2,zero
   810e4:	f800283a 	ret

000810e8 <alt_ic_irq_disable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   810e8:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   810ec:	00bfff84 	movi	r2,-2
   810f0:	2084703a 	and	r2,r4,r2
   810f4:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active &= ~(1 << id);
   810f8:	00ffff84 	movi	r3,-2
   810fc:	d0a12a17 	ldw	r2,-31576(gp)
   81100:	194a183a 	rol	r5,r3,r5
   81104:	288a703a 	and	r5,r5,r2
   81108:	d1612a15 	stw	r5,-31576(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
   8110c:	d0a12a17 	ldw	r2,-31576(gp)
   81110:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   81114:	2001703a 	wrctl	status,r4
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_disable(irq);
}
   81118:	0005883a 	mov	r2,zero
   8111c:	f800283a 	ret

00081120 <alt_ic_irq_enabled>:
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
   81120:	000730fa 	rdctl	r3,ienable

    return (irq_enabled & (1 << irq)) ? 1: 0;
   81124:	00800044 	movi	r2,1
   81128:	1144983a 	sll	r2,r2,r5
   8112c:	10c4703a 	and	r2,r2,r3
}
   81130:	1004c03a 	cmpne	r2,r2,zero
   81134:	f800283a 	ret

00081138 <alt_iic_isr_register>:
{
  int rc = -EINVAL;  
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  alt_irq_context status;

  if (id < ALT_NIRQ)
   81138:	00c007c4 	movi	r3,31
   8113c:	19401616 	blt	r3,r5,81198 <alt_iic_isr_register+0x60>
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
   81140:	defffe04 	addi	sp,sp,-8
   81144:	dfc00115 	stw	ra,4(sp)
   81148:	dc000015 	stw	r16,0(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   8114c:	0021303a 	rdctl	r16,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   81150:	00ffff84 	movi	r3,-2
   81154:	80c6703a 	and	r3,r16,r3
   81158:	1801703a 	wrctl	status,r3
     * state.
     */

    status = alt_irq_disable_all();

    alt_irq[id].handler = isr;
   8115c:	280490fa 	slli	r2,r5,3
   81160:	00c00234 	movhi	r3,8
   81164:	18c87a04 	addi	r3,r3,8680
   81168:	1885883a 	add	r2,r3,r2
   8116c:	11800015 	stw	r6,0(r2)
    alt_irq[id].context = isr_context;
   81170:	11c00115 	stw	r7,4(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
   81174:	30000226 	beq	r6,zero,81180 <alt_iic_isr_register+0x48>
   81178:	00810b00 	call	810b0 <alt_ic_irq_enable>
   8117c:	00000106 	br	81184 <alt_iic_isr_register+0x4c>
   81180:	00810e80 	call	810e8 <alt_ic_irq_disable>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   81184:	8001703a 	wrctl	status,r16

    alt_irq_enable_all(status);
  }

  return rc; 
}
   81188:	dfc00117 	ldw	ra,4(sp)
   8118c:	dc000017 	ldw	r16,0(sp)
   81190:	dec00204 	addi	sp,sp,8
   81194:	f800283a 	ret
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  int rc = -EINVAL;  
   81198:	00bffa84 	movi	r2,-22
   8119c:	f800283a 	ret

000811a0 <altera_nios2_qsys_irq_init>:
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_qsys_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
   811a0:	000170fa 	wrctl	ienable,zero
   811a4:	f800283a 	ret

000811a8 <alt_icache_flush>:
  if (len > NIOS2_ICACHE_SIZE)
  {
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;
   811a8:	00840004 	movi	r2,4096
   811ac:	1140012e 	bgeu	r2,r5,811b4 <alt_icache_flush+0xc>
   811b0:	100b883a 	mov	r5,r2
   811b4:	214b883a 	add	r5,r4,r5

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
   811b8:	2005883a 	mov	r2,r4
   811bc:	1140032e 	bgeu	r2,r5,811cc <alt_icache_flush+0x24>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
   811c0:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
   811c4:	10800804 	addi	r2,r2,32
   811c8:	003ffc06 	br	811bc <alt_icache_flush+0x14>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
   811cc:	210007cc 	andi	r4,r4,31
   811d0:	20000126 	beq	r4,zero,811d8 <alt_icache_flush+0x30>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
   811d4:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
   811d8:	0000203a 	flushp
   811dc:	f800283a 	ret

000811e0 <memcmp>:
   811e0:	218d883a 	add	r6,r4,r6
   811e4:	21800826 	beq	r4,r6,81208 <memcmp+0x28>
   811e8:	20800003 	ldbu	r2,0(r4)
   811ec:	28c00003 	ldbu	r3,0(r5)
   811f0:	10c00226 	beq	r2,r3,811fc <memcmp+0x1c>
   811f4:	10c5c83a 	sub	r2,r2,r3
   811f8:	f800283a 	ret
   811fc:	21000044 	addi	r4,r4,1
   81200:	29400044 	addi	r5,r5,1
   81204:	003ff706 	br	811e4 <memcmp+0x4>
   81208:	0005883a 	mov	r2,zero
   8120c:	f800283a 	ret

00081210 <strlen>:
   81210:	2005883a 	mov	r2,r4
   81214:	10c00007 	ldb	r3,0(r2)
   81218:	18000226 	beq	r3,zero,81224 <strlen+0x14>
   8121c:	10800044 	addi	r2,r2,1
   81220:	003ffc06 	br	81214 <strlen+0x4>
   81224:	1105c83a 	sub	r2,r2,r4
   81228:	f800283a 	ret

0008122c <__divsi3>:
   8122c:	20001b16 	blt	r4,zero,8129c <__divsi3+0x70>
   81230:	000f883a 	mov	r7,zero
   81234:	28001616 	blt	r5,zero,81290 <__divsi3+0x64>
   81238:	200d883a 	mov	r6,r4
   8123c:	29001a2e 	bgeu	r5,r4,812a8 <__divsi3+0x7c>
   81240:	00800804 	movi	r2,32
   81244:	00c00044 	movi	r3,1
   81248:	00000106 	br	81250 <__divsi3+0x24>
   8124c:	10000d26 	beq	r2,zero,81284 <__divsi3+0x58>
   81250:	294b883a 	add	r5,r5,r5
   81254:	10bfffc4 	addi	r2,r2,-1
   81258:	18c7883a 	add	r3,r3,r3
   8125c:	293ffb36 	bltu	r5,r4,8124c <__divsi3+0x20>
   81260:	0005883a 	mov	r2,zero
   81264:	18000726 	beq	r3,zero,81284 <__divsi3+0x58>
   81268:	0005883a 	mov	r2,zero
   8126c:	31400236 	bltu	r6,r5,81278 <__divsi3+0x4c>
   81270:	314dc83a 	sub	r6,r6,r5
   81274:	10c4b03a 	or	r2,r2,r3
   81278:	1806d07a 	srli	r3,r3,1
   8127c:	280ad07a 	srli	r5,r5,1
   81280:	183ffa1e 	bne	r3,zero,8126c <__divsi3+0x40>
   81284:	38000126 	beq	r7,zero,8128c <__divsi3+0x60>
   81288:	0085c83a 	sub	r2,zero,r2
   8128c:	f800283a 	ret
   81290:	014bc83a 	sub	r5,zero,r5
   81294:	39c0005c 	xori	r7,r7,1
   81298:	003fe706 	br	81238 <__divsi3+0xc>
   8129c:	0109c83a 	sub	r4,zero,r4
   812a0:	01c00044 	movi	r7,1
   812a4:	003fe306 	br	81234 <__divsi3+0x8>
   812a8:	00c00044 	movi	r3,1
   812ac:	003fee06 	br	81268 <__divsi3+0x3c>

000812b0 <__modsi3>:
   812b0:	20001716 	blt	r4,zero,81310 <__modsi3+0x60>
   812b4:	000f883a 	mov	r7,zero
   812b8:	2005883a 	mov	r2,r4
   812bc:	28001216 	blt	r5,zero,81308 <__modsi3+0x58>
   812c0:	2900162e 	bgeu	r5,r4,8131c <__modsi3+0x6c>
   812c4:	01800804 	movi	r6,32
   812c8:	00c00044 	movi	r3,1
   812cc:	00000106 	br	812d4 <__modsi3+0x24>
   812d0:	30000a26 	beq	r6,zero,812fc <__modsi3+0x4c>
   812d4:	294b883a 	add	r5,r5,r5
   812d8:	31bfffc4 	addi	r6,r6,-1
   812dc:	18c7883a 	add	r3,r3,r3
   812e0:	293ffb36 	bltu	r5,r4,812d0 <__modsi3+0x20>
   812e4:	18000526 	beq	r3,zero,812fc <__modsi3+0x4c>
   812e8:	1806d07a 	srli	r3,r3,1
   812ec:	11400136 	bltu	r2,r5,812f4 <__modsi3+0x44>
   812f0:	1145c83a 	sub	r2,r2,r5
   812f4:	280ad07a 	srli	r5,r5,1
   812f8:	183ffb1e 	bne	r3,zero,812e8 <__modsi3+0x38>
   812fc:	38000126 	beq	r7,zero,81304 <__modsi3+0x54>
   81300:	0085c83a 	sub	r2,zero,r2
   81304:	f800283a 	ret
   81308:	014bc83a 	sub	r5,zero,r5
   8130c:	003fec06 	br	812c0 <__modsi3+0x10>
   81310:	0109c83a 	sub	r4,zero,r4
   81314:	01c00044 	movi	r7,1
   81318:	003fe706 	br	812b8 <__modsi3+0x8>
   8131c:	00c00044 	movi	r3,1
   81320:	003ff106 	br	812e8 <__modsi3+0x38>

00081324 <__udivsi3>:
   81324:	200d883a 	mov	r6,r4
   81328:	2900152e 	bgeu	r5,r4,81380 <__udivsi3+0x5c>
   8132c:	28001416 	blt	r5,zero,81380 <__udivsi3+0x5c>
   81330:	00800804 	movi	r2,32
   81334:	00c00044 	movi	r3,1
   81338:	00000206 	br	81344 <__udivsi3+0x20>
   8133c:	10000e26 	beq	r2,zero,81378 <__udivsi3+0x54>
   81340:	28000516 	blt	r5,zero,81358 <__udivsi3+0x34>
   81344:	294b883a 	add	r5,r5,r5
   81348:	10bfffc4 	addi	r2,r2,-1
   8134c:	18c7883a 	add	r3,r3,r3
   81350:	293ffa36 	bltu	r5,r4,8133c <__udivsi3+0x18>
   81354:	18000826 	beq	r3,zero,81378 <__udivsi3+0x54>
   81358:	0005883a 	mov	r2,zero
   8135c:	31400236 	bltu	r6,r5,81368 <__udivsi3+0x44>
   81360:	314dc83a 	sub	r6,r6,r5
   81364:	10c4b03a 	or	r2,r2,r3
   81368:	1806d07a 	srli	r3,r3,1
   8136c:	280ad07a 	srli	r5,r5,1
   81370:	183ffa1e 	bne	r3,zero,8135c <__udivsi3+0x38>
   81374:	f800283a 	ret
   81378:	0005883a 	mov	r2,zero
   8137c:	f800283a 	ret
   81380:	00c00044 	movi	r3,1
   81384:	003ff406 	br	81358 <__udivsi3+0x34>

00081388 <__umodsi3>:
   81388:	2005883a 	mov	r2,r4
   8138c:	2900122e 	bgeu	r5,r4,813d8 <__umodsi3+0x50>
   81390:	28001116 	blt	r5,zero,813d8 <__umodsi3+0x50>
   81394:	01800804 	movi	r6,32
   81398:	00c00044 	movi	r3,1
   8139c:	00000206 	br	813a8 <__umodsi3+0x20>
   813a0:	30000c26 	beq	r6,zero,813d4 <__umodsi3+0x4c>
   813a4:	28000516 	blt	r5,zero,813bc <__umodsi3+0x34>
   813a8:	294b883a 	add	r5,r5,r5
   813ac:	31bfffc4 	addi	r6,r6,-1
   813b0:	18c7883a 	add	r3,r3,r3
   813b4:	293ffa36 	bltu	r5,r4,813a0 <__umodsi3+0x18>
   813b8:	18000626 	beq	r3,zero,813d4 <__umodsi3+0x4c>
   813bc:	1806d07a 	srli	r3,r3,1
   813c0:	11400136 	bltu	r2,r5,813c8 <__umodsi3+0x40>
   813c4:	1145c83a 	sub	r2,r2,r5
   813c8:	280ad07a 	srli	r5,r5,1
   813cc:	183ffb1e 	bne	r3,zero,813bc <__umodsi3+0x34>
   813d0:	f800283a 	ret
   813d4:	f800283a 	ret
   813d8:	00c00044 	movi	r3,1
   813dc:	003ff706 	br	813bc <__umodsi3+0x34>
